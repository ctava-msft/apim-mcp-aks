{
  "$schema": "https://schema.management.azure.com/schemas/2018-05-01/subscriptionDeploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "metadata": {
    "_generator": {
      "name": "bicep",
      "version": "0.40.2.10011",
      "templateHash": "13834282070223999868"
    }
  },
  "parameters": {
    "environmentName": {
      "type": "string",
      "minLength": 1,
      "maxLength": 64,
      "metadata": {
        "description": "Name of the the environment which is used to generate a short unique hash used in all resources."
      }
    },
    "location": {
      "type": "string",
      "allowedValues": [
        "australiaeast",
        "eastasia",
        "eastus",
        "eastus2",
        "northeurope",
        "southcentralus",
        "southeastasia",
        "swedencentral",
        "uksouth",
        "westus2",
        "eastus2euap"
      ],
      "metadata": {
        "azd": {
          "type": "location"
        },
        "description": "Primary location for all resources"
      },
      "minLength": 1
    },
    "vnetEnabled": {
      "type": "bool"
    },
    "apiServiceName": {
      "type": "string",
      "defaultValue": ""
    },
    "apiUserAssignedIdentityName": {
      "type": "string",
      "defaultValue": ""
    },
    "applicationInsightsName": {
      "type": "string",
      "defaultValue": ""
    },
    "logAnalyticsName": {
      "type": "string",
      "defaultValue": ""
    },
    "resourceGroupName": {
      "type": "string",
      "defaultValue": ""
    },
    "storageAccountName": {
      "type": "string",
      "defaultValue": ""
    },
    "vNetName": {
      "type": "string",
      "defaultValue": ""
    },
    "mcpEntraApplicationDisplayName": {
      "type": "string",
      "defaultValue": ""
    },
    "mcpEntraApplicationUniqueName": {
      "type": "string",
      "defaultValue": ""
    },
    "existingEntraAppId": {
      "type": "string",
      "defaultValue": ""
    },
    "disableLocalAuth": {
      "type": "bool",
      "defaultValue": true
    },
    "foundryName": {
      "type": "string",
      "defaultValue": ""
    },
    "foundryModelDeploymentName": {
      "type": "string",
      "defaultValue": "gpt-5.2-chat"
    },
    "foundryModelName": {
      "type": "string",
      "defaultValue": "gpt-5.2-chat"
    },
    "foundryModelVersion": {
      "type": "string",
      "defaultValue": "2025-12-11"
    },
    "foundryModelCapacity": {
      "type": "int",
      "defaultValue": 10
    },
    "embeddingModelDeploymentName": {
      "type": "string",
      "defaultValue": "text-embedding-3-large"
    },
    "embeddingModelName": {
      "type": "string",
      "defaultValue": "text-embedding-3-large"
    },
    "embeddingModelVersion": {
      "type": "string",
      "defaultValue": "1"
    },
    "embeddingModelCapacity": {
      "type": "int",
      "defaultValue": 10
    },
    "cosmosDbAccountName": {
      "type": "string",
      "defaultValue": ""
    },
    "cosmosDatabaseName": {
      "type": "string",
      "defaultValue": "mcpdb"
    },
    "searchServiceName": {
      "type": "string",
      "defaultValue": ""
    },
    "searchIndexName": {
      "type": "string",
      "defaultValue": "task-instructions"
    },
    "fabricCapacityName": {
      "type": "string",
      "defaultValue": ""
    },
    "fabricSkuName": {
      "type": "string",
      "defaultValue": "F2",
      "allowedValues": [
        "F2",
        "F4",
        "F8",
        "F16",
        "F32",
        "F64",
        "F128",
        "F256",
        "F512",
        "F1024",
        "F2048"
      ]
    },
    "fabricAdminEmail": {
      "type": "string",
      "defaultValue": ""
    },
    "fabricEnabled": {
      "type": "bool",
      "defaultValue": false
    },
    "fabricDataAgentsEnabled": {
      "type": "bool",
      "defaultValue": false,
      "metadata": {
        "description": "Enable Fabric Data Agents for lakehouse, warehouse, pipeline, and semantic model operations"
      }
    },
    "fabricWorkspaceId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Fabric workspace ID for data agents (optional - can be created separately)"
      }
    },
    "agentIdentityEnabled": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Enable Entra Agent Identity for the Next Best Action agent (preview feature)"
      }
    },
    "agentBlueprintDisplayName": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Display name for the Agent Identity Blueprint"
      }
    },
    "agentIdentityDisplayName": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Display name for the Next Best Action Agent Identity"
      }
    },
    "agentSponsorPrincipalId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Principal ID of sponsor user for agent identity (admin user)"
      }
    },
    "developerPrincipalId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Principal ID of developer user for local development Cosmos DB access (optional)"
      }
    },
    "developerIpAddress": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Developer IP address for Cosmos DB firewall access (optional, for local development)"
      }
    },
    "approvalLogicAppEnabled": {
      "type": "bool",
      "defaultValue": false,
      "metadata": {
        "description": "Enable the approval Logic App for CI/CD governance"
      }
    },
    "teamsChannelId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Teams channel ID for approval notifications"
      }
    },
    "teamsGroupId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Teams group/team ID for approval notifications"
      }
    },
    "approvalTimeoutHours": {
      "type": "int",
      "defaultValue": 2,
      "metadata": {
        "description": "Approval timeout in hours"
      }
    },
    "grafanaEnabled": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Enable Azure Managed Grafana for AKS monitoring dashboards"
      }
    },
    "grafanaName": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Name for the Azure Managed Grafana instance"
      }
    },
    "defenderEnabled": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Enable Microsoft Defender for Cloud"
      }
    },
    "defenderSecurityContactEmail": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Email address for Defender security contact notifications"
      }
    },
    "defenderSecurityContactPhone": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Phone number for Defender security contact notifications"
      }
    },
    "defenderForContainersEnabled": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Enable Defender for Containers"
      }
    },
    "defenderForKeyVaultEnabled": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Enable Defender for Key Vault"
      }
    },
    "defenderForCosmosDBEnabled": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Enable Defender for Azure Cosmos DB"
      }
    },
    "defenderForAPIsEnabled": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Enable Defender for APIs (API Management)"
      }
    },
    "defenderForResourceManagerEnabled": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Enable Defender for Resource Manager"
      }
    },
    "defenderForContainerRegistryEnabled": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Enable Defender for Container Registries"
      }
    },
    "purviewEnabled": {
      "type": "bool",
      "defaultValue": false,
      "metadata": {
        "description": "Enable Microsoft Purview for data governance and compliance"
      }
    },
    "purviewAccountName": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Name for the Microsoft Purview account"
      }
    }
  },
  "variables": {
    "$fxv#0": {
      "analysisServicesServers": "as",
      "apiManagementService": "apim-",
      "appConfigurationConfigurationStores": "appcs-",
      "applications": "app-",
      "appManagedEnvironments": "cae-",
      "appContainerApps": "ca-",
      "authorizationPolicyDefinitions": "policy-",
      "automationAutomationAccounts": "aa-",
      "blueprintBlueprints": "bp-",
      "blueprintBlueprintsArtifacts": "bpa-",
      "cacheRedis": "redis-",
      "cdnProfiles": "cdnp-",
      "cdnProfilesEndpoints": "cdne-",
      "cognitiveServicesAccounts": "cog-",
      "cognitiveServicesFormRecognizer": "cog-fr-",
      "cognitiveServicesTextAnalytics": "cog-ta-",
      "computeAvailabilitySets": "avail-",
      "computeCloudServices": "cld-",
      "computeDiskEncryptionSets": "des",
      "computeDisks": "disk",
      "computeDisksOs": "osdisk",
      "computeGalleries": "gal",
      "computeSnapshots": "snap-",
      "computeVirtualMachines": "vm",
      "computeVirtualMachineScaleSets": "vmss-",
      "containerInstanceContainerGroups": "ci",
      "containerRegistryRegistries": "cr",
      "containerServiceManagedClusters": "aks-",
      "databricksWorkspaces": "dbw-",
      "dataFactoryFactories": "adf-",
      "dataLakeAnalyticsAccounts": "dla",
      "dataLakeStoreAccounts": "dls",
      "dataMigrationServices": "dms-",
      "dBforMySQLServers": "mysql-",
      "dBforPostgreSQLServers": "psql-",
      "devicesIotHubs": "iot-",
      "devicesProvisioningServices": "provs-",
      "devicesProvisioningServicesCertificates": "pcert-",
      "documentDBDatabaseAccounts": "cosmos-",
      "eventGridDomains": "evgd-",
      "eventGridDomainsTopics": "evgt-",
      "eventGridEventSubscriptions": "evgs-",
      "eventHubNamespaces": "evhns-",
      "eventHubNamespacesEventHubs": "evh-",
      "fabricCapacities": "fc",
      "hdInsightClustersHadoop": "hadoop-",
      "hdInsightClustersHbase": "hbase-",
      "hdInsightClustersKafka": "kafka-",
      "hdInsightClustersMl": "mls-",
      "hdInsightClustersSpark": "spark-",
      "hdInsightClustersStorm": "storm-",
      "hybridComputeMachines": "arcs-",
      "insightsActionGroups": "ag-",
      "insightsComponents": "appi-",
      "keyVaultVaults": "kv-",
      "kubernetesConnectedClusters": "arck",
      "kustoClusters": "dec",
      "kustoClustersDatabases": "dedb",
      "logicIntegrationAccounts": "ia-",
      "logicWorkflows": "logic-",
      "machineLearningServicesWorkspaces": "mlw-",
      "managedIdentityUserAssignedIdentities": "id-",
      "managementManagementGroups": "mg-",
      "migrateAssessmentProjects": "migr-",
      "networkApplicationGateways": "agw-",
      "networkApplicationSecurityGroups": "asg-",
      "networkAzureFirewalls": "afw-",
      "networkBastionHosts": "bas-",
      "networkConnections": "con-",
      "networkDnsZones": "dnsz-",
      "networkExpressRouteCircuits": "erc-",
      "networkFirewallPolicies": "afwp-",
      "networkFirewallPoliciesWebApplication": "waf",
      "networkFirewallPoliciesRuleGroups": "wafrg",
      "networkFrontDoors": "fd-",
      "networkFrontdoorWebApplicationFirewallPolicies": "fdfp-",
      "networkLoadBalancersExternal": "lbe-",
      "networkLoadBalancersInternal": "lbi-",
      "networkLoadBalancersInboundNatRules": "rule-",
      "networkLocalNetworkGateways": "lgw-",
      "networkNatGateways": "ng-",
      "networkNetworkInterfaces": "nic-",
      "networkNetworkSecurityGroups": "nsg-",
      "networkNetworkSecurityGroupsSecurityRules": "nsgsr-",
      "networkNetworkWatchers": "nw-",
      "networkPrivateDnsZones": "pdnsz-",
      "networkPrivateLinkServices": "pl-",
      "networkPublicIPAddresses": "pip-",
      "networkPublicIPPrefixes": "ippre-",
      "networkRouteFilters": "rf-",
      "networkRouteTables": "rt-",
      "networkRouteTablesRoutes": "udr-",
      "networkTrafficManagerProfiles": "traf-",
      "networkVirtualNetworkGateways": "vgw-",
      "networkVirtualNetworks": "vnet-",
      "networkVirtualNetworksSubnets": "snet-",
      "networkVirtualNetworksVirtualNetworkPeerings": "peer-",
      "networkVirtualWans": "vwan-",
      "networkVpnGateways": "vpng-",
      "networkVpnGatewaysVpnConnections": "vcn-",
      "networkVpnGatewaysVpnSites": "vst-",
      "notificationHubsNamespaces": "ntfns-",
      "notificationHubsNamespacesNotificationHubs": "ntf-",
      "operationalInsightsWorkspaces": "log-",
      "portalDashboards": "dash-",
      "powerBIDedicatedCapacities": "pbi-",
      "purviewAccounts": "pview-",
      "recoveryServicesVaults": "rsv-",
      "resourcesResourceGroups": "rg-",
      "searchSearchServices": "srch-",
      "serviceBusNamespaces": "sb-",
      "serviceBusNamespacesQueues": "sbq-",
      "serviceBusNamespacesTopics": "sbt-",
      "serviceEndPointPolicies": "se-",
      "serviceFabricClusters": "sf-",
      "signalRServiceSignalR": "sigr",
      "sqlManagedInstances": "sqlmi-",
      "sqlServers": "sql-",
      "sqlServersDataWarehouse": "sqldw-",
      "sqlServersDatabases": "sqldb-",
      "sqlServersDatabasesStretch": "sqlstrdb-",
      "storageStorageAccounts": "st",
      "storageStorageAccountsVm": "stvm",
      "storSimpleManagers": "ssimp",
      "streamAnalyticsCluster": "asa-",
      "synapseWorkspaces": "syn",
      "synapseWorkspacesAnalyticsWorkspaces": "synw",
      "synapseWorkspacesSqlPoolsDedicated": "syndp",
      "synapseWorkspacesSqlPoolsSpark": "synsp",
      "timeSeriesInsightsEnvironments": "tsi-",
      "webServerFarms": "plan-",
      "webSitesAppService": "app-",
      "webSitesAppServiceEnvironment": "ase-",
      "webSitesFunctions": "func-",
      "webStaticSites": "stapp-"
    },
    "ontologyContainerName": "ontologies",
    "oauth_scopes": "openid https://graph.microsoft.com/.default",
    "abbrs": "[variables('$fxv#0')]",
    "resourceToken": "[toLower(uniqueString(subscription().id, parameters('environmentName'), parameters('location')))]",
    "tags": {
      "azd-env-name": "[parameters('environmentName')]"
    },
    "functionAppName": "[if(not(empty(parameters('apiServiceName'))), parameters('apiServiceName'), format('{0}api-{1}', variables('abbrs').webSitesFunctions, variables('resourceToken')))]",
    "deploymentStorageContainerName": "[format('app-package-{0}-{1}', take(variables('functionAppName'), 32), take(toLower(uniqueString(variables('functionAppName'), variables('resourceToken'))), 7))]",
    "serviceVirtualNetworkName": "[if(not(empty(parameters('vNetName'))), parameters('vNetName'), format('{0}{1}', variables('abbrs').networkVirtualNetworks, variables('resourceToken')))]",
    "serviceVirtualNetworkAppSubnetName": "app",
    "serviceVirtualNetworkPrivateEndpointSubnetName": "private-endpoints-subnet",
    "apimResourceToken": "[toLower(uniqueString(subscription().id, parameters('resourceGroupName'), parameters('environmentName'), parameters('location')))]",
    "apiManagementName": "[format('{0}{1}', variables('abbrs').apiManagementService, variables('apimResourceToken'))]",
    "agentBlueprintName": "[if(not(empty(parameters('agentBlueprintDisplayName'))), parameters('agentBlueprintDisplayName'), format('NextBestAction-Blueprint-{0}', variables('resourceToken')))]",
    "agentName": "[if(not(empty(parameters('agentIdentityDisplayName'))), parameters('agentIdentityDisplayName'), format('NextBestAction-Agent-{0}', variables('resourceToken')))]",
    "azureMonitorWorkspaceName": "[format('amw-{0}', variables('resourceToken'))]",
    "acrPullRoleDefinitionId": "7f951dda-4ed3-4680-a7ca-43fe172d538d",
    "StorageBlobDataOwner": "b7e6dc6d-f1e8-4753-8033-0f276bb0955b",
    "StorageQueueDataContributor": "974c5e8b-45b9-4653-ba55-5f855dd0fb88",
    "foundryResourceName": "[if(not(empty(parameters('foundryName'))), parameters('foundryName'), format('{0}{1}', variables('abbrs').cognitiveServicesAccounts, variables('resourceToken')))]",
    "bingResourceName": "[format('bing-{0}', variables('resourceToken'))]",
    "CognitiveServicesOpenAIUser": "5e0bd9bd-7b93-4f28-af87-19fc36ad61bd",
    "AzureAIDeveloper": "64702f94-c441-49e6-a78b-ef80e0188fee",
    "cosmosResourceName": "[if(not(empty(parameters('cosmosDbAccountName'))), parameters('cosmosDbAccountName'), format('{0}{1}', variables('abbrs').documentDBDatabaseAccounts, variables('resourceToken')))]",
    "CosmosDBDataContributor": "00000000-0000-0000-0000-000000000002",
    "searchResourceName": "[if(not(empty(parameters('searchServiceName'))), parameters('searchServiceName'), format('{0}{1}', variables('abbrs').searchSearchServices, variables('resourceToken')))]",
    "SearchIndexDataContributor": "8ebe5a00-799e-43f5-93ac-243d3dce84a7",
    "SearchServiceContributor": "7ca78c08-252a-4471-8644-bb5ff32d4ba0",
    "fabricResourceName": "[if(not(empty(parameters('fabricCapacityName'))), parameters('fabricCapacityName'), toLower(format('{0}{1}', variables('abbrs').fabricCapacities, replace(variables('resourceToken'), '-', ''))))]",
    "monitoringRoleDefinitionId": "3913510d-42f4-4e42-8a64-420c390055eb",
    "grafanaResourceName": "[if(not(empty(parameters('grafanaName'))), parameters('grafanaName'), format('amg-{0}', variables('resourceToken')))]",
    "MonitoringReader": "43d0d8ad-25c7-4714-9337-8ba259a9fe05",
    "ReaderRole": "acdd72a7-3385-48ef-bd42-f606fba81ae7",
    "MonitoringDataReader": "b0d8363b-8ddd-447d-831f-62ca05bff136",
    "purviewResourceName": "[if(not(empty(parameters('purviewAccountName'))), parameters('purviewAccountName'), format('purview-{0}', variables('resourceToken')))]",
    "PurviewDataReader": "4c48d476-69c1-41d0-88c2-9ac66e4b64f4"
  },
  "resources": [
    {
      "type": "Microsoft.Resources/resourceGroups",
      "apiVersion": "2021-04-01",
      "name": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "location": "[parameters('location')]",
      "tags": "[variables('tags')]"
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "[variables('apiManagementName')]",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "apiManagementName": {
            "value": "[variables('apiManagementName')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "11191429856110053128"
            }
          },
          "parameters": {
            "apiManagementName": {
              "type": "string",
              "metadata": {
                "description": "The name of the API Management instance. Defaults to \"apim-<resourceSuffix>\"."
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "The location of the API Management instance. Defaults to the resource group location."
              }
            },
            "publisherEmail": {
              "type": "string",
              "defaultValue": "noreply@microsoft.com",
              "metadata": {
                "description": "The email address of the publisher. Defaults to \"noreply@microsoft.com\"."
              }
            },
            "publisherName": {
              "type": "string",
              "defaultValue": "Microsoft",
              "metadata": {
                "description": "The name of the publisher. Defaults to \"Microsoft\"."
              }
            },
            "apimLoggerName": {
              "type": "string",
              "defaultValue": "apim-logger",
              "metadata": {
                "description": "Name of the APIM Logger"
              }
            },
            "apimLoggerDescription": {
              "type": "string",
              "defaultValue": "APIM Logger for OpenAI API",
              "metadata": {
                "description": "Description of the APIM Logger"
              }
            },
            "apimSku": {
              "type": "string",
              "defaultValue": "Basicv2",
              "allowedValues": [
                "Consumption",
                "Developer",
                "Basic",
                "Basicv2",
                "Standard",
                "Standardv2",
                "Premium"
              ],
              "metadata": {
                "description": "The pricing tier of this API Management service"
              }
            },
            "appInsightsInstrumentationKey": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "The instrumentation key for Application Insights"
              }
            },
            "appInsightsId": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "The resource ID for Application Insights"
              }
            },
            "entraAppUserAssignedIdentityName": {
              "type": "string",
              "defaultValue": "entra-app-user-assigned-identity",
              "metadata": {
                "description": "The name of the user-assigned managed identity used as entra app FIC"
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.ManagedIdentity/userAssignedIdentities",
              "apiVersion": "2023-01-31",
              "name": "[parameters('entraAppUserAssignedIdentityName')]",
              "location": "[parameters('location')]"
            },
            {
              "type": "Microsoft.ApiManagement/service",
              "apiVersion": "2024-06-01-preview",
              "name": "[parameters('apiManagementName')]",
              "location": "[parameters('location')]",
              "sku": {
                "name": "[parameters('apimSku')]",
                "capacity": 1
              },
              "properties": {
                "publisherEmail": "[parameters('publisherEmail')]",
                "publisherName": "[parameters('publisherName')]"
              },
              "identity": {
                "type": "SystemAssigned, UserAssigned",
                "userAssignedIdentities": {
                  "[format('{0}', resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', parameters('entraAppUserAssignedIdentityName')))]": {}
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', parameters('entraAppUserAssignedIdentityName'))]"
              ]
            },
            {
              "condition": "[and(not(empty(parameters('appInsightsId'))), not(empty(parameters('appInsightsInstrumentationKey'))))]",
              "type": "Microsoft.ApiManagement/service/loggers",
              "apiVersion": "2021-12-01-preview",
              "name": "[format('{0}/{1}', parameters('apiManagementName'), parameters('apimLoggerName'))]",
              "properties": {
                "credentials": {
                  "instrumentationKey": "[parameters('appInsightsInstrumentationKey')]"
                },
                "description": "[parameters('apimLoggerDescription')]",
                "isBuffered": false,
                "loggerType": "applicationInsights",
                "resourceId": "[parameters('appInsightsId')]"
              },
              "dependsOn": [
                "[resourceId('Microsoft.ApiManagement/service', parameters('apiManagementName'))]"
              ]
            }
          ],
          "outputs": {
            "id": {
              "type": "string",
              "value": "[resourceId('Microsoft.ApiManagement/service', parameters('apiManagementName'))]"
            },
            "name": {
              "type": "string",
              "value": "[parameters('apiManagementName')]"
            },
            "principalId": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.ApiManagement/service', parameters('apiManagementName')), '2024-06-01-preview', 'full').identity.principalId]"
            },
            "gatewayUrl": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.ApiManagement/service', parameters('apiManagementName')), '2024-06-01-preview').gatewayUrl]"
            },
            "entraAppUserAssignedIdentityPrincipleId": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', parameters('entraAppUserAssignedIdentityName')), '2023-01-31').principalId]"
            },
            "entraAppUserAssignedIdentityClientId": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', parameters('entraAppUserAssignedIdentityName')), '2023-01-31').clientId]"
            }
          }
        }
      },
      "dependsOn": [
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "oauthAPIModule",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "entraAppUniqueName": "[if(not(empty(parameters('mcpEntraApplicationUniqueName'))), createObject('value', parameters('mcpEntraApplicationUniqueName')), createObject('value', format('mcp-oauth-{0}{1}', variables('abbrs').applications, variables('apimResourceToken'))))]",
          "entraAppDisplayName": "[if(not(empty(parameters('mcpEntraApplicationDisplayName'))), createObject('value', parameters('mcpEntraApplicationDisplayName')), createObject('value', format('MCP-OAuth-{0}{1}', variables('abbrs').applications, variables('apimResourceToken'))))]",
          "apimServiceName": {
            "value": "[variables('apiManagementName')]"
          },
          "oauthScopes": {
            "value": "[variables('oauth_scopes')]"
          },
          "entraAppUserAssignedIdentityPrincipleId": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', variables('apiManagementName')), '2025-04-01').outputs.entraAppUserAssignedIdentityPrincipleId.value]"
          },
          "entraAppUserAssignedIdentityClientId": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', variables('apiManagementName')), '2025-04-01').outputs.entraAppUserAssignedIdentityClientId.value]"
          },
          "existingEntraAppId": {
            "value": "[parameters('existingEntraAppId')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "17654527386920812907"
            }
          },
          "parameters": {
            "apimServiceName": {
              "type": "string",
              "metadata": {
                "description": "The name of the API Management service"
              }
            },
            "location": {
              "type": "string",
              "metadata": {
                "description": "The Azure region for resources"
              }
            },
            "oauthScopes": {
              "type": "string",
              "metadata": {
                "description": "The required scopes for authorization"
              }
            },
            "entraAppUserAssignedIdentityPrincipleId": {
              "type": "string",
              "metadata": {
                "description": "The principle id of the user-assigned managed identity for Entra app"
              }
            },
            "entraAppUserAssignedIdentityClientId": {
              "type": "string",
              "metadata": {
                "description": "The client ID of the user-assigned managed identity for Entra app"
              }
            },
            "entraAppUniqueName": {
              "type": "string",
              "metadata": {
                "description": "The name of the Entra application"
              }
            },
            "entraAppDisplayName": {
              "type": "string",
              "metadata": {
                "description": "The display name of the Entra application"
              }
            },
            "mcpServerName": {
              "type": "string",
              "defaultValue": "MCP Server",
              "metadata": {
                "description": "The name of the MCP Server to display in the consent page"
              }
            },
            "existingEntraAppId": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Pre-created Entra application client ID (temporary parameter until Microsoft Graph extension is supported)"
              }
            }
          },
          "variables": {
            "$fxv#0": "<!--\n    AUTHORIZE POLICY\n    This policy implements the authorization endpoint for PKCE OAuth2 flow with Entra ID.\n    \n    SECURITY NOTE: User consent is validated ONLY through secure HttpOnly cookies set by \n    the consent endpoint. No query parameters can bypass consent validation.\n    \n    Flow:\n    1. MCP client calls this endpoint with code_challenge and code_challenge_method\n    2. Check for existing user consent via secure cookies (redirect to consent page if needed)\n    3. We generate a code verifier and challenge for Entra ID\n    4. We generate a confirmation code to return to the MCP client later\n    5. We redirect the user to Entra ID login page\n    6. After authentication, Entra ID will redirect back to the callback endpoint\n-->\n<policies>\n    <inbound>\n        <base />\n        <!-- STEP 1: Retrieve PKCE parameters from MCP Client request -->\n        <set-variable name=\"mcpClientCodeChallenge\" value=\"@((string)context.Request.Url.Query.GetValueOrDefault(\"code_challenge\", \"\"))\" />\n        <set-variable name=\"mcpClientCodeChallengeMethod\" value=\"@((string)context.Request.Url.Query.GetValueOrDefault(\"code_challenge_method\", \"\"))\" />\n        \n        <!-- STEP 2: Extract client ID and parameters -->\n        <set-variable name=\"clientId\" value=\"@((string)context.Request.Url.Query.GetValueOrDefault(\"client_id\", \"\"))\" />\n        <set-variable name=\"redirect_uri\" value=\"@((string)context.Request.Url.Query.GetValueOrDefault(\"redirect_uri\", \"\"))\" />\n        <set-variable name=\"currentState\" value=\"@((string)context.Request.Url.Query.GetValueOrDefault(\"state\", \"\"))\" />\n        \n        <!-- Normalize the redirect URI for consistent cookie matching -->\n        <set-variable name=\"normalized_redirect_uri\" value=\"@{\n            string redirectUri = context.Variables.GetValueOrDefault<string>(\"redirect_uri\", \"\");\n            if (string.IsNullOrEmpty(redirectUri)) {\n                return \"\";\n            }\n            \n            try {\n                // URL decode the redirect URI to get the normalized form\n                string decodedUri = System.Net.WebUtility.UrlDecode(redirectUri);\n                return decodedUri;\n            } catch (Exception) {\n                // If decoding fails, use the original URI\n                return redirectUri;\n            }\n        }\" />\n        \n        <!-- Check for existing approval cookie for this client_id and redirect_uri combination -->\n        <set-variable name=\"has_approval_cookie\" value=\"@{\n            try {\n                if (string.IsNullOrEmpty(context.Variables.GetValueOrDefault<string>(\"clientId\", \"\")) || \n                    string.IsNullOrEmpty(context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\"))) {\n                    return false;\n                }\n                  \n                string clientId = context.Variables.GetValueOrDefault<string>(\"clientId\", \"\");\n                string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                \n                // Define the cookie name for approvals (must match consent policy)\n                string APPROVAL_COOKIE_NAME = \"MCP_APPROVED_CLIENTS\";\n                \n                // Check for cookie in request\n                var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\n                if (string.IsNullOrEmpty(cookieHeader)) {\n                    return false;\n                }\n                \n                // Parse cookies\n                string[] cookies = cookieHeader.Split(';');\n                foreach (string cookie in cookies) {\n                    string trimmedCookie = cookie.Trim();\n                    if (trimmedCookie.StartsWith(APPROVAL_COOKIE_NAME + \"=\")) {\n                        try {\n                            // Extract and parse the cookie value\n                            string cookieValue = trimmedCookie.Substring(APPROVAL_COOKIE_NAME.Length + 1);\n                            string decodedValue = System.Text.Encoding.UTF8.GetString(\n                                System.Convert.FromBase64String(cookieValue));\n                            JArray approvedClients = JArray.Parse(decodedValue);\n                            \n                            // Check if this client/redirect combination is approved\n                            string clientKey = $\"{clientId}:{redirectUri}\";\n                            foreach (var item in approvedClients) {\n                                if (item.ToString() == clientKey) {\n                                    return true;\n                                }\n                            }\n                        } catch (Exception ex) {\n                            context.Trace($\"Error parsing approval cookie: {ex.Message}\");\n                        }\n                        break;\n                    }\n                }\n                \n                return false;\n            } catch (Exception ex) {\n                context.Trace($\"Error checking approval cookie: {ex.Message}\");\n                return false;\n            }\n        }\" />\n        \n        <!-- Check if the client has been approved via secure cookie -->\n        <choose>\n            <when condition=\"@(context.Variables.GetValueOrDefault<bool>(\"has_approval_cookie\"))\">\n                <!-- Continue with normal flow - client is authorized via secure cookie -->\n            </when>\n            <otherwise>\n                <!-- Redirect to consent page for user approval -->\n                <return-response>\n                    <set-status code=\"302\" reason=\"Found\" />\n                    <set-header name=\"Location\" exists-action=\"override\">\n                        <value>@{\n                            string basePath = context.Request.OriginalUrl.Scheme + \"://\" + context.Request.OriginalUrl.Host + (context.Request.OriginalUrl.Port == 80 || context.Request.OriginalUrl.Port == 443 ? \"\" : \":\" + context.Request.OriginalUrl.Port);\n                            string clientId = context.Variables.GetValueOrDefault<string>(\"clientId\");\n                            // Use the normalized (already decoded) redirect_uri to avoid double-encoding\n                            string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\");\n                            string state = context.Variables.GetValueOrDefault<string>(\"currentState\");\n                            string codeChallenge = context.Variables.GetValueOrDefault<string>(\"mcpClientCodeChallenge\");\n                            string codeChallengeMethod = context.Variables.GetValueOrDefault<string>(\"mcpClientCodeChallengeMethod\");\n                            \n                            // URL encode parameters for the consent redirect URL\n                            string encodedClientId = System.Net.WebUtility.UrlEncode(clientId);\n                            string encodedRedirectUri = System.Net.WebUtility.UrlEncode(redirectUri);\n                            \n                            // State parameter: use as-is without additional encoding\n                            // context.Request.Url.Query.GetValueOrDefault() preserves the original encoding\n                            string encodedState = state;\n                            \n                            // Code challenge parameters: use as-is since they typically don't need encoding\n                            string encodedCodeChallenge = codeChallenge;\n                            string encodedCodeChallengeMethod = codeChallengeMethod;\n                            \n                            return $\"{basePath}/consent?client_id={encodedClientId}&redirect_uri={encodedRedirectUri}&state={encodedState}&code_challenge={encodedCodeChallenge}&code_challenge_method={encodedCodeChallengeMethod}\";\n                        }</value>\n                    </set-header>\n                </return-response>\n            </otherwise>\n        </choose>\n        \n        <!-- STEP 3: Generate PKCE parameters for Entra ID authentication -->\n        <!-- Generate a random code verifier for Entra ID -->\n        <set-variable name=\"codeVerifier\" value=\"@((string)Guid.NewGuid().ToString().Replace(\"-\", \"\"))\" />\n        <!-- Set the code challenge method for Entra ID -->\n        <set-variable name=\"codeChallengeMethod\" value=\"S256\" />\n        <!-- Generate a code challenge using SHA-256 for Entra ID -->\n        <set-variable name=\"codeChallenge\" value=\"@{\n            using (var sha256 = System.Security.Cryptography.SHA256.Create())\n            {\n                var bytes = System.Text.Encoding.UTF8.GetBytes((string)context.Variables.GetValueOrDefault(\"codeVerifier\", \"\"));\n                var hash = sha256.ComputeHash(bytes);\n                return System.Convert.ToBase64String(hash).TrimEnd('=').Replace('+', '-').Replace('/', '_');\n            }\n            }\" />\n\n        <!-- STEP 4: Construct the Entra ID authorization URL -->\n        <!-- Base URL for Entra ID authorization endpoint -->\n        <set-variable name=\"baseAuthUrl\" value=\"https://login.microsoftonline.com/{{EntraIDTenantId}}/oauth2/v2.0/authorize?response_type=code\" />\n        <!-- Add client ID parameter - using EntraIDClientId instead of the request client ID -->\n        <set-variable name=\"clientIdParam\" value=\"@(\"&client_id={{EntraIDClientId}}\")\" />        \n        <!-- Add PKCE parameters -->\n        <set-variable name=\"codeChallengeParam\" value=\"@(string.Concat(\"&code_challenge=\", context.Variables.GetValueOrDefault(\"codeChallenge\", \"\")))\" />\n        <set-variable name=\"codeChallengeMethodParam\" value=\"@(string.Concat(\"&code_challenge_method=\", context.Variables.GetValueOrDefault(\"codeChallengeMethod\", \"\")))\" />\n        <!-- Add OAuth callback parameter -->\n        <set-variable name=\"redirectUriParam\" value=\"@(string.Concat(\"&redirect_uri=\", \"{{OAuthCallbackUri}}\" ))\" />        \n        <!-- Add required scope parameter -->\n        <set-variable name=\"scopeParam\" value=\"@(string.Concat(\"&scope={{OAuthScopes}}\"))\" />\n        <!-- Generate Entra State -->\n        <set-variable name=\"entraState\" value=\"@((string)Guid.NewGuid().ToString())\" />\n        <!-- Add state parameter for security -->\n        <set-variable name=\"stateParam\" value=\"@(string.Concat(\"&state=\", context.Variables.GetValueOrDefault(\"entraState\", \"\")))\" />\n        <!-- Combine all parts to form the complete authorization URL with PKCE params -->\n        <set-variable name=\"authUrl\" value=\"@(string.Concat(\n            context.Variables.GetValueOrDefault(\"baseAuthUrl\", \"\"), \n            context.Variables.GetValueOrDefault(\"clientIdParam\", \"\"), \n            context.Variables.GetValueOrDefault(\"codeChallengeParam\", \"\"), \n            context.Variables.GetValueOrDefault(\"codeChallengeMethodParam\", \"\"), \n            context.Variables.GetValueOrDefault(\"redirectUriParam\", \"\"), \n            context.Variables.GetValueOrDefault(\"scopeParam\", \"\"), \n            context.Variables.GetValueOrDefault(\"stateParam\", \"\")))\" />        \n        \n        <!-- STEP 5: Store authentication data in cache for use in callback -->\n        <!-- Generate a confirmation code to return to the MCP client -->\n        <set-variable name=\"mcpConfirmConsentCode\" value=\"@((string)Guid.NewGuid().ToString())\" />\n        \n        <!-- Store code verifier for token exchange -->\n        <cache-store-value duration=\"3600\" \n            key=\"@(\"CodeVerifier-\"+context.Variables.GetValueOrDefault(\"entraState\", \"\"))\" \n            value=\"@(context.Variables.GetValueOrDefault(\"codeVerifier\", \"\"))\" />\n        \n        <!-- Map state to MCP confirmation code for callback -->\n        <cache-store-value duration=\"3600\" \n            key=\"@((string)context.Variables.GetValueOrDefault(\"entraState\"))\" \n            value=\"@(context.Variables.GetValueOrDefault(\"mcpConfirmConsentCode\", \"\"))\" />\n\n         <!-- Retrieve MCP Client State and Scope from request (Claude sends the state and scope param for binding the auth flow per request) -->\n         <set-variable name=\"mcpState\" value=\"@((string)context.Request.Url.Query.GetValueOrDefault(\"state\", \"\"))\" />\n         <set-variable name=\"mcpScope\" value=\"@((string)context.Request.Url.Query.GetValueOrDefault(\"scope\", \"\"))\" />\n        \n        <!-- Store MCP client PKCE data, client state and client callback redirect uri for verification during token exchange -->\n        <cache-store-value duration=\"3600\" \n            key=\"@($\"McpClientAuthData-{context.Variables.GetValueOrDefault(\"mcpConfirmConsentCode\")}\")\" \n            value=\"@{\n                // Create a JObject and populate it with values\n                return new JObject{\n                    [\"mcpClientCodeChallenge\"] = (string)context.Variables.GetValueOrDefault(\"mcpClientCodeChallenge\", \"\"),\n                    [\"mcpClientCodeChallengeMethod\"] = (string)context.Variables.GetValueOrDefault(\"mcpClientCodeChallengeMethod\", \"\"),\n                    [\"mcpClientState\"] = (string)context.Variables.GetValueOrDefault(\"mcpState\", \"\"),\n                    [\"mcpClientScope\"] = (string)context.Variables.GetValueOrDefault(\"mcpScope\", \"\"),\n                    [\"mcpCallbackRedirectUri\"] = Uri.UnescapeDataString(context.Variables.GetValueOrDefault(\"redirect_uri\", \"\"))\n                }.ToString();\n            }\" />\n    </inbound>\n    <backend>\n        <base />\n    </backend>\n    <outbound>\n        <base />        \n        <!-- Return the response with a 302 status code for redirect -->\n        <return-response>\n            <set-status code=\"302\" reason=\"Found\" />\n            <set-header name=\"Location\" exists-action=\"override\">\n                <value>@(context.Variables.GetValueOrDefault(\"authUrl\", \"\"))</value>\n            </set-header>\n            <!-- Add cache control headers to ensure browser follows redirect -->\n            <set-header name=\"Cache-Control\" exists-action=\"override\">\n                <value>no-store, no-cache, must-revalidate</value>\n            </set-header>\n            <set-header name=\"Pragma\" exists-action=\"override\">\n                <value>no-cache</value>\n            </set-header>\n            <!-- Remove any content-type that might interfere -->\n            <set-header name=\"Content-Type\" exists-action=\"delete\" />\n        </return-response>\n    </outbound>\n    <on-error>\n        <base />\n    </on-error>\n</policies>",
            "$fxv#1": "<!--\n    SIMPLIFIED TOKEN POLICY - FOR DEBUGGING\n    This is a simplified version to test if the basic policy infrastructure works\n-->\n<policies>\n    <inbound>\n        <base />\n        <!-- Generate a more realistic token response -->\n        <set-variable name=\"clientId\" value=\"@{\n            // Extract client_id from request body\n            var body = context.Request.Body?.As<string>(preserveContent: true) ?? \"\";\n            var pairs = body.Split('&');\n            foreach (var pair in pairs)\n            {\n                var keyValue = pair.Split('=');\n                if (keyValue.Length == 2 && keyValue[0] == \"client_id\")\n                {\n                    return System.Net.WebUtility.UrlDecode(keyValue[1]);\n                }\n            }\n            return \"unknown\";\n        }\" />\n        \n        <set-variable name=\"authCode\" value=\"@{\n            // Extract code from request body\n            var body = context.Request.Body?.As<string>(preserveContent: true) ?? \"\";\n            var pairs = body.Split('&');\n            foreach (var pair in pairs)\n            {\n                var keyValue = pair.Split('=');\n                if (keyValue.Length == 2 && keyValue[0] == \"code\")\n                {\n                    return System.Net.WebUtility.UrlDecode(keyValue[1]);\n                }\n            }\n            return \"unknown\";\n        }\" />\n        \n        <return-response>\n            <set-status code=\"200\" reason=\"OK\" />\n            <set-header name=\"Content-Type\" exists-action=\"override\">\n                <value>application/json</value>\n            </set-header>\n            <set-body>@{\n                string clientId = (string)context.Variables.GetValueOrDefault(\"clientId\", \"unknown\");\n                string authCode = (string)context.Variables.GetValueOrDefault(\"authCode\", \"unknown\");\n                string accessToken = $\"mcp_access_token_{clientId}_{authCode}_{DateTimeOffset.UtcNow.ToUnixTimeSeconds()}\";\n                \n                return $@\"{{\n                    \"\"access_token\"\": \"\"{accessToken}\"\",\n                    \"\"token_type\"\": \"\"Bearer\"\",\n                    \"\"expires_in\"\": 3600,\n                    \"\"scope\"\": \"\"openid https://graph.microsoft.com/.default\"\",\n                    \"\"client_id\"\": \"\"{clientId}\"\",\n                    \"\"issued_at\"\": {DateTimeOffset.UtcNow.ToUnixTimeSeconds()}\n                }}\";\n            }</set-body>\n        </return-response>\n    </inbound>\n    <backend>\n        <base />\n    </backend>\n    <outbound>\n        <base />\n    </outbound>\n    <on-error>\n        <base />\n    </on-error>\n</policies>",
            "$fxv#2": "<!--\n    SIMPLIFIED OAUTH CALLBACK POLICY - FOR DEBUGGING\n    This is a simplified version to test if the basic callback infrastructure works\n-->\n<policies>\n    <inbound>\n        <base />\n        <!-- Extract the authorization code from the callback -->\n        <set-variable name=\"authCode\" value=\"@((string)context.Request.Url.Query.GetValueOrDefault(\"code\", \"\"))\" />\n        <set-variable name=\"state\" value=\"@((string)context.Request.Url.Query.GetValueOrDefault(\"state\", \"\"))\" />\n        \n        <!-- For now, just return a simple success response -->\n        <return-response>\n            <set-status code=\"200\" reason=\"OK\" />\n            <set-header name=\"Content-Type\" exists-action=\"override\">\n                <value>text/html</value>\n            </set-header>\n            <set-body>@{\n                string authCode = (string)context.Variables.GetValueOrDefault(\"authCode\", \"none\");\n                string state = (string)context.Variables.GetValueOrDefault(\"state\", \"none\");\n                return $@\"\n<!DOCTYPE html>\n<html>\n<head>\n    <title>OAuth Callback - Debug</title>\n    <style>\n        body {{ font-family: Arial, sans-serif; margin: 50px; }}\n        .info {{ background: #f0f8ff; padding: 20px; border-radius: 5px; }}\n    </style>\n</head>\n<body>\n    <h1>OAuth Callback Received</h1>\n    <div class='info'>\n        <p><strong>Authorization Code:</strong> {authCode}</p>\n        <p><strong>State:</strong> {state}</p>\n        <p><strong>Status:</strong> Callback received successfully (simplified policy)</p>\n    </div>\n    <p>This is a debug version. In production, this would exchange the code for tokens.</p>\n</body>\n</html>\";\n            }</set-body>\n        </return-response>\n    </inbound>\n    <backend>\n        <base />\n    </backend>\n    <outbound>\n        <base />\n    </outbound>\n    <on-error>\n        <base />\n    </on-error>\n</policies>",
            "$fxv#3": "<!--\n    REGISTER POLICY\n    This policy implements the dynamic client registration endpoint for OAuth2 flow.\n    \n    Flow:\n    1. MCP client sends a registration request with redirect URIs\n    2. We store the registration information in cache for later verification\n    3. We generate and return client credentials with the provided redirect URIs\n-->\n<policies>\n    <inbound>\n        <base />\n        <!-- STEP 1: Extract client registration data from request -->\n        <set-variable name=\"requestBody\" value=\"@(context.Request.Body.As<JObject>(preserveContent: true))\" />\n          <!-- STEP 2: Store registration information in cache -->\n        <cache-store-value duration=\"3600\" \n            key=\"DynamicClientRegistration\" \n            value=\"@(context.Variables.GetValueOrDefault<JObject>(\"requestBody\").ToString())\" />\n        \n        <!-- Store the redirect URI -->\n        <cache-store-value duration=\"3600\" \n            key=\"ClientRedirectUri\" \n            value=\"@(context.Variables.GetValueOrDefault<JObject>(\"requestBody\")[\"redirect_uris\"][0].ToString())\" />\n\n        <!-- Generate a unique client ID (GUID) -->\n        <set-variable name=\"uniqueClientId\" value=\"@(Guid.NewGuid().ToString())\" />\n        \n        <!-- Store client info by client ID for easy lookup during consent -->\n        <cache-store-value duration=\"3600\" \n            key=\"@($\"ClientInfo-{context.Variables.GetValueOrDefault<string>(\"uniqueClientId\")}\")\" \n            value=\"@{\n                var requestBody = context.Variables.GetValueOrDefault<JObject>(\"requestBody\");\n                var clientInfo = new JObject();\n                clientInfo[\"client_name\"] = requestBody[\"client_name\"]?.ToString() ?? \"Unknown Application\";\n                clientInfo[\"client_uri\"] = requestBody[\"client_uri\"]?.ToString() ?? \"\";\n                clientInfo[\"redirect_uris\"] = requestBody[\"redirect_uris\"];\n                return clientInfo.ToString();\n            }\" />\n        \n        <!-- STEP 3: Set response content type -->\n        <set-header name=\"Content-Type\" exists-action=\"override\">\n            <value>application/json</value>\n        </set-header>\n        \n        <!-- STEP 4: Return client credentials response -->\n        <return-response>\n            <set-status code=\"200\" reason=\"OK\" />\n            <set-header name=\"access-control-allow-origin\" exists-action=\"override\">\n                <value>*</value>\n            </set-header>\n            <set-body template=\"none\">@{\n                var requestBody = context.Variables.GetValueOrDefault<JObject>(\"requestBody\");\n                \n                // Generate timestamps dynamically\n                // Current time in seconds since epoch (Unix timestamp)\n                long currentTimeSeconds = DateTimeOffset.UtcNow.ToUnixTimeSeconds();\n                \n                // Client ID issued at current time\n                long clientIdIssuedAt = currentTimeSeconds;\n                \n                // Client secret expires in 1 year (31536000 seconds = 365 days)\n                long clientSecretExpiresAt = currentTimeSeconds + 31536000;\n\n                // Use the generated client ID from earlier\n                string uniqueClientId = context.Variables.GetValueOrDefault<string>(\"uniqueClientId\", Guid.NewGuid().ToString());\n                \n                return new JObject\n                {\n                    [\"client_id\"] = uniqueClientId,\n                    [\"client_id_issued_at\"] = clientIdIssuedAt,\n                    [\"client_secret_expires_at\"] = clientSecretExpiresAt,\n                    [\"redirect_uris\"] = requestBody[\"redirect_uris\"]?.ToObject<JArray>(),\n                    [\"client_name\"] = requestBody[\"client_name\"]?.ToString() ?? \"Unknown Application\",\n                    [\"client_uri\"] = requestBody[\"client_uri\"]?.ToString() ?? \"\"\n                }.ToString();\n            }</set-body>\n        </return-response>\n    </inbound>\n    <backend />\n    <outbound>\n        <base />\n    </outbound>\n    <on-error>\n        <base />\n    </on-error>\n</policies>",
            "$fxv#4": "<!--\n    REGISTER OPTIONS POLICY\n    This policy handles the OPTIONS pre-flight requests for the OAuth client registration endpoint.\n    It returns the appropriate CORS headers to allow cross-origin requests.\n-->\n<policies>\n    <inbound>\n        <!-- Return a 200 OK response with appropriate CORS headers -->\n        <return-response>\n            <set-status code=\"200\" reason=\"OK\" />\n            <set-header name=\"Access-Control-Allow-Origin\" exists-action=\"override\">\n                <value>*</value>\n            </set-header>\n            <set-header name=\"Access-Control-Allow-Methods\" exists-action=\"override\">\n                <value>GET, OPTIONS</value>\n            </set-header>\n            <set-header name=\"Access-Control-Allow-Headers\" exists-action=\"override\">\n                <value>Content-Type, Authorization</value>\n            </set-header>\n            <set-header name=\"Access-Control-Max-Age\" exists-action=\"override\">\n                <value>86400</value>\n            </set-header>\n            <set-body />\n        </return-response>\n        <base />\n    </inbound>\n    <backend>\n        <base />\n    </backend>\n    <outbound>\n        <base />\n    </outbound>\n    <on-error>\n        <base />\n    </on-error>\n</policies>\n",
            "$fxv#5": "<!--\n    OAUTH METADATA OPTIONS POLICY\n    This policy handles OPTIONS requests to the OAuth metadata endpoint, implementing CORS support\n    for cross-origin requests to the OAuth authorization server.\n-->\n<policies>\n    <inbound>\n        <!-- Return CORS headers for OPTIONS requests -->\n        <return-response>\n            <set-status code=\"200\" reason=\"OK\" />\n            <set-header name=\"Access-Control-Allow-Origin\" exists-action=\"override\">\n                <value>*</value>\n            </set-header>\n            <set-header name=\"Access-Control-Allow-Methods\" exists-action=\"override\">\n                <value>GET, OPTIONS</value>\n            </set-header>\n            <set-header name=\"Access-Control-Allow-Headers\" exists-action=\"override\">\n                <value>Content-Type, Authorization</value>\n            </set-header>\n            <set-header name=\"Access-Control-Max-Age\" exists-action=\"override\">\n                <value>86400</value>\n            </set-header>\n            <set-body />\n        </return-response>\n        <base />\n    </inbound>\n    <backend>\n        <base />\n    </backend>\n    <outbound>\n        <base />\n    </outbound>\n    <on-error>\n        <base />\n    </on-error>\n</policies>",
            "$fxv#6": "<!--\n    OAUTH METADATA POLICY\n    This policy implements the OpenID Connect and OAuth 2.0 discovery endpoint (.well-known/oauth-authorization-server).\n-->\n<policies>\n    <inbound>\n        <!-- Return the OAuth metadata in JSON format -->\n        <return-response>\n            <set-status code=\"200\" reason=\"OK\" />\n            <set-header name=\"Content-Type\" exists-action=\"override\">\n                <value>application/json; charset=utf-8</value>\n            </set-header>\n            <set-header name=\"access-control-allow-origin\" exists-action=\"override\">\n                <value>*</value>\n            </set-header>                \n            <set-body>\n                {\n                    \"issuer\": \"{{APIMGatewayURL}}\",\n                    \"service_documentation\": \"https://microsoft.com/\",\n                    \"authorization_endpoint\": \"{{APIMGatewayURL}}/authorize\",\n                    \"token_endpoint\": \"{{APIMGatewayURL}}/token\",\n                    \"revocation_endpoint\": \"{{APIMGatewayURL}}/revoke\",\n                    \"registration_endpoint\": \"{{APIMGatewayURL}}/register\",\n                    \"response_types_supported\": [\n                        \"code\"\n                    ],\n                    \"code_challenge_methods_supported\": [\n                        \"S256\"\n                    ],\n                    \"token_endpoint_auth_methods_supported\": [\n                        \"none\"\n                    ],\n                    \"grant_types_supported\": [\n                        \"authorization_code\",\n                        \"refresh_token\"\n                    ],\n                    \"revocation_endpoint_auth_methods_supported\": [\n                        \"client_secret_post\"\n                    ]\n                }\n            </set-body>\n        </return-response>\n        <base />\n    </inbound>\n    <backend>\n        <base />\n    </backend>\n    <outbound>\n        <base />\n    </outbound>\n    <on-error>\n        <base />\n    </on-error>\n</policies>",
            "$fxv#7": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<!--\n    Consent Policy - Handles user consent for OAuth client applications\n    \n    Flow:\n    1. Check existing consent status (cookies)\n    2. Display consent form for new clients\n    3. Process user response (allow/deny)\n    4. Store decision and redirect appropriately\n-->\n<policies>\n    <inbound>        \n        <base />        \n        <!-- Helper function to extract parameters from form/query -->\n        <set-variable name=\"form_body\" value=\"@{\n            if (context.Request.Method == \"POST\") {\n                string contentType = context.Request.Headers.GetValueOrDefault(\"Content-Type\", \"\");\n                if (contentType.Contains(\"application/x-www-form-urlencoded\")) {\n                    return context.Request.Body.As<string>(preserveContent: true);\n                }\n            }\n            return \"\";\n        }\" />\n        \n        <!-- Extract request parameters using consolidated logic -->\n        <set-variable name=\"client_id\" value=\"@{\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\n            \n            // Check form data first (POST)\n            if (!string.IsNullOrEmpty(formBody)) {\n                string[] pairs = formBody.Split('&');\n                foreach (string pair in pairs) {\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\n                    if (keyValue.Length == 2 && keyValue[0] == \"client_id\") {\n                        return System.Net.WebUtility.UrlDecode(keyValue[1]);\n                    }\n                }\n            }\n            // Fallback to query string (GET)\n            return (string)context.Request.Url.Query.GetValueOrDefault(\"client_id\", \"\");\n        }\" />\n        \n        <set-variable name=\"redirect_uri\" value=\"@{\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\n            \n            // Check form data first (POST)\n            if (!string.IsNullOrEmpty(formBody)) {\n                string[] pairs = formBody.Split('&');\n                foreach (string pair in pairs) {\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\n                    if (keyValue.Length == 2 && keyValue[0] == \"redirect_uri\") {\n                        return keyValue[1]; // Keep encoded for normalization\n                    }\n                }\n            }\n            // Fallback to query string (GET)\n            return (string)context.Request.Url.Query.GetValueOrDefault(\"redirect_uri\", \"\");\n        }\" />\n        \n        <set-variable name=\"state\" value=\"@{\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\n            \n            // Check form data first (POST)\n            if (!string.IsNullOrEmpty(formBody)) {\n                string[] pairs = formBody.Split('&');\n                foreach (string pair in pairs) {\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\n                    if (keyValue.Length == 2 && keyValue[0] == \"state\") {\n                        return keyValue[1]; // Keep encoded\n                    }\n                }\n            }\n            // Fallback to query string (GET)\n            return (string)context.Request.Url.Query.GetValueOrDefault(\"state\", \"\") ?? \"\";\n        }\" />\n        \n        <set-variable name=\"code_challenge\" value=\"@{\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\n            \n            // Check form data first (POST)\n            if (!string.IsNullOrEmpty(formBody)) {\n                string[] pairs = formBody.Split('&');\n                foreach (string pair in pairs) {\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\n                    if (keyValue.Length == 2 && keyValue[0] == \"code_challenge\") {\n                        return keyValue[1]; // Keep encoded\n                    }\n                }\n            }\n            // Fallback to query string (GET)\n            return (string)context.Request.Url.Query.GetValueOrDefault(\"code_challenge\", \"\");\n        }\" />\n        \n        <set-variable name=\"code_challenge_method\" value=\"@{\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\n            \n            // Check form data first (POST)\n            if (!string.IsNullOrEmpty(formBody)) {\n                string[] pairs = formBody.Split('&');\n                foreach (string pair in pairs) {\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\n                    if (keyValue.Length == 2 && keyValue[0] == \"code_challenge_method\") {\n                        return keyValue[1]; // Keep encoded\n                    }\n                }\n            }\n            // Fallback to query string (GET)\n            return (string)context.Request.Url.Query.GetValueOrDefault(\"code_challenge_method\", \"\");\n        }\" />\n      \n         <set-variable name=\"access_denied_template\" value=\"@{\n            return @\"<!DOCTYPE html>\n<html lang='en'>\n<head>    <meta charset='UTF-8'>\n    <meta name='viewport' content='width=device-width, initial-scale=1.0'>\n    <title>Access Denied</title>\n    <style>\n__COMMON_STYLES__\n        .error-details {\n            background-color: #f8f9fa;\n            border: 1px solid #dee2e6;\n            border-radius: 8px;\n            padding: 20px;\n            margin: 20px 0;\n            font-family: 'Courier New', Consolas, monospace;\n            font-size: 14px;\n            line-height: 1.6;\n            white-space: pre-wrap;\n            overflow-x: auto;\n        }\n        \n        .error-title {\n            color: #dc3545;\n            font-weight: bold;\n            margin-bottom: 10px;\n        }\n        \n        .debug-section {\n            margin-top: 15px;\n            padding-top: 15px;\n            border-top: 1px solid #dee2e6;\n        }\n        \n        .debug-label {\n            font-weight: bold;\n            color: #495057;\n        }\n    </style>\n</head>\n<body>\n    <div class='consent-container'>\n        <h1 class='denial-heading'>Access Denied</h1>\n        <div class='error-details'>\n            <div class='error-title'>Error Details:</div>\n            __DENIAL_MESSAGE__\n        </div>\n        <p>The application will not be able to access your data.</p>\n        <p>You can close this window safely.</p>\n    </div>\n</body>\n</html>\";\n        }\" />\n        \n        <!-- Reusable function to generate 403 error response -->\n        <set-variable name=\"generate_403_response\" value=\"@{\n            string errorTemplate = context.Variables.GetValueOrDefault<string>(\"access_denied_template\");\n            string commonStyles = context.Variables.GetValueOrDefault<string>(\"common_styles\");\n            string message = \"Access denied.\";\n            \n            // Replace placeholders with actual content\n            errorTemplate = errorTemplate.Replace(\"__COMMON_STYLES__\", commonStyles);\n            errorTemplate = errorTemplate.Replace(\"__DENIAL_MESSAGE__\", message);\n            \n            return errorTemplate;\n        }\" />\n            <!-- Error page template -->\n        <set-variable name=\"client_not_found_template\" value=\"@{\n            return @\"<!DOCTYPE html>\n<html lang='en'>\n<head>    \n    <meta charset='UTF-8'>\n    <meta name='viewport' content='width=device-width, initial-scale=1.0'>\n    <title>Client Not Found</title>\n    <style>\n__COMMON_STYLES__\n    </style>\n</head>\n<body>\n    <div class='consent-container'>        \n        <h1 class='denial-heading'>Client Not Found</h1>\n        <p>The client registration for the specified client was not found.</p>\n        <div class='client-info'>\n            <p><strong>Client ID:</strong> <code>__CLIENT_ID_DISPLAY__</code></p>\n            <p><strong>Redirect URI:</strong> <code>__REDIRECT_URI__</code></p>\n        </div>\n        <p>Please ensure that you are using a properly registered client application.</p>\n        <p>You can close this window safely.</p>\n    </div>\n</body>\n</html>\";\n        }\" />\n        <!-- Normalize redirect URI by handling potential double-encoding -->\n        <set-variable name=\"normalized_redirect_uri\" value=\"@{\n            string redirectUri = context.Variables.GetValueOrDefault<string>(\"redirect_uri\", \"\");\n            \n            if (string.IsNullOrEmpty(redirectUri)) {\n                return \"\";\n            }\n            \n            try {\n                string firstDecode = System.Net.WebUtility.UrlDecode(redirectUri);\n                \n                // Check if still encoded (contains % followed by hex digits)\n                if (firstDecode.Contains(\"%\") && System.Text.RegularExpressions.Regex.IsMatch(firstDecode, @\"%[0-9A-Fa-f]{2}\")) {\n                    // Double-encoded, decode again\n                    string secondDecode = System.Net.WebUtility.UrlDecode(firstDecode);\n                    return secondDecode;\n                } else {\n                    // Single encoding, first decode is sufficient\n                    return firstDecode;\n                }\n            } catch (Exception) {\n                // If decoding fails, return original value\n                return redirectUri;\n            }\n        }\" />\n        \n        <!-- Cache client information lookup -->\n        <cache-lookup-value key=\"@($\"ClientInfo-{context.Variables.GetValueOrDefault<string>(\"client_id\")}\")\" variable-name=\"clientInfoJson\" />\n        \n        <!-- Get OAuth scopes from configuration -->\n        <set-variable name=\"oauth_scopes\" value=\"{{OAuthScopes}}\" />\n        \n        <!-- Generate CSRF token for form protection (GET requests only) -->\n        <set-variable name=\"csrf_token\" value=\"@{\n            // Only generate tokens for GET requests (showing consent form)\n            // POST requests validate existing tokens, not generate new ones\n            if (context.Request.Method != \"GET\") {\n                return \"\";\n            }\n            \n            // Generate random CSRF token using Guid and timestamp\n            string guidPart = Guid.NewGuid().ToString(\"N\");\n            string timestampPart = DateTime.UtcNow.Ticks.ToString();\n            string combinedString = guidPart + timestampPart;\n            \n            // Create URL-safe token by encoding combined string\n            string token = System.Convert.ToBase64String(\n                System.Text.Encoding.UTF8.GetBytes(combinedString)\n            ).Replace(\"+\", \"-\").Replace(\"/\", \"_\").Replace(\"=\", \"\").Substring(0, 32);\n            \n            return token;\n        }\" />\n        \n        <!-- Cache CSRF token for validation (GET requests only) -->\n        <choose>\n            <when condition=\"@(context.Request.Method == \"GET\" && !string.IsNullOrEmpty(context.Variables.GetValueOrDefault<string>(\"csrf_token\")))\">\n                <cache-store-value key=\"@($\"CSRF-{context.Variables.GetValueOrDefault<string>(\"csrf_token\")}\")\" \n                                  value=\"@{\n                                      string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                                      string normalizedRedirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                                      string timestamp = DateTime.UtcNow.ToString(\"yyyy-MM-ddTHH:mm:ssZ\");\n                                      string tokenData = $\"{clientId}:{normalizedRedirectUri}:{timestamp}\";\n                                      \n                                      // Add debugging metadata\n                                      string debugInfo = $\"CACHED_AT:{DateTime.UtcNow:yyyy-MM-ddTHH:mm:ss.fffZ}\";\n                                      return $\"{tokenData}|{debugInfo}\";\n                                  }\" \n                                  duration=\"900\" />\n                <!-- Track token caching for debugging -->\n                <set-variable name=\"csrf_token_cached\" value=\"true\" />\n            </when>\n            <otherwise>\n                <set-variable name=\"csrf_token_cached\" value=\"false\" />\n            </otherwise>\n        </choose>\n          <!-- Validate client registration -->\n        <set-variable name=\"is_client_registered\" value=\"@{\n            try {\n                string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                \n                if (string.IsNullOrEmpty(clientId)) {\n                    return false;\n                }\n                \n                // Get client info from cache lookup\n                string clientInfoJson = context.Variables.GetValueOrDefault<string>(\"clientInfoJson\");\n                  if (string.IsNullOrEmpty(clientInfoJson)) {\n                    return false;\n                }\n                \n                // Parse client configuration\n                JObject clientInfo = JObject.Parse(clientInfoJson);\n                JArray redirectUris = clientInfo[\"redirect_uris\"]?.ToObject<JArray>();\n                \n                // Validate redirect URI is registered\n                if (redirectUris != null) {\n                    foreach (var uri in redirectUris) {\n                        // Normalize registered URI for comparison\n                        string registeredUri = System.Net.WebUtility.UrlDecode(uri.ToString());\n                        if (registeredUri == redirectUri) {\n                            return true;\n                        }\n                    }\n                }\n                \n                return false;\n            }\n            catch (Exception ex) {\n                return false;\n            }\n        }\" />\n        \n        <!-- Extract client name from cache -->\n        <set-variable name=\"client_name\" value=\"@{\n            try {\n                string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                \n                if (string.IsNullOrEmpty(clientId)) {\n                    return \"Unknown Application\";\n                }\n                \n                // Get client info from cache lookup\n                string clientInfoJson = context.Variables.GetValueOrDefault<string>(\"clientInfoJson\");\n                \n                if (string.IsNullOrEmpty(clientInfoJson)) {\n                    return clientId;\n                }\n                \n                // Parse client configuration\n                JObject clientInfo = JObject.Parse(clientInfoJson);\n                string clientName = clientInfo[\"client_name\"]?.ToString();\n                \n                return string.IsNullOrEmpty(clientName) ? clientId : clientName;\n            }\n            catch (Exception ex) {\n                return context.Variables.GetValueOrDefault<string>(\"client_id\", \"Unknown Application\");\n            }\n        }\" />\n        \n        <!-- Extract client URI from cache -->\n        <set-variable name=\"client_uri\" value=\"@{\n            try {\n                // Get client info from cache lookup\n                string clientInfoJson = context.Variables.GetValueOrDefault<string>(\"clientInfoJson\");\n                \n                if (string.IsNullOrEmpty(clientInfoJson)) {\n                    return \"N/A\";\n                }\n                \n                // Parse client configuration\n                JObject clientInfo = JObject.Parse(clientInfoJson);\n                string clientUri = clientInfo[\"client_uri\"]?.ToString();\n                \n                return string.IsNullOrEmpty(clientUri) ? \"N/A\" : clientUri;\n            }\n            catch (Exception ex) {\n                return \"N/A\";\n            }\n        }\" />\n        \n        <!-- Define common styles for consent and error pages -->\n        <set-variable name=\"common_styles\" value=\"@{\n            return @\"        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            max-width: 100%;\n            margin: 0;            padding: 0;\n            line-height: 1.6;\n            min-height: 100vh;\n            background: linear-gradient(135deg, #1f1f1f, #333344, #3f4066); /* Modern dark gradient */\n            color: #333333;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n        }.container, .consent-container {\n            background-color: #ffffff;\n            border-radius: 4px; /* Adding some subtle rounding */\n            padding: 30px;\n            max-width: 600px;            width: 90%;\n            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);\n            border: none;\n        }\n        \n        h1 {\n            margin-bottom: 20px;\n            border-bottom: 1px solid #EDEBE9;\n            padding-bottom: 10px;\n            font-weight: 500;\n        }\n        .consent-heading {\n            color: #0078D4; /* Microsoft Blue */\n        }\n        .denial-heading {\n            color: #D83B01; /* Microsoft Attention color */\n        }\n        \n        p {\n            margin: 15px 0;\n            line-height: 1.7;\n            color: #323130; /* Microsoft text color */\n        }          .client-info {\n            background-color: #F5F5F5; /* Light gray background for info boxes */\n            padding: 15px;\n            border-radius: 4px; /* Adding some subtle rounding */\n            margin: 15px 0;\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);\n            border: 1px solid #EDEBE9;\n        }\n          .client-info p {\n            display: flex;\n            align-items: flex-start;\n            margin: 8px 0;\n        }\n        \n        .client-info strong {\n            min-width: 160px;\n            flex-shrink: 0;\n            text-align: left;\n            padding-right: 15px;\n            color: #0078D4; /* Microsoft Blue */\n        }\n          .client-info code {\n            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;\n            background-color: rgba(240, 240, 250, 0.5);\n            padding: 2px 6px;\n            border-radius: 4px; /* Adding some subtle rounding */\n            color: #0078D4; /* Microsoft Blue */\n            word-break: break-all;\n        }\n          .btn {\n            display: inline-block;\n            padding: 8px 16px;\n            margin: 10px 0;\n            border-radius: 4px; /* Adding some subtle rounding */\n            text-decoration: none;\n            font-weight: 600;\n            cursor: pointer;\n            transition: all 0.2s ease;\n        }\n        \n        .btn-primary {\n            background-color: #0078D4; /* Microsoft Blue */\n            color: white;\n            border: none;\n        }\n        .btn-primary:hover {\n            background-color: #106EBE; /* Microsoft Blue hover */\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);\n        }\n        \n        .btn-secondary {\n            background-color: #D83B01; /* Microsoft Red */\n            color: white; /* White text */\n            border: none;\n        }\n        .btn-secondary:hover {\n            background-color: #A80000; /* Darker red on hover */\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);\n        }\n          .buttons {\n            margin-top: 20px;\n            display: flex;\n            gap: 10px;\n            justify-content: flex-start;\n        }\n        \n        a {\n            color: #0078D4; /* Microsoft Blue */\n            text-decoration: none;\n            font-weight: 600;\n        }\n        a:hover {\n            text-decoration: underline;\n        }\n        strong {\n            color: #0078D4; /* Microsoft Blue */\n            font-weight: 600;\n        }          .error-message {\n            background-color: #FDE7E9; /* Light red background */\n            padding: 15px;\n            margin: 15px 0;\n            border-radius: 4px; /* Adding some subtle rounding */\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);\n            border-left: 3px solid #D83B01; /* Microsoft Attention color */\n        }\n        \n        .error-message p {\n            margin: 8px 0;\n        }\n        \n        .error-message p:first-child {\n            font-weight: 500;\n            color: #D83B01; /* Microsoft Attention color */\n        }\";\n        }\" />\n        \n        <!-- Consent page HTML template -->\n        <set-variable name=\"consent_page_template\" value=\"@{\n            return @\"<!DOCTYPE html>\n<html lang='en'>\n<head>    <meta charset='UTF-8'>\n    <meta name='viewport' content='width=device-width, initial-scale=1.0'>\n    <title>Application Consent</title>\n    <style>\n__COMMON_STYLES__    /* Additional styles for scopes list */\n    .scopes-list {\n        margin: 0;\n        padding-left: 0;\n    }\n    .scopes-list li {\n        list-style-type: none;\n        padding: 4px 0;\n        display: flex;\n    }\n    </style>\n</head>\n<body>\n    <div class='consent-container'>\n        <h1 class='consent-heading'>Application Access Request</h1>\n\n        <p>The following application is requesting access to <strong>{{MCPServerName}}</strong>, which might include access to everything <strong>{{MCPServerName}}</strong> has been and will be granted access to.</p>\n        \n        <div class='client-info'>\n            <p><strong>Application Name:</strong> <code>__CLIENT_NAME__</code></p>\n            <p><strong>Application Website:</strong> <code>__CLIENT_URI__</code></p>\n            <p><strong>Application ID:</strong> <code>__CLIENT_ID_DISPLAY__</code></p>\n            <p><strong>Redirect URI:</strong> <code>__REDIRECT_URI__</code></p>\n        </div>        \n        <p>The application will have access to the following scopes, used by <strong>{{MCPServerName}}</strong>:</p>\n        <div class='client-info'>\n            <ul class='scopes-list'>\n                <li>__OAUTH_SCOPES__</li>\n            </ul>\n        </div>        <div class='buttons'>\n            <form method='post' action='__CONSENT_ACTION_URL__' style='display: inline-block;'>\n                <input type='hidden' name='client_id' value='__CLIENT_ID_FORM__'>\n                <input type='hidden' name='redirect_uri' value='__REDIRECT_URI__'>\n                <input type='hidden' name='state' value='__STATE__'>\n                <input type='hidden' name='code_challenge' value='__CODE_CHALLENGE__'>\n                <input type='hidden' name='code_challenge_method' value='__CODE_CHALLENGE_METHOD__'>\n                <input type='hidden' name='csrf_token' value='__CSRF_TOKEN__'>\n                <input type='hidden' name='consent_action' value='allow'>\n                <button type='submit' class='btn btn-primary'>Allow</button>\n            </form>\n            \n            <form method='post' action='__CONSENT_ACTION_URL__' style='display: inline-block;'>                <input type='hidden' name='client_id' value='__CLIENT_ID_FORM__'>\n                <input type='hidden' name='redirect_uri' value='__REDIRECT_URI__'>\n                <input type='hidden' name='state' value='__STATE__'>\n                <input type='hidden' name='code_challenge' value='__CODE_CHALLENGE__'>\n                <input type='hidden' name='code_challenge_method' value='__CODE_CHALLENGE_METHOD__'>\n                <input type='hidden' name='csrf_token' value='__CSRF_TOKEN__'>\n                <input type='hidden' name='consent_action' value='deny'>\n                <button type='submit' class='btn btn-secondary'>Deny</button>\n            </form>\n        </div>\n    </div>\n</body>\n</html>\";\n        }\" />\n\n        <!-- Check for existing client denial cookie -->\n        <set-variable name=\"has_denial_cookie\" value=\"@{\n            try {\n                if (string.IsNullOrEmpty(context.Variables.GetValueOrDefault<string>(\"client_id\", \"\")) || \n                    string.IsNullOrEmpty(context.Variables.GetValueOrDefault<string>(\"redirect_uri\", \"\"))) {\n                    return false;\n                }\n                  \n                string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                // Use normalized redirect URI for consistency\n                string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                \n                // Cookie name for client denials\n                string DENIAL_COOKIE_NAME = \"MCP_DENIED_CLIENTS\";\n                \n                // Check for denial cookie in request\n                var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\n                if (string.IsNullOrEmpty(cookieHeader)) {\n                    return false;\n                }\n                \n                // Parse cookie header for denial cookie\n                string[] cookies = cookieHeader.Split(';');\n                foreach (string cookie in cookies) {\n                    string trimmedCookie = cookie.Trim();\n                    if (trimmedCookie.StartsWith(DENIAL_COOKIE_NAME + \"=\")) {\n                        // Extract cookie value\n                        string cookieValue = trimmedCookie.Substring(DENIAL_COOKIE_NAME.Length + 1);\n                        try {\n                            // Parse base64-encoded JSON array of denied clients\n                            string decodedValue = System.Text.Encoding.UTF8.GetString(\n                                System.Convert.FromBase64String(cookieValue.Split('.')[0]));\n                            JArray deniedClients = JArray.Parse(decodedValue);                            \n                            \n                            // Create client/redirect identifier\n                            // Use normalized redirect URI for consistency\n                            string clientKey = $\"{clientId}:{redirectUri}\";\n                            \n                            foreach (var item in deniedClients) {\n                                string itemString = item.ToString();\n                                \n                                // Direct comparison using normalized URI\n                                if (itemString == clientKey) {\n                                    return true;\n                                }\n                                \n                                // Handle URL-encoded redirect URI in stored cookie\n                                try {\n                                    string storedValue = itemString;\n                                    if (storedValue.Contains(':')) {\n                                        string[] parts = storedValue.Split(new char[] {':'}, 2);\n                                        if (parts.Length == 2) {\n                                            string storedClientId = parts[0];\n                                            // Decode stored redirect URI for comparison\n                                            string storedRedirectUri = System.Net.WebUtility.UrlDecode(parts[1]);\n                                            \n                                            // Compare both decoded forms\n                                            if (storedClientId == clientId && storedRedirectUri == redirectUri) {\n                                                return true;\n                                            }\n                                        }\n                                    }\n                                } catch (Exception ex) {\n                                    // Ignore comparison errors and continue\n                                }\n                            }\n                        } catch (Exception ex) {\n                            // Ignore cookie parsing errors and continue\n                        }\n                    }\n                }\n                \n                return false;\n            } catch (Exception ex) {\n                return false;\n            }\n        }\" />\n        \n        <!-- Check for existing client approval cookie -->\n        <set-variable name=\"has_approval_cookie\" value=\"@{\n            try {\n                if (string.IsNullOrEmpty(context.Variables.GetValueOrDefault<string>(\"client_id\", \"\")) || \n                    string.IsNullOrEmpty(context.Variables.GetValueOrDefault<string>(\"redirect_uri\", \"\"))) {\n                    return false;\n                }\n                  \n                string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                // Use normalized redirect URI for consistency\n                string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                \n                // Cookie name for client approvals\n                string APPROVAL_COOKIE_NAME = \"MCP_APPROVED_CLIENTS\";\n                \n                // Check for approval cookie in request\n                var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\n                if (string.IsNullOrEmpty(cookieHeader)) {\n                    return false;\n                }\n                \n                // Parse cookie header for approval cookie\n                string[] cookies = cookieHeader.Split(';');\n                foreach (string cookie in cookies) {\n                    string trimmedCookie = cookie.Trim();\n                    if (trimmedCookie.StartsWith(APPROVAL_COOKIE_NAME + \"=\")) {\n                        // Extract cookie value\n                        string cookieValue = trimmedCookie.Substring(APPROVAL_COOKIE_NAME.Length + 1);\n                        try {                            \n                            // Parse base64-encoded JSON array of approved clients\n                            string decodedValue = System.Text.Encoding.UTF8.GetString(\n                                System.Convert.FromBase64String(cookieValue.Split('.')[0]));\n                            JArray approvedClients = JArray.Parse(decodedValue);\n                            \n                            // Create client/redirect identifier\n                            // Use normalized redirect URI for consistency\n                            string clientKey = $\"{clientId}:{redirectUri}\";\n                            \n                            foreach (var item in approvedClients) {\n                                string itemString = item.ToString();\n                                \n                                // Direct comparison using normalized URI\n                                if (itemString == clientKey) {\n                                    return true;\n                                }\n                                \n                                // Handle URL-encoded redirect URI in stored cookie\n                                try {\n                                    string storedValue = itemString;\n                                    if (storedValue.Contains(':')) {\n                                        string[] parts = storedValue.Split(new char[] {':'}, 2);\n                                        if (parts.Length == 2) {\n                                            string storedClientId = parts[0];\n                                            // Decode stored redirect URI for comparison\n                                            string storedRedirectUri = System.Net.WebUtility.UrlDecode(parts[1]);\n                                            \n                                            // Compare both decoded forms\n                                            if (storedClientId == clientId && storedRedirectUri == redirectUri) {\n                                                return true;\n                                            }\n                                        }\n                                    }\n                                } catch (Exception ex) {\n                                    // Ignore comparison errors and continue\n                                }\n                            }\n                        } catch (Exception ex) {\n                            // Ignore cookie parsing errors and continue\n                        }\n                    }\n                }\n                \n                return false;\n            } catch (Exception ex) {\n                return false;\n            }\n        }\" />\n        \n        <set-variable name=\"consent_action\" value=\"@{\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\n            \n            if (!string.IsNullOrEmpty(formBody)) {\n                string[] pairs = formBody.Split('&');\n                foreach (string pair in pairs) {\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\n                    if (keyValue.Length == 2 && keyValue[0] == \"consent_action\") {\n                        return System.Net.WebUtility.UrlDecode(keyValue[1]);\n                    }\n                }\n                // Fallback to JSON parsing if form parsing failed\n                return context.Request.Body.As<JObject>(preserveContent: true)[\"consent_action\"]?.ToString() ?? \"\";\n            }\n            return \"\";\n        }\" />\n        \n        <!-- Extract CSRF token from form data -->\n        <set-variable name=\"csrf_token_from_form\" value=\"@{\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\n            \n            if (!string.IsNullOrEmpty(formBody)) {\n                string[] pairs = formBody.Split('&');\n                foreach (string pair in pairs) {\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\n                    if (keyValue.Length == 2 && keyValue[0] == \"csrf_token\") {\n                        return System.Net.WebUtility.UrlDecode(keyValue[1]);\n                    }\n                }\n            }\n            return \"\";\n        }\" />\n        \n        <!-- Validate CSRF token for POST requests -->\n        <set-variable name=\"csrf_valid\" value=\"@{\n            if (context.Request.Method != \"POST\") {\n                return true; // Only validate POST requests\n            }\n            \n            string submittedToken = context.Variables.GetValueOrDefault<string>(\"csrf_token_from_form\", \"\");\n            if (string.IsNullOrEmpty(submittedToken)) {\n                return false;\n            }\n            \n            // Token cache lookup validation happens next\n            string cacheKey = $\"CSRF-{submittedToken}\";\n            \n            return true; // Initial validation passes, detailed validation follows\n        }\" />\n        \n        <!-- Validate Origin/Referer headers for CSRF protection -->\n        <set-variable name=\"origin_referer_valid\" value=\"@{\n            if (context.Request.Method != \"POST\") {\n                return true; // Only validate state-changing operations\n            }\n            \n            // Get the target origin (expected origin)\n            string targetOrigin = \"{{APIMGatewayURL}}\";\n            \n            // Remove protocol and trailing slash for comparison\n            if (targetOrigin.StartsWith(\"https://\")) {\n                targetOrigin = targetOrigin.Substring(8);\n            } else if (targetOrigin.StartsWith(\"http://\")) {\n                targetOrigin = targetOrigin.Substring(7);\n            }\n            if (targetOrigin.EndsWith(\"/\")) {\n                targetOrigin = targetOrigin.TrimEnd('/');\n            }\n            \n            // First check Origin header (preferred)\n            string originHeader = context.Request.Headers.GetValueOrDefault(\"Origin\", \"\");\n            if (!string.IsNullOrEmpty(originHeader)) {\n                try {\n                    Uri originUri = new Uri(originHeader);\n                    string sourceOrigin = originUri.Host;\n                    if (originUri.Port != 80 && originUri.Port != 443) {\n                        sourceOrigin += \":\" + originUri.Port;\n                    }\n                    \n                    if (sourceOrigin.Equals(targetOrigin, StringComparison.OrdinalIgnoreCase)) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                } catch (Exception ex) {\n                    return false;\n                }\n            }\n            \n            // Fallback to Referer header if Origin is not present\n            string refererHeader = context.Request.Headers.GetValueOrDefault(\"Referer\", \"\");\n            if (!string.IsNullOrEmpty(refererHeader)) {\n                try {\n                    Uri refererUri = new Uri(refererHeader);\n                    string sourceOrigin = refererUri.Host;\n                    if (refererUri.Port != 80 && refererUri.Port != 443) {\n                        sourceOrigin += \":\" + refererUri.Port;\n                    }\n                    \n                    if (sourceOrigin.Equals(targetOrigin, StringComparison.OrdinalIgnoreCase)) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                } catch (Exception ex) {\n                    return false;\n                }\n            }\n            \n            // Neither Origin nor Referer header present - this is suspicious for POST requests\n            // OWASP recommends blocking such requests for better security\n            return false; // Block requests without proper origin validation\n        }\" />\n        \n        <!-- Validate Fetch Metadata headers for CSRF protection -->\n        <set-variable name=\"fetch_metadata_valid\" value=\"@{\n            // Check Sec-Fetch-Site header for cross-site request detection\n            string secFetchSite = context.Request.Headers.GetValueOrDefault(\"Sec-Fetch-Site\", \"\");\n            \n            // Allow same-origin, same-site, and direct navigation\n            if (string.IsNullOrEmpty(secFetchSite) || \n                secFetchSite == \"same-origin\" || \n                secFetchSite == \"same-site\" || \n                secFetchSite == \"none\") {\n                return true;\n            }\n            \n            // Block cross-site POST requests\n            if (context.Request.Method == \"POST\" && secFetchSite == \"cross-site\") {\n                return false;\n            }\n            \n            // Allow other values for compatibility\n            return true;\n        }\" />\n        \n        <!-- Lookup CSRF token from cache -->\n        <cache-lookup-value key=\"@($\"CSRF-{context.Variables.GetValueOrDefault<string>(\"csrf_token_from_form\")}\")\" variable-name=\"csrf_token_data\" />\n        \n        <!-- Validate CSRF token details -->\n        <set-variable name=\"csrf_validation_result\" value=\"@{\n            if (context.Request.Method != \"POST\") {\n                return \"valid\"; // No validation needed for GET requests\n            }\n            \n            string submittedToken = context.Variables.GetValueOrDefault<string>(\"csrf_token_from_form\", \"\");\n            if (string.IsNullOrEmpty(submittedToken)) {\n                return \"missing_token\";\n            }\n            \n            string tokenData = context.Variables.GetValueOrDefault<string>(\"csrf_token_data\");\n            if (string.IsNullOrEmpty(tokenData)) {\n                return \"invalid_token\";\n            }\n            \n            try {\n                // Extract token data (before debug info separator)\n                string actualTokenData = tokenData;\n                if (tokenData.Contains(\"|\")) {\n                    actualTokenData = tokenData.Split('|')[0];\n                }\n                \n                // Parse token data: client_id:redirect_uri:timestamp\n                // Since both redirect_uri and timestamp can contain colons, we need to be very careful\n                // The timestamp format is: YYYY-MM-DDTHH:mm:ssZ\n                // So we look for the last occurrence of a timestamp pattern\n                \n                // Find the last occurrence of a timestamp pattern (YYYY-MM-DDTHH:mm:ssZ)\n                var timestampPattern = @\":\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$\";\n                var timestampMatch = System.Text.RegularExpressions.Regex.Match(actualTokenData, timestampPattern);\n                \n                if (!timestampMatch.Success) {\n                    return \"malformed_token\";\n                }\n                \n                // Extract the timestamp (without the leading colon)\n                string timestampStr = timestampMatch.Value.Substring(1);\n                \n                // Extract everything before the timestamp match as the client_id:redirect_uri part\n                string clientAndRedirect = actualTokenData.Substring(0, timestampMatch.Index);\n                \n                // Split client_id:redirect_uri on the first colon only\n                int firstColonIndex = clientAndRedirect.IndexOf(':');\n                if (firstColonIndex == -1) {\n                    return \"malformed_token\";\n                }\n                \n                string tokenClientId = clientAndRedirect.Substring(0, firstColonIndex);\n                string tokenRedirectUri = clientAndRedirect.Substring(firstColonIndex + 1);\n                \n                // Validate client_id and redirect_uri match using constant-time comparison\n                string currentClientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                string currentRedirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                \n                // Constant-time string comparison for client_id to prevent timing attacks\n                bool clientIdMatches = true;\n                if (tokenClientId == null || currentClientId == null) {\n                    clientIdMatches = (tokenClientId == currentClientId);\n                } else if (tokenClientId.Length != currentClientId.Length) {\n                    clientIdMatches = false;\n                } else {\n                    int result = 0;\n                    for (int i = 0; i < tokenClientId.Length; i++) {\n                        result |= tokenClientId[i] ^ currentClientId[i];\n                    }\n                    clientIdMatches = (result == 0);\n                }\n                \n                if (!clientIdMatches) {\n                    return \"client_mismatch\";\n                }\n                \n                // Constant-time string comparison for redirect_uri to prevent timing attacks\n                bool redirectUriMatches = true;\n                if (tokenRedirectUri == null || currentRedirectUri == null) {\n                    redirectUriMatches = (tokenRedirectUri == currentRedirectUri);\n                } else if (tokenRedirectUri.Length != currentRedirectUri.Length) {\n                    redirectUriMatches = false;\n                } else {\n                    int result = 0;\n                    for (int i = 0; i < tokenRedirectUri.Length; i++) {\n                        result |= tokenRedirectUri[i] ^ currentRedirectUri[i];\n                    }\n                    redirectUriMatches = (result == 0);\n                }\n                \n                if (!redirectUriMatches) {\n                    return \"redirect_mismatch\";\n                }\n                \n                // Validate timestamp (token should not be older than 15 minutes)\n                DateTime tokenTime;\n                try {\n                    tokenTime = DateTime.Parse(timestampStr);\n                } catch (Exception) {\n                    return \"invalid_timestamp\";\n                }\n                \n                TimeSpan age = DateTime.UtcNow - tokenTime;\n                if (age.TotalMinutes > 15) {\n                    return \"expired_token\";\n                }\n                \n                return \"valid\";\n                \n            } catch (Exception ex) {\n                return \"validation_error\";\n            }\n        }\" />\n        \n        <!-- If this is a form submission, process the consent choice -->\n        <choose>\n            <when condition=\"@(context.Request.Method == \"POST\")\">\n                <!-- Validate Origin/Referer headers -->\n                <choose>\n                    <when condition=\"@(!context.Variables.GetValueOrDefault<bool>(\"origin_referer_valid\"))\">\n                        <!-- Origin/Referer validation failed -->\n                        <return-response>\n                            <set-status code=\"403\" reason=\"Forbidden\" />\n                            <set-header name=\"Content-Type\" exists-action=\"override\">\n                                <value>text/html</value>\n                            </set-header>\n                            <set-header name=\"Cache-Control\" exists-action=\"override\">\n                                <value>no-store, no-cache</value>\n                            </set-header>\n                            <set-header name=\"Pragma\" exists-action=\"override\">\n                                <value>no-cache</value>\n                            </set-header>\n                            <set-body>@(context.Variables.GetValueOrDefault<string>(\"generate_403_response\"))</set-body>\n                        </return-response>\n                    </when>\n                    <otherwise>\n                        <!-- Origin/Referer validation passed -->\n                        <!-- Validate Fetch Metadata headers -->\n                        <choose>\n                            <when condition=\"@(!context.Variables.GetValueOrDefault<bool>(\"fetch_metadata_valid\"))\">\n                                <!-- Fetch metadata validation failed -->\n                                <return-response>\n                                    <set-status code=\"403\" reason=\"Forbidden\" />\n                                    <set-header name=\"Content-Type\" exists-action=\"override\">\n                                        <value>text/html</value>\n                                    </set-header>\n                                    <set-header name=\"Cache-Control\" exists-action=\"override\">\n                                        <value>no-store, no-cache</value>\n                                    </set-header>\n                                    <set-header name=\"Pragma\" exists-action=\"override\">\n                                        <value>no-cache</value>\n                                    </set-header>\n                                    <set-body>@(context.Variables.GetValueOrDefault<string>(\"generate_403_response\"))</set-body>\n                                </return-response>\n                            </when>\n                            <otherwise>\n                                <!-- Fetch metadata validation passed -->\n                                <!-- Validate CSRF token -->\n                                <choose>\n                                    <when condition=\"@(context.Variables.GetValueOrDefault<string>(\"csrf_validation_result\") != \"valid\")\">\n                                        <!-- CSRF validation failed -->\n                                        <return-response>\n                                            <set-status code=\"403\" reason=\"Forbidden\" />\n                                            <set-header name=\"Content-Type\" exists-action=\"override\">\n                                                <value>text/html</value>\n                                            </set-header>\n                                            <set-header name=\"Cache-Control\" exists-action=\"override\">\n                                                <value>no-store, no-cache</value>\n                                            </set-header>\n                                            <set-header name=\"Pragma\" exists-action=\"override\">\n                                                <value>no-cache</value>\n                                            </set-header>\n                                            <set-body>@(context.Variables.GetValueOrDefault<string>(\"generate_403_response\"))</set-body>\n                                        </return-response>\n                                    </when>\n                                    <otherwise>\n                                        <!-- CSRF validation passed -->\n                                        <!-- Delete CSRF token from cache to prevent reuse -->\n                                        <cache-remove-value key=\"@($\"CSRF-{context.Variables.GetValueOrDefault<string>(\"csrf_token_from_form\")}\")\" />\n                                        \n                                        <choose>\n                                            <when condition=\"@(context.Variables.GetValueOrDefault<string>(\"consent_action\") == \"allow\")\">\n                        <!-- Process consent approval -->\n                        <set-variable name=\"response_status_code\" value=\"302\" />\n                        <set-variable name=\"response_redirect_location\" value=\"@{\n                            string baseUrl = \"{{APIMGatewayURL}}\";\n                            \n                            // Use already extracted parameters instead of re-parsing form data\n                            string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                            string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                            string state = context.Variables.GetValueOrDefault<string>(\"state\", \"\");\n                            \n                            // URL encode parameters to prevent injection attacks\n                            string encodedClientId = System.Net.WebUtility.UrlEncode(clientId);\n                            string encodedRedirectUri = System.Net.WebUtility.UrlEncode(redirectUri);\n                            // State is already properly encoded from form submission, don't double-encode\n                            string encodedState = state;\n                            \n                            // Add PKCE parameters if they exist\n                            string codeChallenge = context.Variables.GetValueOrDefault<string>(\"code_challenge\", \"\");\n                            string codeChallengeMethod = context.Variables.GetValueOrDefault<string>(\"code_challenge_method\", \"\");\n                            \n                            string url = $\"{baseUrl}/authorize?client_id={encodedClientId}&redirect_uri={encodedRedirectUri}&state={encodedState}\";\n                            \n                            if (!string.IsNullOrEmpty(codeChallenge)) {\n                                url += $\"&code_challenge={System.Net.WebUtility.UrlEncode(codeChallenge)}\";\n                            }\n                            \n                            if (!string.IsNullOrEmpty(codeChallengeMethod)) {\n                                url += $\"&code_challenge_method={System.Net.WebUtility.UrlEncode(codeChallengeMethod)}\";\n                            }\n                            \n                            return url;\n                        }\" />\n                          <!-- Calculate approval cookie value -->\n                        <set-variable name=\"approval_cookie\" value=\"@{\n                            string cookieName = \"MCP_APPROVED_CLIENTS\";\n                            \n                            // Use already extracted parameters instead of re-parsing form data\n                            string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                            string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                            \n                            // Create a unique identifier for this client/redirect combination\n                            string clientKey = $\"{clientId}:{redirectUri}\";\n                            \n                            // Check for existing cookie\n                            var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\n                            JArray approvedClients = new JArray();\n                            \n                            if (!string.IsNullOrEmpty(cookieHeader)) {\n                                // Parse cookies to find our approval cookie\n                                string[] cookies = cookieHeader.Split(';');\n                                foreach (string cookie in cookies) {\n                                    string trimmedCookie = cookie.Trim();\n                                    if (trimmedCookie.StartsWith(cookieName + \"=\")) {\n                                        try {\n                                            // Extract and parse the cookie value\n                                            string cookieValue = trimmedCookie.Substring(cookieName.Length + 1);\n                                            // Get the payload part (before the first dot if cookie is signed)\n                                            string payload = cookieValue.Contains('.') ? \n                                                cookieValue.Split('.')[0] : cookieValue;\n                                            string decodedValue = System.Text.Encoding.UTF8.GetString(\n                                                System.Convert.FromBase64String(payload));\n                                            approvedClients = JArray.Parse(decodedValue);\n                                        } catch (Exception) {\n                                            // If parsing fails, we'll just create a new cookie\n                                            approvedClients = new JArray();\n                                        }\n                                        break;\n                                    }\n                                }\n                            }\n                            \n                            // Add the current client if not already in the list\n                            bool clientExists = false;\n                            foreach (var item in approvedClients) {\n                                if (item.ToString() == clientKey) {\n                                    clientExists = true;\n                                    break;\n                                }\n                            }\n                            \n                            if (!clientExists) {\n                                approvedClients.Add(clientKey);\n                            }\n                            \n                            // Base64 encode the client list\n                            string jsonClients = approvedClients.ToString(Newtonsoft.Json.Formatting.None);\n                            string encodedClients = System.Convert.ToBase64String(\n                                System.Text.Encoding.UTF8.GetBytes(jsonClients));\n                            \n                            // Return the full cookie string with appropriate settings\n                            return $\"{cookieName}={encodedClients}; Max-Age=31536000; Path=/; Secure; HttpOnly; SameSite=Lax\";\n                        }\" />\n                        \n                        <!-- Set variables for outbound policy awareness -->\n                        <set-variable name=\"consent_approved\" value=\"true\" />\n                        <set-variable name=\"cookie_name\" value=\"MCP_APPROVED_CLIENTS\" />\n                        \n                        <!-- Return the response with the cookie already set -->\n                        <return-response>\n                            <set-status code=\"302\" reason=\"Found\" />\n                            <set-header name=\"Location\" exists-action=\"override\">\n                                <value>@(context.Variables.GetValueOrDefault<string>(\"response_redirect_location\", \"\"))</value>\n                            </set-header>\n                            <set-header name=\"Set-Cookie\" exists-action=\"append\">\n                                <value>@(context.Variables.GetValueOrDefault<string>(\"approval_cookie\"))</value>\n                            </set-header>\n                        </return-response>\n                    </when>\n                    <when condition=\"@(context.Variables.GetValueOrDefault<string>(\"consent_action\") == \"deny\")\">\n                        <!-- Process consent denial -->\n                        <set-variable name=\"response_status_code\" value=\"403\" />\n                        <set-variable name=\"response_content_type\" value=\"text/html\" />\n                        <set-variable name=\"response_cache_control\" value=\"no-store, no-cache\" />\n                        <set-variable name=\"response_pragma\" value=\"no-cache\" />\n                        \n                        <!-- Calculate the cookie value right here in inbound before returning response -->\n                        <set-variable name=\"denial_cookie\" value=\"@{\n                            string cookieName = \"MCP_DENIED_CLIENTS\";\n                            \n                            // Use already extracted parameters instead of re-parsing form data\n                            string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                            string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                            \n                            // Create a unique identifier for this client/redirect combination\n                            string clientKey = $\"{clientId}:{redirectUri}\";\n                            \n                            // Check for existing cookie\n                            var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\n                            JArray deniedClients = new JArray();\n                            \n                            if (!string.IsNullOrEmpty(cookieHeader)) {\n                                // Parse cookies to find our denial cookie\n                                string[] cookies = cookieHeader.Split(';');\n                                foreach (string cookie in cookies) {\n                                    string trimmedCookie = cookie.Trim();\n                                    if (trimmedCookie.StartsWith(cookieName + \"=\")) {\n                                        try {\n                                            // Extract and parse the cookie value\n                                            string cookieValue = trimmedCookie.Substring(cookieName.Length + 1);\n                                            // Get the payload part (before the first dot if cookie is signed)\n                                            string payload = cookieValue.Contains('.') ? \n                                                cookieValue.Split('.')[0] : cookieValue;\n                                            string decodedValue = System.Text.Encoding.UTF8.GetString(\n                                                System.Convert.FromBase64String(payload));\n                                            deniedClients = JArray.Parse(decodedValue);\n                                        } catch (Exception) {\n                                            // If parsing fails, we'll just create a new cookie\n                                            deniedClients = new JArray();\n                                        }\n                                        break;\n                                    }\n                                }\n                            }\n                            \n                            // Add the current client if not already in the list\n                            bool clientExists = false;\n                            foreach (var item in deniedClients) {\n                                if (item.ToString() == clientKey) {\n                                    clientExists = true;\n                                    break;\n                                }\n                            }\n                            \n                            if (!clientExists) {\n                                deniedClients.Add(clientKey);\n                            }\n                            \n                            // Base64 encode the client list\n                            string jsonClients = deniedClients.ToString(Newtonsoft.Json.Formatting.None);\n                            string encodedClients = System.Convert.ToBase64String(\n                                System.Text.Encoding.UTF8.GetBytes(jsonClients));\n                            \n                            // Return the full cookie string with appropriate settings\n                            return $\"{cookieName}={encodedClients}; Max-Age=31536000; Path=/; Secure; HttpOnly; SameSite=Lax\";\n                        }\" />                        <!-- Store the HTML content for the access denied page -->\n                        <set-variable name=\"response_body\" value=\"@{\n                            string denialTemplate = context.Variables.GetValueOrDefault<string>(\"access_denied_template\");\n                            string commonStyles = context.Variables.GetValueOrDefault<string>(\"common_styles\");\n                            \n                            // Replace placeholders with actual content\n                            denialTemplate = denialTemplate.Replace(\"__COMMON_STYLES__\", commonStyles);\n                            denialTemplate = denialTemplate.Replace(\"__DENIAL_MESSAGE__\", \n                                \"You have denied authorization for this application against the MCP server.\");\n                            \n                            return denialTemplate;\n                        }\" />\n                        \n                        <!-- Set variables for outbound policy awareness -->\n                        <set-variable name=\"consent_denied\" value=\"true\" />\n                        <set-variable name=\"cookie_name\" value=\"MCP_DENIED_CLIENTS\" />\n                        \n                        <!-- Return the response with the cookie already set -->\n                        <return-response>\n                            <set-status code=\"403\" reason=\"Forbidden\" />\n                            <set-header name=\"Content-Type\" exists-action=\"override\">\n                                <value>text/html</value>\n                            </set-header>\n                            <set-header name=\"Cache-Control\" exists-action=\"override\">\n                                <value>no-store, no-cache</value>\n                            </set-header>\n                            <set-header name=\"Pragma\" exists-action=\"override\">\n                                <value>no-cache</value>\n                            </set-header>\n                            <set-header name=\"Set-Cookie\" exists-action=\"append\">\n                                <value>@(context.Variables.GetValueOrDefault<string>(\"denial_cookie\"))</value>\n                            </set-header>\n                            <set-body>@(context.Variables.GetValueOrDefault<string>(\"response_body\", \"\"))</set-body>\n                        </return-response>\n                    </when>\n                    <otherwise>\n                        <!-- Invalid consent action - return error -->\n                        <return-response>\n                            <set-status code=\"403\" reason=\"Forbidden\" />\n                            <set-header name=\"Content-Type\" exists-action=\"override\">\n                                <value>text/html</value>\n                            </set-header>\n                            <!-- Explicitly disable any redirects -->\n                            <set-header name=\"Cache-Control\" exists-action=\"override\">\n                                <value>no-store, no-cache</value>\n                            </set-header>\n                            <set-header name=\"Pragma\" exists-action=\"override\">\n                                <value>no-cache</value>\n                            </set-header>\n                            <set-body>@{\n                                string denialTemplate = context.Variables.GetValueOrDefault<string>(\"access_denied_template\");\n                                string commonStyles = context.Variables.GetValueOrDefault<string>(\"common_styles\");\n                                string consentAction = context.Variables.GetValueOrDefault<string>(\"consent_action\", \"\");\n                                \n                                string detailedMessage = $\"Invalid consent action '{consentAction}' received. Expected 'allow' or 'deny'. This may indicate a form tampering attempt or a browser compatibility issue.\";\n                                \n                                // Replace placeholders with actual content\n                                denialTemplate = denialTemplate.Replace(\"__COMMON_STYLES__\", commonStyles);\n                                denialTemplate = denialTemplate.Replace(\"__DENIAL_MESSAGE__\", detailedMessage);\n                                \n                                return denialTemplate;\n                            }</set-body>\n                        </return-response>\n                                            </otherwise>\n                                        </choose>\n                                    </otherwise>\n                                </choose>\n                            </otherwise>\n                        </choose>\n                    </otherwise>\n                </choose>\n            </when>\n            <!-- For GET requests, check for cookies first, then display consent page if no cookie found -->\n            <otherwise>\n                <choose>\n                    <!-- If there's an approval cookie, skip consent and redirect to authorization endpoint -->\n                    <when condition=\"@(context.Variables.GetValueOrDefault<bool>(\"has_approval_cookie\"))\">\n                        <!-- Set redirect location to authorization endpoint -->\n                        <set-variable name=\"response_redirect_location\" value=\"@{\n                            string baseUrl = \"{{APIMGatewayURL}}\";\n                            string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                            string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                            string state = context.Variables.GetValueOrDefault<string>(\"state\", \"\");\n                            \n                            // URL encode parameters to prevent injection attacks\n                            string encodedClientId = System.Net.WebUtility.UrlEncode(clientId);\n                            string encodedRedirectUri = System.Net.WebUtility.UrlEncode(redirectUri);\n                            // State is already properly encoded, don't double-encode\n                            string encodedState = state;\n                            \n                            // Add PKCE parameters if they exist\n                            string codeChallenge = context.Variables.GetValueOrDefault<string>(\"code_challenge\", \"\");\n                            string codeChallengeMethod = context.Variables.GetValueOrDefault<string>(\"code_challenge_method\", \"\");\n                            \n                            string url = $\"{baseUrl}/authorize?client_id={encodedClientId}&redirect_uri={encodedRedirectUri}&state={encodedState}\";\n                            \n                            if (!string.IsNullOrEmpty(codeChallenge)) {\n                                url += $\"&code_challenge={System.Net.WebUtility.UrlEncode(codeChallenge)}\";\n                            }\n                            \n                            if (!string.IsNullOrEmpty(codeChallengeMethod)) {\n                                url += $\"&code_challenge_method={System.Net.WebUtility.UrlEncode(codeChallengeMethod)}\";\n                            }\n                            \n                            return url;\n                        }\" />\n                        \n                        <!-- Redirect to authorization endpoint -->\n                        <return-response>\n                            <set-status code=\"302\" reason=\"Found\" />\n                            <set-header name=\"Location\" exists-action=\"override\">\n                                <value>@(context.Variables.GetValueOrDefault<string>(\"response_redirect_location\", \"\"))</value>\n                            </set-header>\n                        </return-response>\n                    </when>\n                    \n                    <!-- If there's a denial cookie, return access denied page immediately -->\n                    <when condition=\"@(context.Variables.GetValueOrDefault<bool>(\"has_denial_cookie\"))\">\n                        <return-response>\n                            <set-status code=\"403\" reason=\"Forbidden\" />\n                            <set-header name=\"Content-Type\" exists-action=\"override\">\n                                <value>text/html</value>\n                            </set-header>\n                            <!-- Explicitly disable any redirects -->\n                            <set-header name=\"Cache-Control\" exists-action=\"override\">\n                                <value>no-store, no-cache</value>\n                            </set-header>\n                            <set-header name=\"Pragma\" exists-action=\"override\">\n                                <value>no-cache</value>\n                            </set-header>\n                            <set-body>@{\n                                string denialTemplate = context.Variables.GetValueOrDefault<string>(\"access_denied_template\");\n                                string commonStyles = context.Variables.GetValueOrDefault<string>(\"common_styles\");\n                                \n                                // Replace placeholders with actual content\n                                denialTemplate = denialTemplate.Replace(\"__COMMON_STYLES__\", commonStyles);\n                                denialTemplate = denialTemplate.Replace(\"__DENIAL_MESSAGE__\", \n                                    \"You have previously denied access to this application.\");\n                                \n                                return denialTemplate;\n                            }</set-body>\n                        </return-response>\n                    </when>\n                      <!-- If no cookies found, show the consent screen -->\n                    <otherwise>\n                        <!-- Check if client is registered first -->\n                        <choose>\n                            <when condition=\"@(!context.Variables.GetValueOrDefault<bool>(\"is_client_registered\"))\">\n                                <!-- Client is not registered, show error page -->\n                                <return-response>\n                                    <set-status code=\"403\" reason=\"Forbidden\" />\n                                    <set-header name=\"Content-Type\" exists-action=\"override\">\n                                        <value>text/html</value>\n                                    </set-header>\n                                    <set-header name=\"Cache-Control\" exists-action=\"override\">\n                                        <value>no-store, no-cache</value>\n                                    </set-header>\n                                    <set-header name=\"Pragma\" exists-action=\"override\">\n                                        <value>no-cache</value>\n                                    </set-header>\n                                    <set-body>@{\n                                        string template = context.Variables.GetValueOrDefault<string>(\"client_not_found_template\");\n                                        string commonStyles = context.Variables.GetValueOrDefault<string>(\"common_styles\");\n                                        string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                                        string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                                        \n                                        // Replace placeholders with HTML-encoded content to prevent XSS\n                                        template = template.Replace(\"__COMMON_STYLES__\", commonStyles);\n                                        template = template.Replace(\"__CLIENT_ID_DISPLAY__\", System.Net.WebUtility.HtmlEncode(clientId));\n                                        template = template.Replace(\"__REDIRECT_URI__\", System.Net.WebUtility.HtmlEncode(redirectUri));\n                                        \n                                        return template;\n                                    }</set-body>\n                                </return-response>\n                            </when>\n                            <otherwise>                                <!-- Client is registered, get client name from the cache -->\n                                <!-- Build consent page using the standardized template -->\n                                <set-variable name=\"consent_page\" value=\"@{\n                                    string template = context.Variables.GetValueOrDefault<string>(\"consent_page_template\");\n                                    string commonStyles = context.Variables.GetValueOrDefault<string>(\"common_styles\");\n                                    \n                                    // Use the service URL from APIM configuration\n                                    string basePath = \"{{APIMGatewayURL}}\";\n                                    \n                                    string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                                    string clientName = context.Variables.GetValueOrDefault<string>(\"client_name\", \"Unknown Application\");\n                                    string clientUri = context.Variables.GetValueOrDefault<string>(\"client_uri\", \"N/A\");\n                                    string oauthScopes = context.Variables.GetValueOrDefault<string>(\"oauth_scopes\", \"\");\n                                    \n                                    // Get the normalized (human-readable) redirect URI for display\n                                    string normalizedRedirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                                    \n                                    // Use the normalized redirect URI for form submission to ensure consistency\n                                    string formRedirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                                    string htmlEncodedFormUri = System.Net.WebUtility.HtmlEncode(formRedirectUri);\n                                    \n                                    string state = context.Variables.GetValueOrDefault<string>(\"state\", \"\");\n                                    string csrfToken = context.Variables.GetValueOrDefault<string>(\"csrf_token\", \"\");\n                                    \n                                    // Create a temporary placeholder for the form fields\n                                    string FORM_FIELD_PLACEHOLDER = \"___ENCODED_REDIRECT_URI___\";\n                                    \n                                    // Replace the styles first\n                                    template = template.Replace(\"__COMMON_STYLES__\", commonStyles);\n                                    \n                                    // First, create a temporary placeholder for the form fields\n                                    template = template.Replace(\"value='__REDIRECT_URI__'\", \"value='\" + FORM_FIELD_PLACEHOLDER + \"'\");\n                                      \n                                    // Replace template placeholders with properly encoded values\n                                    template = template.Replace(\"__CLIENT_NAME__\", System.Net.WebUtility.HtmlEncode(clientName));\n                                    template = template.Replace(\"__CLIENT_URI__\", System.Net.WebUtility.HtmlEncode(clientUri));\n                                    // For display purposes, use HtmlEncode for safety\n                                    template = template.Replace(\"__CLIENT_ID_DISPLAY__\", System.Net.WebUtility.HtmlEncode(clientId));\n                                    template = template.Replace(\"__REDIRECT_URI__\", System.Net.WebUtility.HtmlEncode(normalizedRedirectUri));\n                                    // For form field values, use HtmlEncode for XSS protection\n                                    template = template.Replace(\"__CLIENT_ID_FORM__\", System.Net.WebUtility.HtmlEncode(clientId));\n                                    // State needs to be URL-decoded first since it comes URL-encoded from query, then HTML-encoded for form safety\n                                    string decodedState = System.Net.WebUtility.UrlDecode(state);\n                                    template = template.Replace(\"__STATE__\", System.Net.WebUtility.HtmlEncode(decodedState));\n                                    template = template.Replace(\"__CODE_CHALLENGE__\", System.Net.WebUtility.HtmlEncode(context.Variables.GetValueOrDefault<string>(\"code_challenge\", \"\")));\n                                    template = template.Replace(\"__CODE_CHALLENGE_METHOD__\", System.Net.WebUtility.HtmlEncode(context.Variables.GetValueOrDefault<string>(\"code_challenge_method\", \"\")));\n                                    template = template.Replace(\"__CSRF_TOKEN__\", System.Net.WebUtility.HtmlEncode(csrfToken));\n                                    template = template.Replace(\"__CONSENT_ACTION_URL__\", basePath + \"/consent\");                                    \n                                    // Handle space-separated OAuth scopes and create individual list items with HTML encoding\n                                    string[] scopeArray = oauthScopes.Split(new char[] {' '}, StringSplitOptions.RemoveEmptyEntries);\n                                    StringBuilder scopeList = new StringBuilder();\n                                    \n                                    foreach (string scope in scopeArray) {\n                                        scopeList.AppendLine($\"<li><code>{System.Net.WebUtility.HtmlEncode(scope)}</code></li>\");\n                                    }\n                                    \n                                    template = template.Replace(\"__OAUTH_SCOPES__\", scopeList.ToString());\n                                    \n                                // Replace form field placeholder with encoded URI\n                                template = template.Replace(FORM_FIELD_PLACEHOLDER, htmlEncodedFormUri);                                    return template;\n                                }\" />\n                                \n                                <!-- Return consent page -->\n                                <return-response>\n                                    <set-status code=\"200\" reason=\"OK\" />\n                                    <set-header name=\"Content-Type\" exists-action=\"override\">\n                                        <value>text/html</value>\n                                    </set-header>\n                                    <!-- Security headers -->\n                                    <set-header name=\"X-Frame-Options\" exists-action=\"override\">\n                                        <value>DENY</value>\n                                    </set-header>\n                                    <set-header name=\"X-Content-Type-Options\" exists-action=\"override\">\n                                        <value>nosniff</value>\n                                    </set-header>\n                                    <set-header name=\"X-XSS-Protection\" exists-action=\"override\">\n                                        <value>1; mode=block</value>\n                                    </set-header>\n                                    <set-header name=\"Referrer-Policy\" exists-action=\"override\">\n                                        <value>strict-origin-when-cross-origin</value>\n                                    </set-header>\n                                    <set-header name=\"Content-Security-Policy\" exists-action=\"override\">\n                                        <value>default-src 'self'; style-src 'unsafe-inline'; script-src 'none'; object-src 'none'; base-uri 'self'; form-action 'self' https:</value>\n                                    </set-header>\n                                    <set-header name=\"Cache-Control\" exists-action=\"override\">\n                                        <value>no-store, no-cache, must-revalidate</value>\n                                    </set-header>\n                                    <set-header name=\"Pragma\" exists-action=\"override\">\n                                        <value>no-cache</value>\n                                    </set-header>\n                                    <set-body>@{\n                                        return context.Variables.GetValueOrDefault<string>(\"consent_page\", \"\");\n                                    }</set-body>\n                                </return-response>\n                            </otherwise>\n                        </choose>\n                    </otherwise>\n                </choose>\n            </otherwise>\n        </choose>\n    </inbound>\n    <backend>\n        <base />\n    </backend>\n    <outbound>\n        <base />\n        <!-- Debug trace for variable verification -->\n        <trace source=\"outbound-debug\" severity=\"information\">\n            <message>@{\n                return $\"Outbound policy: consent_approved={context.Variables.GetValueOrDefault<bool>(\"consent_approved\")}, consent_denied={context.Variables.GetValueOrDefault<bool>(\"consent_denied\")}, cookie_name={context.Variables.GetValueOrDefault<string>(\"cookie_name\")}\";\n            }</message>\n        </trace>\n        \n        <!-- Set cookies based on consent decision -->\n        <choose>\n            <!-- Handle approval cookie -->\n            <when condition=\"@(context.Variables.GetValueOrDefault<bool>(\"consent_approved\"))\">\n                <set-header name=\"Set-Cookie\" exists-action=\"append\">\n                    <value>@{\n                        string cookieName = context.Variables.GetValueOrDefault<string>(\"cookie_name\", \"MCP_APPROVED_CLIENTS\");\n                        string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                        // Use normalized redirect URI for cookies\n                        string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                        \n                        // Create unique client/redirect identifier\n                        string clientKey = $\"{clientId}:{redirectUri}\";\n                        \n                        // Check for existing cookie\n                        var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\n                        JArray approvedClients = new JArray();\n                        \n                        if (!string.IsNullOrEmpty(cookieHeader)) {\n                            // Parse cookies to find approval cookie\n                            string[] cookies = cookieHeader.Split(';');\n                            foreach (string cookie in cookies) {\n                                string trimmedCookie = cookie.Trim();\n                                if (trimmedCookie.StartsWith(cookieName + \"=\")) {\n                                    try {\n                                        // Extract and parse cookie value\n                                        string cookieValue = trimmedCookie.Substring(cookieName.Length + 1);\n                                        // Get payload part (before first dot if signed)\n                                        string payload = cookieValue.Contains('.') ? \n                                            cookieValue.Split('.')[0] : cookieValue;\n                                        string decodedValue = System.Text.Encoding.UTF8.GetString(\n                                            System.Convert.FromBase64String(payload));\n                                        approvedClients = JArray.Parse(decodedValue);\n                                    } catch (Exception) {\n                                        // If parsing fails, create new cookie\n                                        approvedClients = new JArray();\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                        \n                        // Add the current client if not already in the list\n                        bool clientExists = false;\n                        foreach (var item in approvedClients) {\n                            if (item.ToString() == clientKey) {\n                                clientExists = true;\n                                break;\n                            }\n                        }\n                        \n                        if (!clientExists) {\n                            approvedClients.Add(clientKey);\n                        }\n                        \n                        // Base64 encode the client list\n                        string jsonClients = approvedClients.ToString(Newtonsoft.Json.Formatting.None);\n                        string encodedClients = System.Convert.ToBase64String(\n                            System.Text.Encoding.UTF8.GetBytes(jsonClients));\n                        \n                        // Return the cookie with appropriate settings\n                        return $\"{cookieName}={encodedClients}; Max-Age=31536000; Path=/; Secure; HttpOnly; SameSite=Lax\";\n                    }</value>\n                </set-header>\n                \n                <!-- Set response status and redirect for approval -->\n                <set-status code=\"@(context.Variables.GetValueOrDefault<int>(\"response_status_code\", 302))\" reason=\"Found\" />\n                <set-header name=\"Location\" exists-action=\"override\">\n                    <value>@(context.Variables.GetValueOrDefault<string>(\"response_redirect_location\", \"\"))</value>\n                </set-header>\n            </when>\n            \n            <!-- Handle denial cookie -->\n            <when condition=\"@(context.Variables.GetValueOrDefault<bool>(\"consent_denied\"))\">\n                <set-header name=\"Set-Cookie\" exists-action=\"append\">\n                    <value>@{\n                        string cookieName = context.Variables.GetValueOrDefault<string>(\"cookie_name\", \"MCP_DENIED_CLIENTS\");\n                        string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                        // Use normalized redirect URI for cookies\n                        string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                        \n                        // Create unique client/redirect identifier\n                        string clientKey = $\"{clientId}:{redirectUri}\";\n                        \n                        // Check for existing cookie\n                        var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\n                        JArray deniedClients = new JArray();\n                        \n                        if (!string.IsNullOrEmpty(cookieHeader)) {\n                            // Parse cookies to find denial cookie\n                            string[] cookies = cookieHeader.Split(';');\n                            foreach (string cookie in cookies) {\n                                string trimmedCookie = cookie.Trim();\n                                if (trimmedCookie.StartsWith(cookieName + \"=\")) {\n                                    try {\n                                        // Extract and parse cookie value\n                                        string cookieValue = trimmedCookie.Substring(cookieName.Length + 1);\n                                        // Get payload part (before first dot if signed)\n                                        string payload = cookieValue.Contains('.') ? \n                                            cookieValue.Split('.')[0] : cookieValue;\n                                        string decodedValue = System.Text.Encoding.UTF8.GetString(\n                                            System.Convert.FromBase64String(payload));\n                                        deniedClients = JArray.Parse(decodedValue);\n                                    } catch (Exception) {\n                                        // If parsing fails, create new cookie\n                                        deniedClients = new JArray();\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                        \n                        // Add client if not already in list\n                        bool clientExists = false;\n                        foreach (var item in deniedClients) {\n                            if (item.ToString() == clientKey) {\n                                clientExists = true;\n                                break;\n                            }\n                        }\n                        \n                        if (!clientExists) {\n                            deniedClients.Add(clientKey);\n                        }\n                        \n                        // Base64 encode client list\n                        string jsonClients = deniedClients.ToString(Newtonsoft.Json.Formatting.None);\n                        string encodedClients = System.Convert.ToBase64String(\n                            System.Text.Encoding.UTF8.GetBytes(jsonClients));\n                        \n                        // Return cookie with security settings\n                        return $\"{cookieName}={encodedClients}; Max-Age=31536000; Path=/; Secure; HttpOnly; SameSite=Lax\";\n                    }</value>\n                </set-header>\n            </when>\n        </choose>\n    </outbound>\n    <on-error>\n        <base />\n    </on-error>\n</policies>\n",
            "$fxv#8": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<!--\n    Consent Policy - Handles user consent for OAuth client applications\n    \n    Flow:\n    1. Check existing consent status (cookies)\n    2. Display consent form for new clients\n    3. Process user response (allow/deny)\n    4. Store decision and redirect appropriately\n-->\n<policies>\n    <inbound>        \n        <base />        \n        <!-- Helper function to extract parameters from form/query -->\n        <set-variable name=\"form_body\" value=\"@{\n            if (context.Request.Method == \"POST\") {\n                string contentType = context.Request.Headers.GetValueOrDefault(\"Content-Type\", \"\");\n                if (contentType.Contains(\"application/x-www-form-urlencoded\")) {\n                    return context.Request.Body.As<string>(preserveContent: true);\n                }\n            }\n            return \"\";\n        }\" />\n        \n        <!-- Extract request parameters using consolidated logic -->\n        <set-variable name=\"client_id\" value=\"@{\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\n            \n            // Check form data first (POST)\n            if (!string.IsNullOrEmpty(formBody)) {\n                string[] pairs = formBody.Split('&');\n                foreach (string pair in pairs) {\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\n                    if (keyValue.Length == 2 && keyValue[0] == \"client_id\") {\n                        return System.Net.WebUtility.UrlDecode(keyValue[1]);\n                    }\n                }\n            }\n            // Fallback to query string (GET)\n            return (string)context.Request.Url.Query.GetValueOrDefault(\"client_id\", \"\");\n        }\" />\n        \n        <set-variable name=\"redirect_uri\" value=\"@{\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\n            \n            // Check form data first (POST)\n            if (!string.IsNullOrEmpty(formBody)) {\n                string[] pairs = formBody.Split('&');\n                foreach (string pair in pairs) {\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\n                    if (keyValue.Length == 2 && keyValue[0] == \"redirect_uri\") {\n                        return keyValue[1]; // Keep encoded for normalization\n                    }\n                }\n            }\n            // Fallback to query string (GET)\n            return (string)context.Request.Url.Query.GetValueOrDefault(\"redirect_uri\", \"\");\n        }\" />\n        \n        <set-variable name=\"state\" value=\"@{\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\n            \n            // Check form data first (POST)\n            if (!string.IsNullOrEmpty(formBody)) {\n                string[] pairs = formBody.Split('&');\n                foreach (string pair in pairs) {\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\n                    if (keyValue.Length == 2 && keyValue[0] == \"state\") {\n                        return keyValue[1]; // Keep encoded\n                    }\n                }\n            }\n            // Fallback to query string (GET)\n            return (string)context.Request.Url.Query.GetValueOrDefault(\"state\", \"\") ?? \"\";\n        }\" />\n        \n        <set-variable name=\"code_challenge\" value=\"@{\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\n            \n            // Check form data first (POST)\n            if (!string.IsNullOrEmpty(formBody)) {\n                string[] pairs = formBody.Split('&');\n                foreach (string pair in pairs) {\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\n                    if (keyValue.Length == 2 && keyValue[0] == \"code_challenge\") {\n                        return keyValue[1]; // Keep encoded\n                    }\n                }\n            }\n            // Fallback to query string (GET)\n            return (string)context.Request.Url.Query.GetValueOrDefault(\"code_challenge\", \"\");\n        }\" />\n        \n        <set-variable name=\"code_challenge_method\" value=\"@{\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\n            \n            // Check form data first (POST)\n            if (!string.IsNullOrEmpty(formBody)) {\n                string[] pairs = formBody.Split('&');\n                foreach (string pair in pairs) {\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\n                    if (keyValue.Length == 2 && keyValue[0] == \"code_challenge_method\") {\n                        return keyValue[1]; // Keep encoded\n                    }\n                }\n            }\n            // Fallback to query string (GET)\n            return (string)context.Request.Url.Query.GetValueOrDefault(\"code_challenge_method\", \"\");\n        }\" />\n      \n         <set-variable name=\"access_denied_template\" value=\"@{\n            return @\"<!DOCTYPE html>\n<html lang='en'>\n<head>    <meta charset='UTF-8'>\n    <meta name='viewport' content='width=device-width, initial-scale=1.0'>\n    <title>Access Denied</title>\n    <style>\n__COMMON_STYLES__\n        .error-details {\n            background-color: #f8f9fa;\n            border: 1px solid #dee2e6;\n            border-radius: 8px;\n            padding: 20px;\n            margin: 20px 0;\n            font-family: 'Courier New', Consolas, monospace;\n            font-size: 14px;\n            line-height: 1.6;\n            white-space: pre-wrap;\n            overflow-x: auto;\n        }\n        \n        .error-title {\n            color: #dc3545;\n            font-weight: bold;\n            margin-bottom: 10px;\n        }\n        \n        .debug-section {\n            margin-top: 15px;\n            padding-top: 15px;\n            border-top: 1px solid #dee2e6;\n        }\n        \n        .debug-label {\n            font-weight: bold;\n            color: #495057;\n        }\n    </style>\n</head>\n<body>\n    <div class='consent-container'>\n        <h1 class='denial-heading'>Access Denied</h1>\n        <div class='error-details'>\n            <div class='error-title'>Error Details:</div>\n            __DENIAL_MESSAGE__\n        </div>\n        <p>The application will not be able to access your data.</p>\n        <p>You can close this window safely.</p>\n    </div>\n</body>\n</html>\";\n        }\" />\n        \n        <!-- Reusable function to generate 403 error response -->\n        <set-variable name=\"generate_403_response\" value=\"@{\n            string errorTemplate = context.Variables.GetValueOrDefault<string>(\"access_denied_template\");\n            string commonStyles = context.Variables.GetValueOrDefault<string>(\"common_styles\");\n            string message = \"Access denied.\";\n            \n            // Replace placeholders with actual content\n            errorTemplate = errorTemplate.Replace(\"__COMMON_STYLES__\", commonStyles);\n            errorTemplate = errorTemplate.Replace(\"__DENIAL_MESSAGE__\", message);\n            \n            return errorTemplate;\n        }\" />\n            <!-- Error page template -->\n        <set-variable name=\"client_not_found_template\" value=\"@{\n            return @\"<!DOCTYPE html>\n<html lang='en'>\n<head>    \n    <meta charset='UTF-8'>\n    <meta name='viewport' content='width=device-width, initial-scale=1.0'>\n    <title>Client Not Found</title>\n    <style>\n__COMMON_STYLES__\n    </style>\n</head>\n<body>\n    <div class='consent-container'>        \n        <h1 class='denial-heading'>Client Not Found</h1>\n        <p>The client registration for the specified client was not found.</p>\n        <div class='client-info'>\n            <p><strong>Client ID:</strong> <code>__CLIENT_ID_DISPLAY__</code></p>\n            <p><strong>Redirect URI:</strong> <code>__REDIRECT_URI__</code></p>\n        </div>\n        <p>Please ensure that you are using a properly registered client application.</p>\n        <p>You can close this window safely.</p>\n    </div>\n</body>\n</html>\";\n        }\" />\n        <!-- Normalize redirect URI by handling potential double-encoding -->\n        <set-variable name=\"normalized_redirect_uri\" value=\"@{\n            string redirectUri = context.Variables.GetValueOrDefault<string>(\"redirect_uri\", \"\");\n            \n            if (string.IsNullOrEmpty(redirectUri)) {\n                return \"\";\n            }\n            \n            try {\n                string firstDecode = System.Net.WebUtility.UrlDecode(redirectUri);\n                \n                // Check if still encoded (contains % followed by hex digits)\n                if (firstDecode.Contains(\"%\") && System.Text.RegularExpressions.Regex.IsMatch(firstDecode, @\"%[0-9A-Fa-f]{2}\")) {\n                    // Double-encoded, decode again\n                    string secondDecode = System.Net.WebUtility.UrlDecode(firstDecode);\n                    return secondDecode;\n                } else {\n                    // Single encoding, first decode is sufficient\n                    return firstDecode;\n                }\n            } catch (Exception) {\n                // If decoding fails, return original value\n                return redirectUri;\n            }\n        }\" />\n        \n        <!-- Cache client information lookup -->\n        <cache-lookup-value key=\"@($\"ClientInfo-{context.Variables.GetValueOrDefault<string>(\"client_id\")}\")\" variable-name=\"clientInfoJson\" />\n        \n        <!-- Get OAuth scopes from configuration -->\n        <set-variable name=\"oauth_scopes\" value=\"{{OAuthScopes}}\" />\n        \n        <!-- Generate CSRF token for form protection (GET requests only) -->\n        <set-variable name=\"csrf_token\" value=\"@{\n            // Only generate tokens for GET requests (showing consent form)\n            // POST requests validate existing tokens, not generate new ones\n            if (context.Request.Method != \"GET\") {\n                return \"\";\n            }\n            \n            // Generate random CSRF token using Guid and timestamp\n            string guidPart = Guid.NewGuid().ToString(\"N\");\n            string timestampPart = DateTime.UtcNow.Ticks.ToString();\n            string combinedString = guidPart + timestampPart;\n            \n            // Create URL-safe token by encoding combined string\n            string token = System.Convert.ToBase64String(\n                System.Text.Encoding.UTF8.GetBytes(combinedString)\n            ).Replace(\"+\", \"-\").Replace(\"/\", \"_\").Replace(\"=\", \"\").Substring(0, 32);\n            \n            return token;\n        }\" />\n        \n        <!-- Cache CSRF token for validation (GET requests only) -->\n        <choose>\n            <when condition=\"@(context.Request.Method == \"GET\" && !string.IsNullOrEmpty(context.Variables.GetValueOrDefault<string>(\"csrf_token\")))\">\n                <cache-store-value key=\"@($\"CSRF-{context.Variables.GetValueOrDefault<string>(\"csrf_token\")}\")\" \n                                  value=\"@{\n                                      string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                                      string normalizedRedirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                                      string timestamp = DateTime.UtcNow.ToString(\"yyyy-MM-ddTHH:mm:ssZ\");\n                                      string tokenData = $\"{clientId}:{normalizedRedirectUri}:{timestamp}\";\n                                      \n                                      // Add debugging metadata\n                                      string debugInfo = $\"CACHED_AT:{DateTime.UtcNow:yyyy-MM-ddTHH:mm:ss.fffZ}\";\n                                      return $\"{tokenData}|{debugInfo}\";\n                                  }\" \n                                  duration=\"900\" />\n                <!-- Track token caching for debugging -->\n                <set-variable name=\"csrf_token_cached\" value=\"true\" />\n            </when>\n            <otherwise>\n                <set-variable name=\"csrf_token_cached\" value=\"false\" />\n            </otherwise>\n        </choose>\n          <!-- Validate client registration -->\n        <set-variable name=\"is_client_registered\" value=\"@{\n            try {\n                string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                \n                if (string.IsNullOrEmpty(clientId)) {\n                    return false;\n                }\n                \n                // Get client info from cache lookup\n                string clientInfoJson = context.Variables.GetValueOrDefault<string>(\"clientInfoJson\");\n                  if (string.IsNullOrEmpty(clientInfoJson)) {\n                    return false;\n                }\n                \n                // Parse client configuration\n                JObject clientInfo = JObject.Parse(clientInfoJson);\n                JArray redirectUris = clientInfo[\"redirect_uris\"]?.ToObject<JArray>();\n                \n                // Validate redirect URI is registered\n                if (redirectUris != null) {\n                    foreach (var uri in redirectUris) {\n                        // Normalize registered URI for comparison\n                        string registeredUri = System.Net.WebUtility.UrlDecode(uri.ToString());\n                        if (registeredUri == redirectUri) {\n                            return true;\n                        }\n                    }\n                }\n                \n                return false;\n            }\n            catch (Exception ex) {\n                return false;\n            }\n        }\" />\n        \n        <!-- Extract client name from cache -->\n        <set-variable name=\"client_name\" value=\"@{\n            try {\n                string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                \n                if (string.IsNullOrEmpty(clientId)) {\n                    return \"Unknown Application\";\n                }\n                \n                // Get client info from cache lookup\n                string clientInfoJson = context.Variables.GetValueOrDefault<string>(\"clientInfoJson\");\n                \n                if (string.IsNullOrEmpty(clientInfoJson)) {\n                    return clientId;\n                }\n                \n                // Parse client configuration\n                JObject clientInfo = JObject.Parse(clientInfoJson);\n                string clientName = clientInfo[\"client_name\"]?.ToString();\n                \n                return string.IsNullOrEmpty(clientName) ? clientId : clientName;\n            }\n            catch (Exception ex) {\n                return context.Variables.GetValueOrDefault<string>(\"client_id\", \"Unknown Application\");\n            }\n        }\" />\n        \n        <!-- Extract client URI from cache -->\n        <set-variable name=\"client_uri\" value=\"@{\n            try {\n                // Get client info from cache lookup\n                string clientInfoJson = context.Variables.GetValueOrDefault<string>(\"clientInfoJson\");\n                \n                if (string.IsNullOrEmpty(clientInfoJson)) {\n                    return \"N/A\";\n                }\n                \n                // Parse client configuration\n                JObject clientInfo = JObject.Parse(clientInfoJson);\n                string clientUri = clientInfo[\"client_uri\"]?.ToString();\n                \n                return string.IsNullOrEmpty(clientUri) ? \"N/A\" : clientUri;\n            }\n            catch (Exception ex) {\n                return \"N/A\";\n            }\n        }\" />\n        \n        <!-- Define common styles for consent and error pages -->\n        <set-variable name=\"common_styles\" value=\"@{\n            return @\"        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            max-width: 100%;\n            margin: 0;            padding: 0;\n            line-height: 1.6;\n            min-height: 100vh;\n            background: linear-gradient(135deg, #1f1f1f, #333344, #3f4066); /* Modern dark gradient */\n            color: #333333;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n        }.container, .consent-container {\n            background-color: #ffffff;\n            border-radius: 4px; /* Adding some subtle rounding */\n            padding: 30px;\n            max-width: 600px;            width: 90%;\n            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);\n            border: none;\n        }\n        \n        h1 {\n            margin-bottom: 20px;\n            border-bottom: 1px solid #EDEBE9;\n            padding-bottom: 10px;\n            font-weight: 500;\n        }\n        .consent-heading {\n            color: #0078D4; /* Microsoft Blue */\n        }\n        .denial-heading {\n            color: #D83B01; /* Microsoft Attention color */\n        }\n        \n        p {\n            margin: 15px 0;\n            line-height: 1.7;\n            color: #323130; /* Microsoft text color */\n        }          .client-info {\n            background-color: #F5F5F5; /* Light gray background for info boxes */\n            padding: 15px;\n            border-radius: 4px; /* Adding some subtle rounding */\n            margin: 15px 0;\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);\n            border: 1px solid #EDEBE9;\n        }\n          .client-info p {\n            display: flex;\n            align-items: flex-start;\n            margin: 8px 0;\n        }\n        \n        .client-info strong {\n            min-width: 160px;\n            flex-shrink: 0;\n            text-align: left;\n            padding-right: 15px;\n            color: #0078D4; /* Microsoft Blue */\n        }\n          .client-info code {\n            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;\n            background-color: rgba(240, 240, 250, 0.5);\n            padding: 2px 6px;\n            border-radius: 4px; /* Adding some subtle rounding */\n            color: #0078D4; /* Microsoft Blue */\n            word-break: break-all;\n        }\n          .btn {\n            display: inline-block;\n            padding: 8px 16px;\n            margin: 10px 0;\n            border-radius: 4px; /* Adding some subtle rounding */\n            text-decoration: none;\n            font-weight: 600;\n            cursor: pointer;\n            transition: all 0.2s ease;\n        }\n        \n        .btn-primary {\n            background-color: #0078D4; /* Microsoft Blue */\n            color: white;\n            border: none;\n        }\n        .btn-primary:hover {\n            background-color: #106EBE; /* Microsoft Blue hover */\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);\n        }\n        \n        .btn-secondary {\n            background-color: #D83B01; /* Microsoft Red */\n            color: white; /* White text */\n            border: none;\n        }\n        .btn-secondary:hover {\n            background-color: #A80000; /* Darker red on hover */\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);\n        }\n          .buttons {\n            margin-top: 20px;\n            display: flex;\n            gap: 10px;\n            justify-content: flex-start;\n        }\n        \n        a {\n            color: #0078D4; /* Microsoft Blue */\n            text-decoration: none;\n            font-weight: 600;\n        }\n        a:hover {\n            text-decoration: underline;\n        }\n        strong {\n            color: #0078D4; /* Microsoft Blue */\n            font-weight: 600;\n        }          .error-message {\n            background-color: #FDE7E9; /* Light red background */\n            padding: 15px;\n            margin: 15px 0;\n            border-radius: 4px; /* Adding some subtle rounding */\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);\n            border-left: 3px solid #D83B01; /* Microsoft Attention color */\n        }\n        \n        .error-message p {\n            margin: 8px 0;\n        }\n        \n        .error-message p:first-child {\n            font-weight: 500;\n            color: #D83B01; /* Microsoft Attention color */\n        }\";\n        }\" />\n        \n        <!-- Consent page HTML template -->\n        <set-variable name=\"consent_page_template\" value=\"@{\n            return @\"<!DOCTYPE html>\n<html lang='en'>\n<head>    <meta charset='UTF-8'>\n    <meta name='viewport' content='width=device-width, initial-scale=1.0'>\n    <title>Application Consent</title>\n    <style>\n__COMMON_STYLES__    /* Additional styles for scopes list */\n    .scopes-list {\n        margin: 0;\n        padding-left: 0;\n    }\n    .scopes-list li {\n        list-style-type: none;\n        padding: 4px 0;\n        display: flex;\n    }\n    </style>\n</head>\n<body>\n    <div class='consent-container'>\n        <h1 class='consent-heading'>Application Access Request</h1>\n\n        <p>The following application is requesting access to <strong>{{MCPServerName}}</strong>, which might include access to everything <strong>{{MCPServerName}}</strong> has been and will be granted access to.</p>\n        \n        <div class='client-info'>\n            <p><strong>Application Name:</strong> <code>__CLIENT_NAME__</code></p>\n            <p><strong>Application Website:</strong> <code>__CLIENT_URI__</code></p>\n            <p><strong>Application ID:</strong> <code>__CLIENT_ID_DISPLAY__</code></p>\n            <p><strong>Redirect URI:</strong> <code>__REDIRECT_URI__</code></p>\n        </div>        \n        <p>The application will have access to the following scopes, used by <strong>{{MCPServerName}}</strong>:</p>\n        <div class='client-info'>\n            <ul class='scopes-list'>\n                <li>__OAUTH_SCOPES__</li>\n            </ul>\n        </div>        <div class='buttons'>\n            <form method='post' action='__CONSENT_ACTION_URL__' style='display: inline-block;'>\n                <input type='hidden' name='client_id' value='__CLIENT_ID_FORM__'>\n                <input type='hidden' name='redirect_uri' value='__REDIRECT_URI__'>\n                <input type='hidden' name='state' value='__STATE__'>\n                <input type='hidden' name='code_challenge' value='__CODE_CHALLENGE__'>\n                <input type='hidden' name='code_challenge_method' value='__CODE_CHALLENGE_METHOD__'>\n                <input type='hidden' name='csrf_token' value='__CSRF_TOKEN__'>\n                <input type='hidden' name='consent_action' value='allow'>\n                <button type='submit' class='btn btn-primary'>Allow</button>\n            </form>\n            \n            <form method='post' action='__CONSENT_ACTION_URL__' style='display: inline-block;'>                <input type='hidden' name='client_id' value='__CLIENT_ID_FORM__'>\n                <input type='hidden' name='redirect_uri' value='__REDIRECT_URI__'>\n                <input type='hidden' name='state' value='__STATE__'>\n                <input type='hidden' name='code_challenge' value='__CODE_CHALLENGE__'>\n                <input type='hidden' name='code_challenge_method' value='__CODE_CHALLENGE_METHOD__'>\n                <input type='hidden' name='csrf_token' value='__CSRF_TOKEN__'>\n                <input type='hidden' name='consent_action' value='deny'>\n                <button type='submit' class='btn btn-secondary'>Deny</button>\n            </form>\n        </div>\n    </div>\n</body>\n</html>\";\n        }\" />\n\n        <!-- Check for existing client denial cookie -->\n        <set-variable name=\"has_denial_cookie\" value=\"@{\n            try {\n                if (string.IsNullOrEmpty(context.Variables.GetValueOrDefault<string>(\"client_id\", \"\")) || \n                    string.IsNullOrEmpty(context.Variables.GetValueOrDefault<string>(\"redirect_uri\", \"\"))) {\n                    return false;\n                }\n                  \n                string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                // Use normalized redirect URI for consistency\n                string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                \n                // Cookie name for client denials\n                string DENIAL_COOKIE_NAME = \"MCP_DENIED_CLIENTS\";\n                \n                // Check for denial cookie in request\n                var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\n                if (string.IsNullOrEmpty(cookieHeader)) {\n                    return false;\n                }\n                \n                // Parse cookie header for denial cookie\n                string[] cookies = cookieHeader.Split(';');\n                foreach (string cookie in cookies) {\n                    string trimmedCookie = cookie.Trim();\n                    if (trimmedCookie.StartsWith(DENIAL_COOKIE_NAME + \"=\")) {\n                        // Extract cookie value\n                        string cookieValue = trimmedCookie.Substring(DENIAL_COOKIE_NAME.Length + 1);\n                        try {\n                            // Parse base64-encoded JSON array of denied clients\n                            string decodedValue = System.Text.Encoding.UTF8.GetString(\n                                System.Convert.FromBase64String(cookieValue.Split('.')[0]));\n                            JArray deniedClients = JArray.Parse(decodedValue);                            \n                            \n                            // Create client/redirect identifier\n                            // Use normalized redirect URI for consistency\n                            string clientKey = $\"{clientId}:{redirectUri}\";\n                            \n                            foreach (var item in deniedClients) {\n                                string itemString = item.ToString();\n                                \n                                // Direct comparison using normalized URI\n                                if (itemString == clientKey) {\n                                    return true;\n                                }\n                                \n                                // Handle URL-encoded redirect URI in stored cookie\n                                try {\n                                    string storedValue = itemString;\n                                    if (storedValue.Contains(':')) {\n                                        string[] parts = storedValue.Split(new char[] {':'}, 2);\n                                        if (parts.Length == 2) {\n                                            string storedClientId = parts[0];\n                                            // Decode stored redirect URI for comparison\n                                            string storedRedirectUri = System.Net.WebUtility.UrlDecode(parts[1]);\n                                            \n                                            // Compare both decoded forms\n                                            if (storedClientId == clientId && storedRedirectUri == redirectUri) {\n                                                return true;\n                                            }\n                                        }\n                                    }\n                                } catch (Exception ex) {\n                                    // Ignore comparison errors and continue\n                                }\n                            }\n                        } catch (Exception ex) {\n                            // Ignore cookie parsing errors and continue\n                        }\n                    }\n                }\n                \n                return false;\n            } catch (Exception ex) {\n                return false;\n            }\n        }\" />\n        \n        <!-- Check for existing client approval cookie -->\n        <set-variable name=\"has_approval_cookie\" value=\"@{\n            try {\n                if (string.IsNullOrEmpty(context.Variables.GetValueOrDefault<string>(\"client_id\", \"\")) || \n                    string.IsNullOrEmpty(context.Variables.GetValueOrDefault<string>(\"redirect_uri\", \"\"))) {\n                    return false;\n                }\n                  \n                string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                // Use normalized redirect URI for consistency\n                string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                \n                // Cookie name for client approvals\n                string APPROVAL_COOKIE_NAME = \"MCP_APPROVED_CLIENTS\";\n                \n                // Check for approval cookie in request\n                var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\n                if (string.IsNullOrEmpty(cookieHeader)) {\n                    return false;\n                }\n                \n                // Parse cookie header for approval cookie\n                string[] cookies = cookieHeader.Split(';');\n                foreach (string cookie in cookies) {\n                    string trimmedCookie = cookie.Trim();\n                    if (trimmedCookie.StartsWith(APPROVAL_COOKIE_NAME + \"=\")) {\n                        // Extract cookie value\n                        string cookieValue = trimmedCookie.Substring(APPROVAL_COOKIE_NAME.Length + 1);\n                        try {                            \n                            // Parse base64-encoded JSON array of approved clients\n                            string decodedValue = System.Text.Encoding.UTF8.GetString(\n                                System.Convert.FromBase64String(cookieValue.Split('.')[0]));\n                            JArray approvedClients = JArray.Parse(decodedValue);\n                            \n                            // Create client/redirect identifier\n                            // Use normalized redirect URI for consistency\n                            string clientKey = $\"{clientId}:{redirectUri}\";\n                            \n                            foreach (var item in approvedClients) {\n                                string itemString = item.ToString();\n                                \n                                // Direct comparison using normalized URI\n                                if (itemString == clientKey) {\n                                    return true;\n                                }\n                                \n                                // Handle URL-encoded redirect URI in stored cookie\n                                try {\n                                    string storedValue = itemString;\n                                    if (storedValue.Contains(':')) {\n                                        string[] parts = storedValue.Split(new char[] {':'}, 2);\n                                        if (parts.Length == 2) {\n                                            string storedClientId = parts[0];\n                                            // Decode stored redirect URI for comparison\n                                            string storedRedirectUri = System.Net.WebUtility.UrlDecode(parts[1]);\n                                            \n                                            // Compare both decoded forms\n                                            if (storedClientId == clientId && storedRedirectUri == redirectUri) {\n                                                return true;\n                                            }\n                                        }\n                                    }\n                                } catch (Exception ex) {\n                                    // Ignore comparison errors and continue\n                                }\n                            }\n                        } catch (Exception ex) {\n                            // Ignore cookie parsing errors and continue\n                        }\n                    }\n                }\n                \n                return false;\n            } catch (Exception ex) {\n                return false;\n            }\n        }\" />\n        \n        <set-variable name=\"consent_action\" value=\"@{\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\n            \n            if (!string.IsNullOrEmpty(formBody)) {\n                string[] pairs = formBody.Split('&');\n                foreach (string pair in pairs) {\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\n                    if (keyValue.Length == 2 && keyValue[0] == \"consent_action\") {\n                        return System.Net.WebUtility.UrlDecode(keyValue[1]);\n                    }\n                }\n                // Fallback to JSON parsing if form parsing failed\n                return context.Request.Body.As<JObject>(preserveContent: true)[\"consent_action\"]?.ToString() ?? \"\";\n            }\n            return \"\";\n        }\" />\n        \n        <!-- Extract CSRF token from form data -->\n        <set-variable name=\"csrf_token_from_form\" value=\"@{\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\n            \n            if (!string.IsNullOrEmpty(formBody)) {\n                string[] pairs = formBody.Split('&');\n                foreach (string pair in pairs) {\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\n                    if (keyValue.Length == 2 && keyValue[0] == \"csrf_token\") {\n                        return System.Net.WebUtility.UrlDecode(keyValue[1]);\n                    }\n                }\n            }\n            return \"\";\n        }\" />\n        \n        <!-- Validate CSRF token for POST requests -->\n        <set-variable name=\"csrf_valid\" value=\"@{\n            if (context.Request.Method != \"POST\") {\n                return true; // Only validate POST requests\n            }\n            \n            string submittedToken = context.Variables.GetValueOrDefault<string>(\"csrf_token_from_form\", \"\");\n            if (string.IsNullOrEmpty(submittedToken)) {\n                return false;\n            }\n            \n            // Token cache lookup validation happens next\n            string cacheKey = $\"CSRF-{submittedToken}\";\n            \n            return true; // Initial validation passes, detailed validation follows\n        }\" />\n        \n        <!-- Validate Origin/Referer headers for CSRF protection -->\n        <set-variable name=\"origin_referer_valid\" value=\"@{\n            if (context.Request.Method != \"POST\") {\n                return true; // Only validate state-changing operations\n            }\n            \n            // Get the target origin (expected origin)\n            string targetOrigin = \"{{APIMGatewayURL}}\";\n            \n            // Remove protocol and trailing slash for comparison\n            if (targetOrigin.StartsWith(\"https://\")) {\n                targetOrigin = targetOrigin.Substring(8);\n            } else if (targetOrigin.StartsWith(\"http://\")) {\n                targetOrigin = targetOrigin.Substring(7);\n            }\n            if (targetOrigin.EndsWith(\"/\")) {\n                targetOrigin = targetOrigin.TrimEnd('/');\n            }\n            \n            // First check Origin header (preferred)\n            string originHeader = context.Request.Headers.GetValueOrDefault(\"Origin\", \"\");\n            if (!string.IsNullOrEmpty(originHeader)) {\n                try {\n                    Uri originUri = new Uri(originHeader);\n                    string sourceOrigin = originUri.Host;\n                    if (originUri.Port != 80 && originUri.Port != 443) {\n                        sourceOrigin += \":\" + originUri.Port;\n                    }\n                    \n                    if (sourceOrigin.Equals(targetOrigin, StringComparison.OrdinalIgnoreCase)) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                } catch (Exception ex) {\n                    return false;\n                }\n            }\n            \n            // Fallback to Referer header if Origin is not present\n            string refererHeader = context.Request.Headers.GetValueOrDefault(\"Referer\", \"\");\n            if (!string.IsNullOrEmpty(refererHeader)) {\n                try {\n                    Uri refererUri = new Uri(refererHeader);\n                    string sourceOrigin = refererUri.Host;\n                    if (refererUri.Port != 80 && refererUri.Port != 443) {\n                        sourceOrigin += \":\" + refererUri.Port;\n                    }\n                    \n                    if (sourceOrigin.Equals(targetOrigin, StringComparison.OrdinalIgnoreCase)) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                } catch (Exception ex) {\n                    return false;\n                }\n            }\n            \n            // Neither Origin nor Referer header present - this is suspicious for POST requests\n            // OWASP recommends blocking such requests for better security\n            return false; // Block requests without proper origin validation\n        }\" />\n        \n        <!-- Validate Fetch Metadata headers for CSRF protection -->\n        <set-variable name=\"fetch_metadata_valid\" value=\"@{\n            // Check Sec-Fetch-Site header for cross-site request detection\n            string secFetchSite = context.Request.Headers.GetValueOrDefault(\"Sec-Fetch-Site\", \"\");\n            \n            // Allow same-origin, same-site, and direct navigation\n            if (string.IsNullOrEmpty(secFetchSite) || \n                secFetchSite == \"same-origin\" || \n                secFetchSite == \"same-site\" || \n                secFetchSite == \"none\") {\n                return true;\n            }\n            \n            // Block cross-site POST requests\n            if (context.Request.Method == \"POST\" && secFetchSite == \"cross-site\") {\n                return false;\n            }\n            \n            // Allow other values for compatibility\n            return true;\n        }\" />\n        \n        <!-- Lookup CSRF token from cache -->\n        <cache-lookup-value key=\"@($\"CSRF-{context.Variables.GetValueOrDefault<string>(\"csrf_token_from_form\")}\")\" variable-name=\"csrf_token_data\" />\n        \n        <!-- Validate CSRF token details -->\n        <set-variable name=\"csrf_validation_result\" value=\"@{\n            if (context.Request.Method != \"POST\") {\n                return \"valid\"; // No validation needed for GET requests\n            }\n            \n            string submittedToken = context.Variables.GetValueOrDefault<string>(\"csrf_token_from_form\", \"\");\n            if (string.IsNullOrEmpty(submittedToken)) {\n                return \"missing_token\";\n            }\n            \n            string tokenData = context.Variables.GetValueOrDefault<string>(\"csrf_token_data\");\n            if (string.IsNullOrEmpty(tokenData)) {\n                return \"invalid_token\";\n            }\n            \n            try {\n                // Extract token data (before debug info separator)\n                string actualTokenData = tokenData;\n                if (tokenData.Contains(\"|\")) {\n                    actualTokenData = tokenData.Split('|')[0];\n                }\n                \n                // Parse token data: client_id:redirect_uri:timestamp\n                // Since both redirect_uri and timestamp can contain colons, we need to be very careful\n                // The timestamp format is: YYYY-MM-DDTHH:mm:ssZ\n                // So we look for the last occurrence of a timestamp pattern\n                \n                // Find the last occurrence of a timestamp pattern (YYYY-MM-DDTHH:mm:ssZ)\n                var timestampPattern = @\":\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$\";\n                var timestampMatch = System.Text.RegularExpressions.Regex.Match(actualTokenData, timestampPattern);\n                \n                if (!timestampMatch.Success) {\n                    return \"malformed_token\";\n                }\n                \n                // Extract the timestamp (without the leading colon)\n                string timestampStr = timestampMatch.Value.Substring(1);\n                \n                // Extract everything before the timestamp match as the client_id:redirect_uri part\n                string clientAndRedirect = actualTokenData.Substring(0, timestampMatch.Index);\n                \n                // Split client_id:redirect_uri on the first colon only\n                int firstColonIndex = clientAndRedirect.IndexOf(':');\n                if (firstColonIndex == -1) {\n                    return \"malformed_token\";\n                }\n                \n                string tokenClientId = clientAndRedirect.Substring(0, firstColonIndex);\n                string tokenRedirectUri = clientAndRedirect.Substring(firstColonIndex + 1);\n                \n                // Validate client_id and redirect_uri match using constant-time comparison\n                string currentClientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                string currentRedirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                \n                // Constant-time string comparison for client_id to prevent timing attacks\n                bool clientIdMatches = true;\n                if (tokenClientId == null || currentClientId == null) {\n                    clientIdMatches = (tokenClientId == currentClientId);\n                } else if (tokenClientId.Length != currentClientId.Length) {\n                    clientIdMatches = false;\n                } else {\n                    int result = 0;\n                    for (int i = 0; i < tokenClientId.Length; i++) {\n                        result |= tokenClientId[i] ^ currentClientId[i];\n                    }\n                    clientIdMatches = (result == 0);\n                }\n                \n                if (!clientIdMatches) {\n                    return \"client_mismatch\";\n                }\n                \n                // Constant-time string comparison for redirect_uri to prevent timing attacks\n                bool redirectUriMatches = true;\n                if (tokenRedirectUri == null || currentRedirectUri == null) {\n                    redirectUriMatches = (tokenRedirectUri == currentRedirectUri);\n                } else if (tokenRedirectUri.Length != currentRedirectUri.Length) {\n                    redirectUriMatches = false;\n                } else {\n                    int result = 0;\n                    for (int i = 0; i < tokenRedirectUri.Length; i++) {\n                        result |= tokenRedirectUri[i] ^ currentRedirectUri[i];\n                    }\n                    redirectUriMatches = (result == 0);\n                }\n                \n                if (!redirectUriMatches) {\n                    return \"redirect_mismatch\";\n                }\n                \n                // Validate timestamp (token should not be older than 15 minutes)\n                DateTime tokenTime;\n                try {\n                    tokenTime = DateTime.Parse(timestampStr);\n                } catch (Exception) {\n                    return \"invalid_timestamp\";\n                }\n                \n                TimeSpan age = DateTime.UtcNow - tokenTime;\n                if (age.TotalMinutes > 15) {\n                    return \"expired_token\";\n                }\n                \n                return \"valid\";\n                \n            } catch (Exception ex) {\n                return \"validation_error\";\n            }\n        }\" />\n        \n        <!-- If this is a form submission, process the consent choice -->\n        <choose>\n            <when condition=\"@(context.Request.Method == \"POST\")\">\n                <!-- Validate Origin/Referer headers -->\n                <choose>\n                    <when condition=\"@(!context.Variables.GetValueOrDefault<bool>(\"origin_referer_valid\"))\">\n                        <!-- Origin/Referer validation failed -->\n                        <return-response>\n                            <set-status code=\"403\" reason=\"Forbidden\" />\n                            <set-header name=\"Content-Type\" exists-action=\"override\">\n                                <value>text/html</value>\n                            </set-header>\n                            <set-header name=\"Cache-Control\" exists-action=\"override\">\n                                <value>no-store, no-cache</value>\n                            </set-header>\n                            <set-header name=\"Pragma\" exists-action=\"override\">\n                                <value>no-cache</value>\n                            </set-header>\n                            <set-body>@(context.Variables.GetValueOrDefault<string>(\"generate_403_response\"))</set-body>\n                        </return-response>\n                    </when>\n                    <otherwise>\n                        <!-- Origin/Referer validation passed -->\n                        <!-- Validate Fetch Metadata headers -->\n                        <choose>\n                            <when condition=\"@(!context.Variables.GetValueOrDefault<bool>(\"fetch_metadata_valid\"))\">\n                                <!-- Fetch metadata validation failed -->\n                                <return-response>\n                                    <set-status code=\"403\" reason=\"Forbidden\" />\n                                    <set-header name=\"Content-Type\" exists-action=\"override\">\n                                        <value>text/html</value>\n                                    </set-header>\n                                    <set-header name=\"Cache-Control\" exists-action=\"override\">\n                                        <value>no-store, no-cache</value>\n                                    </set-header>\n                                    <set-header name=\"Pragma\" exists-action=\"override\">\n                                        <value>no-cache</value>\n                                    </set-header>\n                                    <set-body>@(context.Variables.GetValueOrDefault<string>(\"generate_403_response\"))</set-body>\n                                </return-response>\n                            </when>\n                            <otherwise>\n                                <!-- Fetch metadata validation passed -->\n                                <!-- Validate CSRF token -->\n                                <choose>\n                                    <when condition=\"@(context.Variables.GetValueOrDefault<string>(\"csrf_validation_result\") != \"valid\")\">\n                                        <!-- CSRF validation failed -->\n                                        <return-response>\n                                            <set-status code=\"403\" reason=\"Forbidden\" />\n                                            <set-header name=\"Content-Type\" exists-action=\"override\">\n                                                <value>text/html</value>\n                                            </set-header>\n                                            <set-header name=\"Cache-Control\" exists-action=\"override\">\n                                                <value>no-store, no-cache</value>\n                                            </set-header>\n                                            <set-header name=\"Pragma\" exists-action=\"override\">\n                                                <value>no-cache</value>\n                                            </set-header>\n                                            <set-body>@(context.Variables.GetValueOrDefault<string>(\"generate_403_response\"))</set-body>\n                                        </return-response>\n                                    </when>\n                                    <otherwise>\n                                        <!-- CSRF validation passed -->\n                                        <!-- Delete CSRF token from cache to prevent reuse -->\n                                        <cache-remove-value key=\"@($\"CSRF-{context.Variables.GetValueOrDefault<string>(\"csrf_token_from_form\")}\")\" />\n                                        \n                                        <choose>\n                                            <when condition=\"@(context.Variables.GetValueOrDefault<string>(\"consent_action\") == \"allow\")\">\n                        <!-- Process consent approval -->\n                        <set-variable name=\"response_status_code\" value=\"302\" />\n                        <set-variable name=\"response_redirect_location\" value=\"@{\n                            string baseUrl = \"{{APIMGatewayURL}}\";\n                            \n                            // Use already extracted parameters instead of re-parsing form data\n                            string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                            string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                            string state = context.Variables.GetValueOrDefault<string>(\"state\", \"\");\n                            \n                            // URL encode parameters to prevent injection attacks\n                            string encodedClientId = System.Net.WebUtility.UrlEncode(clientId);\n                            string encodedRedirectUri = System.Net.WebUtility.UrlEncode(redirectUri);\n                            // State is already properly encoded from form submission, don't double-encode\n                            string encodedState = state;\n                            \n                            // Add PKCE parameters if they exist\n                            string codeChallenge = context.Variables.GetValueOrDefault<string>(\"code_challenge\", \"\");\n                            string codeChallengeMethod = context.Variables.GetValueOrDefault<string>(\"code_challenge_method\", \"\");\n                            \n                            string url = $\"{baseUrl}/authorize?client_id={encodedClientId}&redirect_uri={encodedRedirectUri}&state={encodedState}\";\n                            \n                            if (!string.IsNullOrEmpty(codeChallenge)) {\n                                url += $\"&code_challenge={System.Net.WebUtility.UrlEncode(codeChallenge)}\";\n                            }\n                            \n                            if (!string.IsNullOrEmpty(codeChallengeMethod)) {\n                                url += $\"&code_challenge_method={System.Net.WebUtility.UrlEncode(codeChallengeMethod)}\";\n                            }\n                            \n                            return url;\n                        }\" />\n                          <!-- Calculate approval cookie value -->\n                        <set-variable name=\"approval_cookie\" value=\"@{\n                            string cookieName = \"MCP_APPROVED_CLIENTS\";\n                            \n                            // Use already extracted parameters instead of re-parsing form data\n                            string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                            string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                            \n                            // Create a unique identifier for this client/redirect combination\n                            string clientKey = $\"{clientId}:{redirectUri}\";\n                            \n                            // Check for existing cookie\n                            var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\n                            JArray approvedClients = new JArray();\n                            \n                            if (!string.IsNullOrEmpty(cookieHeader)) {\n                                // Parse cookies to find our approval cookie\n                                string[] cookies = cookieHeader.Split(';');\n                                foreach (string cookie in cookies) {\n                                    string trimmedCookie = cookie.Trim();\n                                    if (trimmedCookie.StartsWith(cookieName + \"=\")) {\n                                        try {\n                                            // Extract and parse the cookie value\n                                            string cookieValue = trimmedCookie.Substring(cookieName.Length + 1);\n                                            // Get the payload part (before the first dot if cookie is signed)\n                                            string payload = cookieValue.Contains('.') ? \n                                                cookieValue.Split('.')[0] : cookieValue;\n                                            string decodedValue = System.Text.Encoding.UTF8.GetString(\n                                                System.Convert.FromBase64String(payload));\n                                            approvedClients = JArray.Parse(decodedValue);\n                                        } catch (Exception) {\n                                            // If parsing fails, we'll just create a new cookie\n                                            approvedClients = new JArray();\n                                        }\n                                        break;\n                                    }\n                                }\n                            }\n                            \n                            // Add the current client if not already in the list\n                            bool clientExists = false;\n                            foreach (var item in approvedClients) {\n                                if (item.ToString() == clientKey) {\n                                    clientExists = true;\n                                    break;\n                                }\n                            }\n                            \n                            if (!clientExists) {\n                                approvedClients.Add(clientKey);\n                            }\n                            \n                            // Base64 encode the client list\n                            string jsonClients = approvedClients.ToString(Newtonsoft.Json.Formatting.None);\n                            string encodedClients = System.Convert.ToBase64String(\n                                System.Text.Encoding.UTF8.GetBytes(jsonClients));\n                            \n                            // Return the full cookie string with appropriate settings\n                            return $\"{cookieName}={encodedClients}; Max-Age=31536000; Path=/; Secure; HttpOnly; SameSite=Lax\";\n                        }\" />\n                        \n                        <!-- Set variables for outbound policy awareness -->\n                        <set-variable name=\"consent_approved\" value=\"true\" />\n                        <set-variable name=\"cookie_name\" value=\"MCP_APPROVED_CLIENTS\" />\n                        \n                        <!-- Return the response with the cookie already set -->\n                        <return-response>\n                            <set-status code=\"302\" reason=\"Found\" />\n                            <set-header name=\"Location\" exists-action=\"override\">\n                                <value>@(context.Variables.GetValueOrDefault<string>(\"response_redirect_location\", \"\"))</value>\n                            </set-header>\n                            <set-header name=\"Set-Cookie\" exists-action=\"append\">\n                                <value>@(context.Variables.GetValueOrDefault<string>(\"approval_cookie\"))</value>\n                            </set-header>\n                        </return-response>\n                    </when>\n                    <when condition=\"@(context.Variables.GetValueOrDefault<string>(\"consent_action\") == \"deny\")\">\n                        <!-- Process consent denial -->\n                        <set-variable name=\"response_status_code\" value=\"403\" />\n                        <set-variable name=\"response_content_type\" value=\"text/html\" />\n                        <set-variable name=\"response_cache_control\" value=\"no-store, no-cache\" />\n                        <set-variable name=\"response_pragma\" value=\"no-cache\" />\n                        \n                        <!-- Calculate the cookie value right here in inbound before returning response -->\n                        <set-variable name=\"denial_cookie\" value=\"@{\n                            string cookieName = \"MCP_DENIED_CLIENTS\";\n                            \n                            // Use already extracted parameters instead of re-parsing form data\n                            string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                            string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                            \n                            // Create a unique identifier for this client/redirect combination\n                            string clientKey = $\"{clientId}:{redirectUri}\";\n                            \n                            // Check for existing cookie\n                            var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\n                            JArray deniedClients = new JArray();\n                            \n                            if (!string.IsNullOrEmpty(cookieHeader)) {\n                                // Parse cookies to find our denial cookie\n                                string[] cookies = cookieHeader.Split(';');\n                                foreach (string cookie in cookies) {\n                                    string trimmedCookie = cookie.Trim();\n                                    if (trimmedCookie.StartsWith(cookieName + \"=\")) {\n                                        try {\n                                            // Extract and parse the cookie value\n                                            string cookieValue = trimmedCookie.Substring(cookieName.Length + 1);\n                                            // Get the payload part (before the first dot if cookie is signed)\n                                            string payload = cookieValue.Contains('.') ? \n                                                cookieValue.Split('.')[0] : cookieValue;\n                                            string decodedValue = System.Text.Encoding.UTF8.GetString(\n                                                System.Convert.FromBase64String(payload));\n                                            deniedClients = JArray.Parse(decodedValue);\n                                        } catch (Exception) {\n                                            // If parsing fails, we'll just create a new cookie\n                                            deniedClients = new JArray();\n                                        }\n                                        break;\n                                    }\n                                }\n                            }\n                            \n                            // Add the current client if not already in the list\n                            bool clientExists = false;\n                            foreach (var item in deniedClients) {\n                                if (item.ToString() == clientKey) {\n                                    clientExists = true;\n                                    break;\n                                }\n                            }\n                            \n                            if (!clientExists) {\n                                deniedClients.Add(clientKey);\n                            }\n                            \n                            // Base64 encode the client list\n                            string jsonClients = deniedClients.ToString(Newtonsoft.Json.Formatting.None);\n                            string encodedClients = System.Convert.ToBase64String(\n                                System.Text.Encoding.UTF8.GetBytes(jsonClients));\n                            \n                            // Return the full cookie string with appropriate settings\n                            return $\"{cookieName}={encodedClients}; Max-Age=31536000; Path=/; Secure; HttpOnly; SameSite=Lax\";\n                        }\" />                        <!-- Store the HTML content for the access denied page -->\n                        <set-variable name=\"response_body\" value=\"@{\n                            string denialTemplate = context.Variables.GetValueOrDefault<string>(\"access_denied_template\");\n                            string commonStyles = context.Variables.GetValueOrDefault<string>(\"common_styles\");\n                            \n                            // Replace placeholders with actual content\n                            denialTemplate = denialTemplate.Replace(\"__COMMON_STYLES__\", commonStyles);\n                            denialTemplate = denialTemplate.Replace(\"__DENIAL_MESSAGE__\", \n                                \"You have denied authorization for this application against the MCP server.\");\n                            \n                            return denialTemplate;\n                        }\" />\n                        \n                        <!-- Set variables for outbound policy awareness -->\n                        <set-variable name=\"consent_denied\" value=\"true\" />\n                        <set-variable name=\"cookie_name\" value=\"MCP_DENIED_CLIENTS\" />\n                        \n                        <!-- Return the response with the cookie already set -->\n                        <return-response>\n                            <set-status code=\"403\" reason=\"Forbidden\" />\n                            <set-header name=\"Content-Type\" exists-action=\"override\">\n                                <value>text/html</value>\n                            </set-header>\n                            <set-header name=\"Cache-Control\" exists-action=\"override\">\n                                <value>no-store, no-cache</value>\n                            </set-header>\n                            <set-header name=\"Pragma\" exists-action=\"override\">\n                                <value>no-cache</value>\n                            </set-header>\n                            <set-header name=\"Set-Cookie\" exists-action=\"append\">\n                                <value>@(context.Variables.GetValueOrDefault<string>(\"denial_cookie\"))</value>\n                            </set-header>\n                            <set-body>@(context.Variables.GetValueOrDefault<string>(\"response_body\", \"\"))</set-body>\n                        </return-response>\n                    </when>\n                    <otherwise>\n                        <!-- Invalid consent action - return error -->\n                        <return-response>\n                            <set-status code=\"403\" reason=\"Forbidden\" />\n                            <set-header name=\"Content-Type\" exists-action=\"override\">\n                                <value>text/html</value>\n                            </set-header>\n                            <!-- Explicitly disable any redirects -->\n                            <set-header name=\"Cache-Control\" exists-action=\"override\">\n                                <value>no-store, no-cache</value>\n                            </set-header>\n                            <set-header name=\"Pragma\" exists-action=\"override\">\n                                <value>no-cache</value>\n                            </set-header>\n                            <set-body>@{\n                                string denialTemplate = context.Variables.GetValueOrDefault<string>(\"access_denied_template\");\n                                string commonStyles = context.Variables.GetValueOrDefault<string>(\"common_styles\");\n                                string consentAction = context.Variables.GetValueOrDefault<string>(\"consent_action\", \"\");\n                                \n                                string detailedMessage = $\"Invalid consent action '{consentAction}' received. Expected 'allow' or 'deny'. This may indicate a form tampering attempt or a browser compatibility issue.\";\n                                \n                                // Replace placeholders with actual content\n                                denialTemplate = denialTemplate.Replace(\"__COMMON_STYLES__\", commonStyles);\n                                denialTemplate = denialTemplate.Replace(\"__DENIAL_MESSAGE__\", detailedMessage);\n                                \n                                return denialTemplate;\n                            }</set-body>\n                        </return-response>\n                                            </otherwise>\n                                        </choose>\n                                    </otherwise>\n                                </choose>\n                            </otherwise>\n                        </choose>\n                    </otherwise>\n                </choose>\n            </when>\n            <!-- For GET requests, check for cookies first, then display consent page if no cookie found -->\n            <otherwise>\n                <choose>\n                    <!-- If there's an approval cookie, skip consent and redirect to authorization endpoint -->\n                    <when condition=\"@(context.Variables.GetValueOrDefault<bool>(\"has_approval_cookie\"))\">\n                        <!-- Set redirect location to authorization endpoint -->\n                        <set-variable name=\"response_redirect_location\" value=\"@{\n                            string baseUrl = \"{{APIMGatewayURL}}\";\n                            string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                            string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                            string state = context.Variables.GetValueOrDefault<string>(\"state\", \"\");\n                            \n                            // URL encode parameters to prevent injection attacks\n                            string encodedClientId = System.Net.WebUtility.UrlEncode(clientId);\n                            string encodedRedirectUri = System.Net.WebUtility.UrlEncode(redirectUri);\n                            // State is already properly encoded, don't double-encode\n                            string encodedState = state;\n                            \n                            // Add PKCE parameters if they exist\n                            string codeChallenge = context.Variables.GetValueOrDefault<string>(\"code_challenge\", \"\");\n                            string codeChallengeMethod = context.Variables.GetValueOrDefault<string>(\"code_challenge_method\", \"\");\n                            \n                            string url = $\"{baseUrl}/authorize?client_id={encodedClientId}&redirect_uri={encodedRedirectUri}&state={encodedState}\";\n                            \n                            if (!string.IsNullOrEmpty(codeChallenge)) {\n                                url += $\"&code_challenge={System.Net.WebUtility.UrlEncode(codeChallenge)}\";\n                            }\n                            \n                            if (!string.IsNullOrEmpty(codeChallengeMethod)) {\n                                url += $\"&code_challenge_method={System.Net.WebUtility.UrlEncode(codeChallengeMethod)}\";\n                            }\n                            \n                            return url;\n                        }\" />\n                        \n                        <!-- Redirect to authorization endpoint -->\n                        <return-response>\n                            <set-status code=\"302\" reason=\"Found\" />\n                            <set-header name=\"Location\" exists-action=\"override\">\n                                <value>@(context.Variables.GetValueOrDefault<string>(\"response_redirect_location\", \"\"))</value>\n                            </set-header>\n                        </return-response>\n                    </when>\n                    \n                    <!-- If there's a denial cookie, return access denied page immediately -->\n                    <when condition=\"@(context.Variables.GetValueOrDefault<bool>(\"has_denial_cookie\"))\">\n                        <return-response>\n                            <set-status code=\"403\" reason=\"Forbidden\" />\n                            <set-header name=\"Content-Type\" exists-action=\"override\">\n                                <value>text/html</value>\n                            </set-header>\n                            <!-- Explicitly disable any redirects -->\n                            <set-header name=\"Cache-Control\" exists-action=\"override\">\n                                <value>no-store, no-cache</value>\n                            </set-header>\n                            <set-header name=\"Pragma\" exists-action=\"override\">\n                                <value>no-cache</value>\n                            </set-header>\n                            <set-body>@{\n                                string denialTemplate = context.Variables.GetValueOrDefault<string>(\"access_denied_template\");\n                                string commonStyles = context.Variables.GetValueOrDefault<string>(\"common_styles\");\n                                \n                                // Replace placeholders with actual content\n                                denialTemplate = denialTemplate.Replace(\"__COMMON_STYLES__\", commonStyles);\n                                denialTemplate = denialTemplate.Replace(\"__DENIAL_MESSAGE__\", \n                                    \"You have previously denied access to this application.\");\n                                \n                                return denialTemplate;\n                            }</set-body>\n                        </return-response>\n                    </when>\n                      <!-- If no cookies found, show the consent screen -->\n                    <otherwise>\n                        <!-- Check if client is registered first -->\n                        <choose>\n                            <when condition=\"@(!context.Variables.GetValueOrDefault<bool>(\"is_client_registered\"))\">\n                                <!-- Client is not registered, show error page -->\n                                <return-response>\n                                    <set-status code=\"403\" reason=\"Forbidden\" />\n                                    <set-header name=\"Content-Type\" exists-action=\"override\">\n                                        <value>text/html</value>\n                                    </set-header>\n                                    <set-header name=\"Cache-Control\" exists-action=\"override\">\n                                        <value>no-store, no-cache</value>\n                                    </set-header>\n                                    <set-header name=\"Pragma\" exists-action=\"override\">\n                                        <value>no-cache</value>\n                                    </set-header>\n                                    <set-body>@{\n                                        string template = context.Variables.GetValueOrDefault<string>(\"client_not_found_template\");\n                                        string commonStyles = context.Variables.GetValueOrDefault<string>(\"common_styles\");\n                                        string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                                        string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                                        \n                                        // Replace placeholders with HTML-encoded content to prevent XSS\n                                        template = template.Replace(\"__COMMON_STYLES__\", commonStyles);\n                                        template = template.Replace(\"__CLIENT_ID_DISPLAY__\", System.Net.WebUtility.HtmlEncode(clientId));\n                                        template = template.Replace(\"__REDIRECT_URI__\", System.Net.WebUtility.HtmlEncode(redirectUri));\n                                        \n                                        return template;\n                                    }</set-body>\n                                </return-response>\n                            </when>\n                            <otherwise>                                <!-- Client is registered, get client name from the cache -->\n                                <!-- Build consent page using the standardized template -->\n                                <set-variable name=\"consent_page\" value=\"@{\n                                    string template = context.Variables.GetValueOrDefault<string>(\"consent_page_template\");\n                                    string commonStyles = context.Variables.GetValueOrDefault<string>(\"common_styles\");\n                                    \n                                    // Use the service URL from APIM configuration\n                                    string basePath = \"{{APIMGatewayURL}}\";\n                                    \n                                    string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                                    string clientName = context.Variables.GetValueOrDefault<string>(\"client_name\", \"Unknown Application\");\n                                    string clientUri = context.Variables.GetValueOrDefault<string>(\"client_uri\", \"N/A\");\n                                    string oauthScopes = context.Variables.GetValueOrDefault<string>(\"oauth_scopes\", \"\");\n                                    \n                                    // Get the normalized (human-readable) redirect URI for display\n                                    string normalizedRedirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                                    \n                                    // Use the normalized redirect URI for form submission to ensure consistency\n                                    string formRedirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                                    string htmlEncodedFormUri = System.Net.WebUtility.HtmlEncode(formRedirectUri);\n                                    \n                                    string state = context.Variables.GetValueOrDefault<string>(\"state\", \"\");\n                                    string csrfToken = context.Variables.GetValueOrDefault<string>(\"csrf_token\", \"\");\n                                    \n                                    // Create a temporary placeholder for the form fields\n                                    string FORM_FIELD_PLACEHOLDER = \"___ENCODED_REDIRECT_URI___\";\n                                    \n                                    // Replace the styles first\n                                    template = template.Replace(\"__COMMON_STYLES__\", commonStyles);\n                                    \n                                    // First, create a temporary placeholder for the form fields\n                                    template = template.Replace(\"value='__REDIRECT_URI__'\", \"value='\" + FORM_FIELD_PLACEHOLDER + \"'\");\n                                      \n                                    // Replace template placeholders with properly encoded values\n                                    template = template.Replace(\"__CLIENT_NAME__\", System.Net.WebUtility.HtmlEncode(clientName));\n                                    template = template.Replace(\"__CLIENT_URI__\", System.Net.WebUtility.HtmlEncode(clientUri));\n                                    // For display purposes, use HtmlEncode for safety\n                                    template = template.Replace(\"__CLIENT_ID_DISPLAY__\", System.Net.WebUtility.HtmlEncode(clientId));\n                                    template = template.Replace(\"__REDIRECT_URI__\", System.Net.WebUtility.HtmlEncode(normalizedRedirectUri));\n                                    // For form field values, use HtmlEncode for XSS protection\n                                    template = template.Replace(\"__CLIENT_ID_FORM__\", System.Net.WebUtility.HtmlEncode(clientId));\n                                    // State needs to be URL-decoded first since it comes URL-encoded from query, then HTML-encoded for form safety\n                                    string decodedState = System.Net.WebUtility.UrlDecode(state);\n                                    template = template.Replace(\"__STATE__\", System.Net.WebUtility.HtmlEncode(decodedState));\n                                    template = template.Replace(\"__CODE_CHALLENGE__\", System.Net.WebUtility.HtmlEncode(context.Variables.GetValueOrDefault<string>(\"code_challenge\", \"\")));\n                                    template = template.Replace(\"__CODE_CHALLENGE_METHOD__\", System.Net.WebUtility.HtmlEncode(context.Variables.GetValueOrDefault<string>(\"code_challenge_method\", \"\")));\n                                    template = template.Replace(\"__CSRF_TOKEN__\", System.Net.WebUtility.HtmlEncode(csrfToken));\n                                    template = template.Replace(\"__CONSENT_ACTION_URL__\", basePath + \"/consent\");                                    \n                                    // Handle space-separated OAuth scopes and create individual list items with HTML encoding\n                                    string[] scopeArray = oauthScopes.Split(new char[] {' '}, StringSplitOptions.RemoveEmptyEntries);\n                                    StringBuilder scopeList = new StringBuilder();\n                                    \n                                    foreach (string scope in scopeArray) {\n                                        scopeList.AppendLine($\"<li><code>{System.Net.WebUtility.HtmlEncode(scope)}</code></li>\");\n                                    }\n                                    \n                                    template = template.Replace(\"__OAUTH_SCOPES__\", scopeList.ToString());\n                                    \n                                // Replace form field placeholder with encoded URI\n                                template = template.Replace(FORM_FIELD_PLACEHOLDER, htmlEncodedFormUri);                                    return template;\n                                }\" />\n                                \n                                <!-- Return consent page -->\n                                <return-response>\n                                    <set-status code=\"200\" reason=\"OK\" />\n                                    <set-header name=\"Content-Type\" exists-action=\"override\">\n                                        <value>text/html</value>\n                                    </set-header>\n                                    <!-- Security headers -->\n                                    <set-header name=\"X-Frame-Options\" exists-action=\"override\">\n                                        <value>DENY</value>\n                                    </set-header>\n                                    <set-header name=\"X-Content-Type-Options\" exists-action=\"override\">\n                                        <value>nosniff</value>\n                                    </set-header>\n                                    <set-header name=\"X-XSS-Protection\" exists-action=\"override\">\n                                        <value>1; mode=block</value>\n                                    </set-header>\n                                    <set-header name=\"Referrer-Policy\" exists-action=\"override\">\n                                        <value>strict-origin-when-cross-origin</value>\n                                    </set-header>\n                                    <set-header name=\"Content-Security-Policy\" exists-action=\"override\">\n                                        <value>default-src 'self'; style-src 'unsafe-inline'; script-src 'none'; object-src 'none'; base-uri 'self'; form-action 'self' https:</value>\n                                    </set-header>\n                                    <set-header name=\"Cache-Control\" exists-action=\"override\">\n                                        <value>no-store, no-cache, must-revalidate</value>\n                                    </set-header>\n                                    <set-header name=\"Pragma\" exists-action=\"override\">\n                                        <value>no-cache</value>\n                                    </set-header>\n                                    <set-body>@{\n                                        return context.Variables.GetValueOrDefault<string>(\"consent_page\", \"\");\n                                    }</set-body>\n                                </return-response>\n                            </otherwise>\n                        </choose>\n                    </otherwise>\n                </choose>\n            </otherwise>\n        </choose>\n    </inbound>\n    <backend>\n        <base />\n    </backend>\n    <outbound>\n        <base />\n        <!-- Debug trace for variable verification -->\n        <trace source=\"outbound-debug\" severity=\"information\">\n            <message>@{\n                return $\"Outbound policy: consent_approved={context.Variables.GetValueOrDefault<bool>(\"consent_approved\")}, consent_denied={context.Variables.GetValueOrDefault<bool>(\"consent_denied\")}, cookie_name={context.Variables.GetValueOrDefault<string>(\"cookie_name\")}\";\n            }</message>\n        </trace>\n        \n        <!-- Set cookies based on consent decision -->\n        <choose>\n            <!-- Handle approval cookie -->\n            <when condition=\"@(context.Variables.GetValueOrDefault<bool>(\"consent_approved\"))\">\n                <set-header name=\"Set-Cookie\" exists-action=\"append\">\n                    <value>@{\n                        string cookieName = context.Variables.GetValueOrDefault<string>(\"cookie_name\", \"MCP_APPROVED_CLIENTS\");\n                        string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                        // Use normalized redirect URI for cookies\n                        string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                        \n                        // Create unique client/redirect identifier\n                        string clientKey = $\"{clientId}:{redirectUri}\";\n                        \n                        // Check for existing cookie\n                        var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\n                        JArray approvedClients = new JArray();\n                        \n                        if (!string.IsNullOrEmpty(cookieHeader)) {\n                            // Parse cookies to find approval cookie\n                            string[] cookies = cookieHeader.Split(';');\n                            foreach (string cookie in cookies) {\n                                string trimmedCookie = cookie.Trim();\n                                if (trimmedCookie.StartsWith(cookieName + \"=\")) {\n                                    try {\n                                        // Extract and parse cookie value\n                                        string cookieValue = trimmedCookie.Substring(cookieName.Length + 1);\n                                        // Get payload part (before first dot if signed)\n                                        string payload = cookieValue.Contains('.') ? \n                                            cookieValue.Split('.')[0] : cookieValue;\n                                        string decodedValue = System.Text.Encoding.UTF8.GetString(\n                                            System.Convert.FromBase64String(payload));\n                                        approvedClients = JArray.Parse(decodedValue);\n                                    } catch (Exception) {\n                                        // If parsing fails, create new cookie\n                                        approvedClients = new JArray();\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                        \n                        // Add the current client if not already in the list\n                        bool clientExists = false;\n                        foreach (var item in approvedClients) {\n                            if (item.ToString() == clientKey) {\n                                clientExists = true;\n                                break;\n                            }\n                        }\n                        \n                        if (!clientExists) {\n                            approvedClients.Add(clientKey);\n                        }\n                        \n                        // Base64 encode the client list\n                        string jsonClients = approvedClients.ToString(Newtonsoft.Json.Formatting.None);\n                        string encodedClients = System.Convert.ToBase64String(\n                            System.Text.Encoding.UTF8.GetBytes(jsonClients));\n                        \n                        // Return the cookie with appropriate settings\n                        return $\"{cookieName}={encodedClients}; Max-Age=31536000; Path=/; Secure; HttpOnly; SameSite=Lax\";\n                    }</value>\n                </set-header>\n                \n                <!-- Set response status and redirect for approval -->\n                <set-status code=\"@(context.Variables.GetValueOrDefault<int>(\"response_status_code\", 302))\" reason=\"Found\" />\n                <set-header name=\"Location\" exists-action=\"override\">\n                    <value>@(context.Variables.GetValueOrDefault<string>(\"response_redirect_location\", \"\"))</value>\n                </set-header>\n            </when>\n            \n            <!-- Handle denial cookie -->\n            <when condition=\"@(context.Variables.GetValueOrDefault<bool>(\"consent_denied\"))\">\n                <set-header name=\"Set-Cookie\" exists-action=\"append\">\n                    <value>@{\n                        string cookieName = context.Variables.GetValueOrDefault<string>(\"cookie_name\", \"MCP_DENIED_CLIENTS\");\n                        string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\n                        // Use normalized redirect URI for cookies\n                        string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\n                        \n                        // Create unique client/redirect identifier\n                        string clientKey = $\"{clientId}:{redirectUri}\";\n                        \n                        // Check for existing cookie\n                        var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\n                        JArray deniedClients = new JArray();\n                        \n                        if (!string.IsNullOrEmpty(cookieHeader)) {\n                            // Parse cookies to find denial cookie\n                            string[] cookies = cookieHeader.Split(';');\n                            foreach (string cookie in cookies) {\n                                string trimmedCookie = cookie.Trim();\n                                if (trimmedCookie.StartsWith(cookieName + \"=\")) {\n                                    try {\n                                        // Extract and parse cookie value\n                                        string cookieValue = trimmedCookie.Substring(cookieName.Length + 1);\n                                        // Get payload part (before first dot if signed)\n                                        string payload = cookieValue.Contains('.') ? \n                                            cookieValue.Split('.')[0] : cookieValue;\n                                        string decodedValue = System.Text.Encoding.UTF8.GetString(\n                                            System.Convert.FromBase64String(payload));\n                                        deniedClients = JArray.Parse(decodedValue);\n                                    } catch (Exception) {\n                                        // If parsing fails, create new cookie\n                                        deniedClients = new JArray();\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                        \n                        // Add client if not already in list\n                        bool clientExists = false;\n                        foreach (var item in deniedClients) {\n                            if (item.ToString() == clientKey) {\n                                clientExists = true;\n                                break;\n                            }\n                        }\n                        \n                        if (!clientExists) {\n                            deniedClients.Add(clientKey);\n                        }\n                        \n                        // Base64 encode client list\n                        string jsonClients = deniedClients.ToString(Newtonsoft.Json.Formatting.None);\n                        string encodedClients = System.Convert.ToBase64String(\n                            System.Text.Encoding.UTF8.GetBytes(jsonClients));\n                        \n                        // Return cookie with security settings\n                        return $\"{cookieName}={encodedClients}; Max-Age=31536000; Path=/; Secure; HttpOnly; SameSite=Lax\";\n                    }</value>\n                </set-header>\n            </when>\n        </choose>\n    </outbound>\n    <on-error>\n        <base />\n    </on-error>\n</policies>\n"
          },
          "resources": [
            {
              "type": "Microsoft.ApiManagement/service/namedValues",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', parameters('apimServiceName'), 'EncryptionKey')]",
              "properties": {
                "displayName": "EncryptionKey",
                "value": "[base64(uniqueString(resourceGroup().id, parameters('apimServiceName'), parameters('location'), 'encryption-key'))]",
                "secret": true
              }
            },
            {
              "type": "Microsoft.ApiManagement/service/namedValues",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', parameters('apimServiceName'), 'EncryptionIV')]",
              "properties": {
                "displayName": "EncryptionIV",
                "value": "[base64(uniqueString(resourceGroup().id, parameters('apimServiceName'), parameters('location'), 'encryption-iv'))]",
                "secret": true
              }
            },
            {
              "type": "Microsoft.ApiManagement/service/namedValues",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', parameters('apimServiceName'), 'EntraIDTenantId')]",
              "properties": {
                "displayName": "EntraIDTenantId",
                "value": "[reference(resourceId('Microsoft.Resources/deployments', 'entraApp'), '2025-04-01').outputs.entraAppTenantId.value]",
                "secret": false
              },
              "dependsOn": [
                "[resourceId('Microsoft.Resources/deployments', 'entraApp')]"
              ]
            },
            {
              "type": "Microsoft.ApiManagement/service/namedValues",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', parameters('apimServiceName'), 'EntraIDClientId')]",
              "properties": {
                "displayName": "EntraIDClientId",
                "value": "[reference(resourceId('Microsoft.Resources/deployments', 'entraApp'), '2025-04-01').outputs.entraAppId.value]",
                "secret": false
              },
              "dependsOn": [
                "[resourceId('Microsoft.Resources/deployments', 'entraApp')]"
              ]
            },
            {
              "type": "Microsoft.ApiManagement/service/namedValues",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', parameters('apimServiceName'), 'EntraIDFicClientId')]",
              "properties": {
                "displayName": "EntraIdFicClientId",
                "value": "[parameters('entraAppUserAssignedIdentityClientId')]",
                "secret": false
              }
            },
            {
              "type": "Microsoft.ApiManagement/service/namedValues",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', parameters('apimServiceName'), 'OAuthCallbackUri')]",
              "properties": {
                "displayName": "OAuthCallbackUri",
                "value": "[format('{0}/oauth-callback', reference(resourceId('Microsoft.ApiManagement/service', parameters('apimServiceName')), '2021-08-01').gatewayUrl)]",
                "secret": false
              }
            },
            {
              "type": "Microsoft.ApiManagement/service/namedValues",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', parameters('apimServiceName'), 'OAuthScopes')]",
              "properties": {
                "displayName": "OAuthScopes",
                "value": "[parameters('oauthScopes')]",
                "secret": false
              }
            },
            {
              "type": "Microsoft.ApiManagement/service/namedValues",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', parameters('apimServiceName'), 'McpClientId')]",
              "properties": {
                "displayName": "McpClientId",
                "value": "[reference(resourceId('Microsoft.Resources/deployments', 'entraApp'), '2025-04-01').outputs.entraAppId.value]",
                "secret": false
              },
              "dependsOn": [
                "[resourceId('Microsoft.Resources/deployments', 'entraApp')]"
              ]
            },
            {
              "type": "Microsoft.ApiManagement/service/namedValues",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', parameters('apimServiceName'), 'APIMGatewayURL')]",
              "properties": {
                "displayName": "APIMGatewayURL",
                "value": "[reference(resourceId('Microsoft.ApiManagement/service', parameters('apimServiceName')), '2021-08-01').gatewayUrl]",
                "secret": false
              }
            },
            {
              "type": "Microsoft.ApiManagement/service/namedValues",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', parameters('apimServiceName'), 'MCPServerName')]",
              "properties": {
                "displayName": "MCPServerName",
                "value": "[parameters('mcpServerName')]",
                "secret": false
              }
            },
            {
              "type": "Microsoft.ApiManagement/service/apis",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', parameters('apimServiceName'), 'oauth')]",
              "properties": {
                "displayName": "OAuth",
                "description": "OAuth 2.0 Authentication API",
                "subscriptionRequired": false,
                "path": "",
                "protocols": [
                  "https"
                ],
                "serviceUrl": "[format('{0}{1}/oauth2/v2.0', environment().authentication.loginEndpoint, reference(resourceId('Microsoft.Resources/deployments', 'entraApp'), '2025-04-01').outputs.entraAppTenantId.value)]"
              },
              "dependsOn": [
                "[resourceId('Microsoft.Resources/deployments', 'entraApp')]"
              ]
            },
            {
              "type": "Microsoft.ApiManagement/service/apis/operations",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}', parameters('apimServiceName'), 'oauth', 'authorize')]",
              "properties": {
                "displayName": "Authorize",
                "method": "GET",
                "urlTemplate": "/authorize",
                "description": "OAuth 2.0 authorization endpoint"
              },
              "dependsOn": [
                "[resourceId('Microsoft.ApiManagement/service/apis', parameters('apimServiceName'), 'oauth')]"
              ]
            },
            {
              "type": "Microsoft.ApiManagement/service/apis/operations/policies",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}/{3}', parameters('apimServiceName'), 'oauth', 'authorize', 'policy')]",
              "properties": {
                "format": "rawxml",
                "value": "[variables('$fxv#0')]"
              },
              "dependsOn": [
                "[resourceId('Microsoft.ApiManagement/service/apis/operations', parameters('apimServiceName'), 'oauth', 'authorize')]"
              ]
            },
            {
              "type": "Microsoft.ApiManagement/service/apis/operations",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}', parameters('apimServiceName'), 'oauth', 'token')]",
              "properties": {
                "displayName": "Token",
                "method": "POST",
                "urlTemplate": "/token",
                "description": "OAuth 2.0 token endpoint"
              },
              "dependsOn": [
                "[resourceId('Microsoft.ApiManagement/service/apis', parameters('apimServiceName'), 'oauth')]"
              ]
            },
            {
              "type": "Microsoft.ApiManagement/service/apis/operations/policies",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}/{3}', parameters('apimServiceName'), 'oauth', 'token', 'policy')]",
              "properties": {
                "format": "rawxml",
                "value": "[variables('$fxv#1')]"
              },
              "dependsOn": [
                "[resourceId('Microsoft.ApiManagement/service/apis/operations', parameters('apimServiceName'), 'oauth', 'token')]"
              ]
            },
            {
              "type": "Microsoft.ApiManagement/service/apis/operations",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}', parameters('apimServiceName'), 'oauth', 'oauth-callback')]",
              "properties": {
                "displayName": "OAuth Callback",
                "method": "GET",
                "urlTemplate": "/oauth-callback",
                "description": "OAuth 2.0 callback endpoint to handle authorization code flow"
              },
              "dependsOn": [
                "[resourceId('Microsoft.ApiManagement/service/apis', parameters('apimServiceName'), 'oauth')]"
              ]
            },
            {
              "type": "Microsoft.ApiManagement/service/apis/operations/policies",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}/{3}', parameters('apimServiceName'), 'oauth', 'oauth-callback', 'policy')]",
              "properties": {
                "format": "rawxml",
                "value": "[variables('$fxv#2')]"
              },
              "dependsOn": [
                "[resourceId('Microsoft.ApiManagement/service/namedValues', parameters('apimServiceName'), 'EncryptionIV')]",
                "[resourceId('Microsoft.ApiManagement/service/namedValues', parameters('apimServiceName'), 'EncryptionKey')]",
                "[resourceId('Microsoft.ApiManagement/service/apis/operations', parameters('apimServiceName'), 'oauth', 'oauth-callback')]"
              ]
            },
            {
              "type": "Microsoft.ApiManagement/service/apis/operations",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}', parameters('apimServiceName'), 'oauth', 'register')]",
              "properties": {
                "displayName": "Register",
                "method": "POST",
                "urlTemplate": "/register",
                "description": "OAuth 2.0 client registration endpoint"
              },
              "dependsOn": [
                "[resourceId('Microsoft.ApiManagement/service/apis', parameters('apimServiceName'), 'oauth')]"
              ]
            },
            {
              "type": "Microsoft.ApiManagement/service/apis/operations/policies",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}/{3}', parameters('apimServiceName'), 'oauth', 'register', 'policy')]",
              "properties": {
                "format": "rawxml",
                "value": "[variables('$fxv#3')]"
              },
              "dependsOn": [
                "[resourceId('Microsoft.ApiManagement/service/apis/operations', parameters('apimServiceName'), 'oauth', 'register')]"
              ]
            },
            {
              "type": "Microsoft.ApiManagement/service/apis/operations",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}', parameters('apimServiceName'), 'oauth', 'register-options')]",
              "properties": {
                "displayName": "Register Options",
                "method": "OPTIONS",
                "urlTemplate": "/register",
                "description": "CORS preflight request handler for register endpoint"
              },
              "dependsOn": [
                "[resourceId('Microsoft.ApiManagement/service/apis', parameters('apimServiceName'), 'oauth')]"
              ]
            },
            {
              "type": "Microsoft.ApiManagement/service/apis/operations/policies",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}/{3}', parameters('apimServiceName'), 'oauth', 'register-options', 'policy')]",
              "properties": {
                "format": "rawxml",
                "value": "[variables('$fxv#4')]"
              },
              "dependsOn": [
                "[resourceId('Microsoft.ApiManagement/service/apis/operations', parameters('apimServiceName'), 'oauth', 'register-options')]"
              ]
            },
            {
              "type": "Microsoft.ApiManagement/service/apis/operations",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}', parameters('apimServiceName'), 'oauth', 'oauthmetadata-options')]",
              "properties": {
                "displayName": "OAuth Metadata Options",
                "method": "OPTIONS",
                "urlTemplate": "/.well-known/oauth-authorization-server",
                "description": "CORS preflight request handler for OAuth metadata endpoint"
              },
              "dependsOn": [
                "[resourceId('Microsoft.ApiManagement/service/apis', parameters('apimServiceName'), 'oauth')]"
              ]
            },
            {
              "type": "Microsoft.ApiManagement/service/apis/operations/policies",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}/{3}', parameters('apimServiceName'), 'oauth', 'oauthmetadata-options', 'policy')]",
              "properties": {
                "format": "rawxml",
                "value": "[variables('$fxv#5')]"
              },
              "dependsOn": [
                "[resourceId('Microsoft.ApiManagement/service/apis/operations', parameters('apimServiceName'), 'oauth', 'oauthmetadata-options')]"
              ]
            },
            {
              "type": "Microsoft.ApiManagement/service/apis/operations",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}', parameters('apimServiceName'), 'oauth', 'oauthmetadata-get')]",
              "properties": {
                "displayName": "OAuth Metadata Get",
                "method": "GET",
                "urlTemplate": "/.well-known/oauth-authorization-server",
                "description": "OAuth 2.0 metadata endpoint"
              },
              "dependsOn": [
                "[resourceId('Microsoft.ApiManagement/service/apis', parameters('apimServiceName'), 'oauth')]"
              ]
            },
            {
              "type": "Microsoft.ApiManagement/service/apis/operations/policies",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}/{3}', parameters('apimServiceName'), 'oauth', 'oauthmetadata-get', 'policy')]",
              "properties": {
                "format": "rawxml",
                "value": "[variables('$fxv#6')]"
              },
              "dependsOn": [
                "[resourceId('Microsoft.ApiManagement/service/apis/operations', parameters('apimServiceName'), 'oauth', 'oauthmetadata-get')]"
              ]
            },
            {
              "type": "Microsoft.ApiManagement/service/apis/operations",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}', parameters('apimServiceName'), 'oauth', 'consent-get')]",
              "properties": {
                "displayName": "Consent Page",
                "method": "GET",
                "urlTemplate": "/consent",
                "description": "Client consent page endpoint"
              },
              "dependsOn": [
                "[resourceId('Microsoft.ApiManagement/service/apis', parameters('apimServiceName'), 'oauth')]"
              ]
            },
            {
              "type": "Microsoft.ApiManagement/service/apis/operations/policies",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}/{3}', parameters('apimServiceName'), 'oauth', 'consent-get', 'policy')]",
              "properties": {
                "format": "rawxml",
                "value": "[variables('$fxv#7')]"
              },
              "dependsOn": [
                "[resourceId('Microsoft.ApiManagement/service/apis/operations', parameters('apimServiceName'), 'oauth', 'consent-get')]"
              ]
            },
            {
              "type": "Microsoft.ApiManagement/service/apis/operations",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}', parameters('apimServiceName'), 'oauth', 'consent-post')]",
              "properties": {
                "displayName": "Consent Submission",
                "method": "POST",
                "urlTemplate": "/consent",
                "description": "Client consent submission endpoint"
              },
              "dependsOn": [
                "[resourceId('Microsoft.ApiManagement/service/apis', parameters('apimServiceName'), 'oauth')]"
              ]
            },
            {
              "type": "Microsoft.ApiManagement/service/apis/operations/policies",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}/{3}', parameters('apimServiceName'), 'oauth', 'consent-post', 'policy')]",
              "properties": {
                "format": "rawxml",
                "value": "[variables('$fxv#8')]"
              },
              "dependsOn": [
                "[resourceId('Microsoft.ApiManagement/service/apis/operations', parameters('apimServiceName'), 'oauth', 'consent-post')]"
              ]
            },
            {
              "type": "Microsoft.Resources/deployments",
              "apiVersion": "2025-04-01",
              "name": "entraApp",
              "properties": {
                "expressionEvaluationOptions": {
                  "scope": "inner"
                },
                "mode": "Incremental",
                "parameters": {
                  "entraAppUniqueName": {
                    "value": "[parameters('entraAppUniqueName')]"
                  },
                  "entraAppDisplayName": {
                    "value": "[parameters('entraAppDisplayName')]"
                  },
                  "apimOauthCallback": {
                    "value": "[format('{0}/oauth-callback', reference(resourceId('Microsoft.ApiManagement/service', parameters('apimServiceName')), '2021-08-01').gatewayUrl)]"
                  },
                  "userAssignedIdentityPrincipleId": {
                    "value": "[parameters('entraAppUserAssignedIdentityPrincipleId')]"
                  },
                  "existingEntraAppId": {
                    "value": "[parameters('existingEntraAppId')]"
                  }
                },
                "template": {
                  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
                  "contentVersion": "1.0.0.0",
                  "metadata": {
                    "_generator": {
                      "name": "bicep",
                      "version": "0.40.2.10011",
                      "templateHash": "9626897090370742452"
                    }
                  },
                  "parameters": {
                    "entraAppUniqueName": {
                      "type": "string",
                      "metadata": {
                        "description": "The name of the Entra application"
                      }
                    },
                    "entraAppDisplayName": {
                      "type": "string",
                      "metadata": {
                        "description": "The display name of the Entra application"
                      }
                    },
                    "tenantId": {
                      "type": "string",
                      "defaultValue": "[tenant().tenantId]",
                      "metadata": {
                        "description": "Tenant ID where the application is registered"
                      }
                    },
                    "apimOauthCallback": {
                      "type": "string",
                      "metadata": {
                        "description": "The OAuth callback URL for the API Management service"
                      }
                    },
                    "userAssignedIdentityPrincipleId": {
                      "type": "string",
                      "metadata": {
                        "description": "The principle id of the user-assigned managed identity"
                      }
                    },
                    "existingEntraAppId": {
                      "type": "string",
                      "defaultValue": "",
                      "metadata": {
                        "description": "The pre-created Entra application client ID - must be provided for now"
                      }
                    }
                  },
                  "resources": [],
                  "outputs": {
                    "entraAppId": {
                      "type": "string",
                      "value": "[if(not(equals(parameters('existingEntraAppId'), '')), parameters('existingEntraAppId'), '6441e54f-8149-487b-aac4-3a55a049a362')]"
                    },
                    "entraAppTenantId": {
                      "type": "string",
                      "value": "[parameters('tenantId')]"
                    }
                  }
                }
              }
            }
          ],
          "outputs": {
            "apiId": {
              "type": "string",
              "value": "[resourceId('Microsoft.ApiManagement/service/apis', parameters('apimServiceName'), 'oauth')]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', variables('apiManagementName'))]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "mcpApiModule",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "apimServiceName": {
            "value": "[variables('apiManagementName')]"
          },
          "mcpServerBackendUrl": {
            "value": "[format('http://{0}/runtime/webhooks/mcp', reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpPublicIp'), '2025-04-01').outputs.publicIpAddress.value)]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "2303636145518696418"
            }
          },
          "parameters": {
            "apimServiceName": {
              "type": "string",
              "metadata": {
                "description": "The name of the API Management service"
              }
            },
            "mcpServerBackendUrl": {
              "type": "string",
              "metadata": {
                "description": "The backend URL for the MCP server (AKS service endpoint)"
              }
            }
          },
          "variables": {
            "$fxv#0": "<!--\n    SIMPLIFIED MCP API POLICY - FOR DEBUGGING\n    This is a simplified version to test if the basic MCP infrastructure works\n-->\n<policies>\n    <inbound>\n        <base />\n        <!-- Check for Authorization header -->\n        <check-header name=\"Authorization\" failed-check-httpcode=\"401\" failed-check-error-message=\"Not authorized\" ignore-case=\"false\" />\n        \n        <!-- For testing, just validate that we have a Bearer token that starts with \"mcp_access_token\" -->\n        <set-variable name=\"authHeader\" value=\"@(context.Request.Headers.GetValueOrDefault(\"Authorization\", \"\"))\" />\n        <set-variable name=\"bearerToken\" value=\"@{\n            string authHeader = (string)context.Variables.GetValueOrDefault(\"authHeader\", \"\");\n            return authHeader.StartsWith(\"Bearer \") ? authHeader.Substring(7) : \"\";\n        }\" />\n        \n        <choose>\n            <when condition=\"@(!((string)context.Variables.GetValueOrDefault(\"bearerToken\", \"\")).StartsWith(\"mcp_access_token\"))\">\n                <return-response>\n                    <set-status code=\"401\" reason=\"Unauthorized\" />\n                    <set-header name=\"WWW-Authenticate\" exists-action=\"override\">\n                        <value>Bearer error=\"invalid_token\", error_description=\"Token must start with mcp_access_token\"</value>\n                    </set-header>\n                    <set-body>{\"error\": \"invalid_token\", \"message\": \"Invalid or expired access token\"}</set-body>\n                </return-response>\n            </when>\n        </choose>\n        \n    </inbound>\n    <backend>\n        <base />\n    </backend>\n    <outbound>\n        <base />\n    </outbound>\n    <on-error>\n        <base />\n    </on-error>\n</policies>"
          },
          "resources": [
            {
              "type": "Microsoft.ApiManagement/service/apis",
              "apiVersion": "2023-05-01-preview",
              "name": "[format('{0}/{1}', parameters('apimServiceName'), 'mcp')]",
              "properties": {
                "displayName": "MCP API",
                "description": "Model Context Protocol API endpoints - powered by AKS",
                "subscriptionRequired": false,
                "path": "mcp",
                "protocols": [
                  "https"
                ],
                "serviceUrl": "[parameters('mcpServerBackendUrl')]"
              }
            },
            {
              "type": "Microsoft.ApiManagement/service/apis/policies",
              "apiVersion": "2023-05-01-preview",
              "name": "[format('{0}/{1}/{2}', parameters('apimServiceName'), 'mcp', 'policy')]",
              "properties": {
                "format": "rawxml",
                "value": "[variables('$fxv#0')]"
              },
              "dependsOn": [
                "[resourceId('Microsoft.ApiManagement/service/apis', parameters('apimServiceName'), 'mcp')]"
              ]
            },
            {
              "type": "Microsoft.ApiManagement/service/apis/operations",
              "apiVersion": "2023-05-01-preview",
              "name": "[format('{0}/{1}/{2}', parameters('apimServiceName'), 'mcp', 'mcp-sse')]",
              "properties": {
                "displayName": "MCP SSE Endpoint",
                "method": "GET",
                "urlTemplate": "/sse",
                "description": "Server-Sent Events endpoint for MCP Server"
              },
              "dependsOn": [
                "[resourceId('Microsoft.ApiManagement/service/apis', parameters('apimServiceName'), 'mcp')]"
              ]
            },
            {
              "type": "Microsoft.ApiManagement/service/apis/operations",
              "apiVersion": "2023-05-01-preview",
              "name": "[format('{0}/{1}/{2}', parameters('apimServiceName'), 'mcp', 'mcp-message')]",
              "properties": {
                "displayName": "MCP Message Endpoint",
                "method": "POST",
                "urlTemplate": "/message",
                "description": "Message endpoint for MCP Server"
              },
              "dependsOn": [
                "[resourceId('Microsoft.ApiManagement/service/apis', parameters('apimServiceName'), 'mcp')]"
              ]
            }
          ],
          "outputs": {
            "apiId": {
              "type": "string",
              "value": "[resourceId('Microsoft.ApiManagement/service/apis', parameters('apimServiceName'), 'mcp')]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'aksCluster')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', variables('apiManagementName'))]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpPublicIp')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'oauthAPIModule')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "aksUserAssignedIdentity",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "identityName": "[if(not(empty(parameters('apiUserAssignedIdentityName'))), createObject('value', parameters('apiUserAssignedIdentityName')), createObject('value', format('{0}aks-{1}', variables('abbrs').managedIdentityUserAssignedIdentities, variables('resourceToken'))))]"
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "16771438374117069306"
            }
          },
          "parameters": {
            "identityName": {
              "type": "string"
            },
            "location": {
              "type": "string"
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            }
          },
          "resources": [
            {
              "type": "Microsoft.ManagedIdentity/userAssignedIdentities",
              "apiVersion": "2023-07-31-preview",
              "name": "[parameters('identityName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]"
            }
          ],
          "outputs": {
            "identityId": {
              "type": "string",
              "value": "[resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', parameters('identityName'))]"
            },
            "identityName": {
              "type": "string",
              "value": "[parameters('identityName')]"
            },
            "identityPrincipalId": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', parameters('identityName')), '2023-07-31-preview').principalId]"
            },
            "identityClientId": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', parameters('identityName')), '2023-07-31-preview').clientId]"
            }
          }
        }
      },
      "dependsOn": [
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "mcpUserAssignedIdentity",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "identityName": {
            "value": "[format('{0}mcp-{1}', variables('abbrs').managedIdentityUserAssignedIdentities, variables('resourceToken'))]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "16771438374117069306"
            }
          },
          "parameters": {
            "identityName": {
              "type": "string"
            },
            "location": {
              "type": "string"
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            }
          },
          "resources": [
            {
              "type": "Microsoft.ManagedIdentity/userAssignedIdentities",
              "apiVersion": "2023-07-31-preview",
              "name": "[parameters('identityName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]"
            }
          ],
          "outputs": {
            "identityId": {
              "type": "string",
              "value": "[resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', parameters('identityName'))]"
            },
            "identityName": {
              "type": "string",
              "value": "[parameters('identityName')]"
            },
            "identityPrincipalId": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', parameters('identityName')), '2023-07-31-preview').principalId]"
            },
            "identityClientId": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', parameters('identityName')), '2023-07-31-preview').clientId]"
            }
          }
        }
      },
      "dependsOn": [
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "condition": "[parameters('agentIdentityEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "agentIdentityBlueprint",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "blueprintDisplayName": {
            "value": "[variables('agentBlueprintName')]"
          },
          "blueprintUniqueName": {
            "value": "[format('nba-blueprint-{0}', variables('resourceToken'))]"
          },
          "federatedIdentityClientId": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity'), '2025-04-01').outputs.identityName.value]"
          },
          "federatedIdentityPrincipalId": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity'), '2025-04-01').outputs.identityPrincipalId.value]"
          },
          "sponsorPrincipalIds": "[if(not(empty(parameters('agentSponsorPrincipalId'))), createObject('value', createArray(parameters('agentSponsorPrincipalId'))), createObject('value', createArray()))]",
          "ownerPrincipalIds": "[if(not(empty(parameters('agentSponsorPrincipalId'))), createObject('value', createArray(parameters('agentSponsorPrincipalId'))), createObject('value', createArray()))]",
          "agentScopeValue": {
            "value": "next_best_action"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "12678516115314025188"
            }
          },
          "parameters": {
            "blueprintDisplayName": {
              "type": "string",
              "metadata": {
                "description": "Display name for the Entra Agent Identity Blueprint application"
              }
            },
            "blueprintUniqueName": {
              "type": "string",
              "metadata": {
                "description": "Unique name for the Entra Agent Identity Blueprint (used for identifierUri)"
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Location for deployment scripts"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for resources"
              }
            },
            "sponsorPrincipalIds": {
              "type": "array",
              "defaultValue": [],
              "metadata": {
                "description": "Principal IDs of sponsors (users or groups) for the agent identity blueprint"
              }
            },
            "ownerPrincipalIds": {
              "type": "array",
              "defaultValue": [],
              "metadata": {
                "description": "Principal IDs of owners for the agent identity blueprint"
              }
            },
            "federatedIdentityClientId": {
              "type": "string",
              "metadata": {
                "description": "Client ID of the managed identity to use as federated credential for the blueprint"
              }
            },
            "federatedIdentityPrincipalId": {
              "type": "string",
              "metadata": {
                "description": "Principal ID of the managed identity to use as federated credential"
              }
            },
            "tenantId": {
              "type": "string",
              "defaultValue": "[tenant().tenantId]",
              "metadata": {
                "description": "Tenant ID for the Entra ID tenant"
              }
            },
            "agentScopeValue": {
              "type": "string",
              "defaultValue": "access_agent",
              "metadata": {
                "description": "OAuth2 scope value for the agent (default: access_agent)"
              }
            }
          },
          "variables": {
            "entraLoginEndpoint": "[environment().authentication.loginEndpoint]",
            "deploymentScriptName": "[format('ds-agent-blueprint-{0}', uniqueString(parameters('blueprintUniqueName')))]"
          },
          "resources": [
            {
              "type": "Microsoft.Resources/deploymentScripts",
              "apiVersion": "2023-08-01",
              "name": "[variables('deploymentScriptName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "kind": "AzurePowerShell",
              "identity": {
                "type": "UserAssigned",
                "userAssignedIdentities": {
                  "[format('{0}', resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', parameters('federatedIdentityClientId')))]": {}
                }
              },
              "properties": {
                "azPowerShellVersion": "12.0",
                "timeout": "PT30M",
                "retentionInterval": "P1D",
                "cleanupPreference": "OnSuccess",
                "arguments": "[format('-BlueprintDisplayName \"{0}\" -BlueprintUniqueName \"{1}\" -TenantId \"{2}\" -FederatedIdentityPrincipalId \"{3}\" -SponsorIds \"{4}\" -OwnerIds \"{5}\" -AgentScopeValue \"{6}\" -EntraLoginEndpoint \"{7}\"', parameters('blueprintDisplayName'), parameters('blueprintUniqueName'), parameters('tenantId'), parameters('federatedIdentityPrincipalId'), join(parameters('sponsorPrincipalIds'), ','), join(parameters('ownerPrincipalIds'), ','), parameters('agentScopeValue'), variables('entraLoginEndpoint'))]",
                "scriptContent": "      param(\n        [string]$BlueprintDisplayName,\n        [string]$BlueprintUniqueName,\n        [string]$TenantId,\n        [string]$FederatedIdentityPrincipalId,\n        [string]$SponsorIds,\n        [string]$OwnerIds,\n        [string]$AgentScopeValue,\n        [string]$EntraLoginEndpoint\n      )\n\n      # Install Microsoft.Graph modules if needed\n      $modules = @('Microsoft.Graph.Authentication', 'Microsoft.Graph.Applications')\n      foreach ($module in $modules) {\n        if (-not (Get-Module -ListAvailable -Name $module)) {\n          Install-Module -Name $module -Force -Scope CurrentUser -AllowClobber\n        }\n        Import-Module $module -Force\n      }\n\n      # Connect to Microsoft Graph using managed identity\n      Connect-MgGraph -Identity -NoWelcome\n\n      # Prepare sponsors array\n      $sponsors = @()\n      if ($SponsorIds -and $SponsorIds -ne \"\") {\n        $sponsorIdList = $SponsorIds -split ','\n        foreach ($id in $sponsorIdList) {\n          if ($id.Trim()) {\n            $sponsors += \"https://graph.microsoft.com/v1.0/users/$($id.Trim())\"\n          }\n        }\n      }\n\n      # Prepare owners array\n      $owners = @()\n      if ($OwnerIds -and $OwnerIds -ne \"\") {\n        $ownerIdList = $OwnerIds -split ','\n        foreach ($id in $ownerIdList) {\n          if ($id.Trim()) {\n            $owners += \"https://graph.microsoft.com/v1.0/users/$($id.Trim())\"\n          }\n        }\n      }\n\n      # Check if blueprint already exists\n      $existingApp = Get-MgApplication -Filter \"displayName eq '$BlueprintDisplayName'\" -ErrorAction SilentlyContinue | Where-Object { $_.AdditionalProperties.'@odata.type' -eq '#microsoft.graph.agentIdentityBlueprint' }\n\n      if ($existingApp) {\n        Write-Host \"Agent Identity Blueprint already exists with App ID: $($existingApp.AppId)\"\n        $blueprintAppId = $existingApp.AppId\n        $blueprintObjectId = $existingApp.Id\n      } else {\n        # Create Agent Identity Blueprint application\n        $blueprintBody = @{\n          '@odata.type' = '#microsoft.graph.agentIdentityBlueprint'\n          displayName = $BlueprintDisplayName\n        }\n\n        if ($sponsors.Count -gt 0) {\n          $blueprintBody['sponsors@odata.bind'] = $sponsors\n        }\n        if ($owners.Count -gt 0) {\n          $blueprintBody['owners@odata.bind'] = $owners\n        }\n\n        # Create the blueprint via Graph API\n        $headers = @{\n          'OData-Version' = '4.0'\n          'Content-Type' = 'application/json'\n        }\n\n        try {\n          $blueprintResponse = Invoke-MgGraphRequest -Method POST -Uri 'https://graph.microsoft.com/beta/applications' -Body ($blueprintBody | ConvertTo-Json -Depth 10) -Headers $headers\n          $blueprintAppId = $blueprintResponse.appId\n          $blueprintObjectId = $blueprintResponse.id\n          Write-Host \"Created Agent Identity Blueprint with App ID: $blueprintAppId\"\n        } catch {\n          Write-Error \"Failed to create Agent Identity Blueprint: $_\"\n          throw\n        }\n\n        # Create Service Principal for the blueprint\n        $spBody = @{\n          appId = $blueprintAppId\n        }\n\n        try {\n          $spResponse = Invoke-MgGraphRequest -Method POST -Uri 'https://graph.microsoft.com/beta/serviceprincipals/graph.agentIdentityBlueprintPrincipal' -Body ($spBody | ConvertTo-Json) -Headers $headers\n          Write-Host \"Created Service Principal for Agent Identity Blueprint\"\n        } catch {\n          Write-Warning \"Service Principal may already exist or failed to create: $_\"\n        }\n\n        # Add federated identity credential for managed identity\n        $fedCredBody = @{\n          name = 'mcp-agent-msi'\n          issuer = \"$EntraLoginEndpoint$TenantId/v2.0\"\n          subject = $FederatedIdentityPrincipalId\n          audiences = @('api://AzureADTokenExchange')\n        }\n\n        try {\n          Invoke-MgGraphRequest -Method POST -Uri \"https://graph.microsoft.com/beta/applications/$blueprintObjectId/federatedIdentityCredentials\" -Body ($fedCredBody | ConvertTo-Json) -Headers $headers\n          Write-Host \"Added federated identity credential for managed identity\"\n        } catch {\n          Write-Warning \"Federated credential may already exist: $_\"\n        }\n\n        # Configure identifier URI and OAuth2 scope\n        $scopeId = [guid]::NewGuid().ToString()\n        $updateBody = @{\n          identifierUris = @(\"api://$blueprintAppId\")\n          api = @{\n            oauth2PermissionScopes = @(\n              @{\n                adminConsentDescription = \"Allow the application to access the agent on behalf of the signed-in user.\"\n                adminConsentDisplayName = \"Access Agent\"\n                id = $scopeId\n                isEnabled = $true\n                type = \"User\"\n                value = $AgentScopeValue\n              }\n            )\n          }\n        }\n\n        try {\n          Invoke-MgGraphRequest -Method PATCH -Uri \"https://graph.microsoft.com/beta/applications/$blueprintObjectId\" -Body ($updateBody | ConvertTo-Json -Depth 10) -Headers $headers\n          Write-Host \"Configured identifier URI and OAuth2 scope\"\n        } catch {\n          Write-Warning \"Failed to configure identifier URI: $_\"\n        }\n      }\n\n      # Output results\n      $DeploymentScriptOutputs = @{}\n      $DeploymentScriptOutputs['blueprintAppId'] = $blueprintAppId\n      $DeploymentScriptOutputs['blueprintObjectId'] = $blueprintObjectId\n      $DeploymentScriptOutputs['identifierUri'] = \"api://$blueprintAppId\"\n\n      Write-Host \"Agent Identity Blueprint setup complete\"\n      Write-Host \"Blueprint App ID: $blueprintAppId\"\n      Write-Host \"Blueprint Object ID: $blueprintObjectId\"\n    "
              }
            }
          ],
          "outputs": {
            "blueprintAppId": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Resources/deploymentScripts', variables('deploymentScriptName')), '2023-08-01').outputs.blueprintAppId]"
            },
            "blueprintObjectId": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Resources/deploymentScripts', variables('deploymentScriptName')), '2023-08-01').outputs.blueprintObjectId]"
            },
            "identifierUri": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Resources/deploymentScripts', variables('deploymentScriptName')), '2023-08-01').outputs.identifierUri]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "condition": "[parameters('agentIdentityEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "nextBestActionAgentIdentity",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "agentDisplayName": {
            "value": "[variables('agentName')]"
          },
          "blueprintAppId": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'agentIdentityBlueprint'), '2025-04-01').outputs.blueprintAppId.value]"
          },
          "managedIdentityResourceId": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity'), '2025-04-01').outputs.identityId.value]"
          },
          "sponsorPrincipalIds": "[if(not(empty(parameters('agentSponsorPrincipalId'))), createObject('value', createArray(parameters('agentSponsorPrincipalId'))), createObject('value', createArray()))]"
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "11689876024684401853"
            }
          },
          "parameters": {
            "agentDisplayName": {
              "type": "string",
              "metadata": {
                "description": "Display name for the Entra Agent Identity"
              }
            },
            "blueprintAppId": {
              "type": "string",
              "metadata": {
                "description": "App ID of the Agent Identity Blueprint"
              }
            },
            "sponsorPrincipalIds": {
              "type": "array",
              "defaultValue": [],
              "metadata": {
                "description": "Principal IDs of sponsors (users or groups) for the agent identity"
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Location for deployment scripts"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for resources"
              }
            },
            "managedIdentityResourceId": {
              "type": "string",
              "metadata": {
                "description": "Resource ID of the managed identity (full resource ID)"
              }
            }
          },
          "variables": {
            "deploymentScriptName": "[format('ds-agent-identity-{0}', uniqueString(parameters('agentDisplayName')))]"
          },
          "resources": [
            {
              "type": "Microsoft.Resources/deploymentScripts",
              "apiVersion": "2023-08-01",
              "name": "[variables('deploymentScriptName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "kind": "AzurePowerShell",
              "identity": {
                "type": "UserAssigned",
                "userAssignedIdentities": {
                  "[format('{0}', parameters('managedIdentityResourceId'))]": {}
                }
              },
              "properties": {
                "azPowerShellVersion": "12.0",
                "timeout": "PT30M",
                "retentionInterval": "P1D",
                "cleanupPreference": "OnSuccess",
                "arguments": "[format('-AgentDisplayName \"{0}\" -BlueprintAppId \"{1}\" -SponsorIds \"{2}\"', parameters('agentDisplayName'), parameters('blueprintAppId'), join(parameters('sponsorPrincipalIds'), ','))]",
                "scriptContent": "      param(\n        [string]$AgentDisplayName,\n        [string]$BlueprintAppId,\n        [string]$SponsorIds\n      )\n\n      # Install Microsoft.Graph modules if needed\n      $modules = @('Microsoft.Graph.Authentication')\n      foreach ($module in $modules) {\n        if (-not (Get-Module -ListAvailable -Name $module)) {\n          Install-Module -Name $module -Force -Scope CurrentUser -AllowClobber\n        }\n        Import-Module $module -Force\n      }\n\n      # Connect to Microsoft Graph using managed identity\n      Connect-MgGraph -Identity -NoWelcome\n\n      # Get the blueprint service principal to obtain token\n      $blueprintSp = Get-MgServicePrincipal -Filter \"appId eq '$BlueprintAppId'\" -ErrorAction SilentlyContinue\n\n      if (-not $blueprintSp) {\n        Write-Error \"Blueprint service principal not found for App ID: $BlueprintAppId\"\n        throw \"Blueprint not found\"\n      }\n\n      # Check if agent identity already exists\n      $existingSp = Get-MgServicePrincipal -Filter \"displayName eq '$AgentDisplayName' and servicePrincipalType eq 'AgentIdentity'\" -ErrorAction SilentlyContinue\n\n      if ($existingSp) {\n        Write-Host \"Agent Identity already exists with ID: $($existingSp.Id)\"\n        $agentIdentityId = $existingSp.Id\n        $agentIdentityAppId = $existingSp.AppId\n      } else {\n        # Prepare sponsors array\n        $sponsors = @()\n        if ($SponsorIds -and $SponsorIds -ne \"\") {\n          $sponsorIdList = $SponsorIds -split ','\n          foreach ($id in $sponsorIdList) {\n            if ($id.Trim()) {\n              $sponsors += \"https://graph.microsoft.com/v1.0/users/$($id.Trim())\"\n            }\n          }\n        }\n\n        # Create Agent Identity via Graph API\n        $headers = @{\n          'OData-Version' = '4.0'\n          'Content-Type' = 'application/json'\n        }\n\n        $agentBody = @{\n          displayName = $AgentDisplayName\n          agentIdentityBlueprintId = $BlueprintAppId\n        }\n\n        if ($sponsors.Count -gt 0) {\n          $agentBody['sponsors@odata.bind'] = $sponsors\n        }\n\n        try {\n          $agentResponse = Invoke-MgGraphRequest -Method POST -Uri 'https://graph.microsoft.com/beta/serviceprincipals/Microsoft.Graph.AgentIdentity' -Body ($agentBody | ConvertTo-Json -Depth 10) -Headers $headers\n          $agentIdentityId = $agentResponse.id\n          $agentIdentityAppId = $agentResponse.appId\n          Write-Host \"Created Agent Identity with ID: $agentIdentityId\"\n        } catch {\n          Write-Error \"Failed to create Agent Identity: $_\"\n          throw\n        }\n      }\n\n      # Get the full service principal details for the agent identity\n      $agentSp = Invoke-MgGraphRequest -Method GET -Uri \"https://graph.microsoft.com/beta/serviceprincipals/$agentIdentityId\" -ErrorAction SilentlyContinue\n\n      # Output results\n      $DeploymentScriptOutputs = @{}\n      $DeploymentScriptOutputs['agentIdentityId'] = $agentIdentityId\n      $DeploymentScriptOutputs['agentIdentityAppId'] = if ($agentIdentityAppId) { $agentIdentityAppId } else { $agentSp.appId }\n      $DeploymentScriptOutputs['agentIdentityPrincipalId'] = $agentIdentityId\n      $DeploymentScriptOutputs['agentDisplayName'] = $AgentDisplayName\n\n      Write-Host \"Agent Identity creation complete\"\n      Write-Host \"Agent Identity ID: $agentIdentityId\"\n    "
              }
            }
          ],
          "outputs": {
            "agentIdentityId": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Resources/deploymentScripts', variables('deploymentScriptName')), '2023-08-01').outputs.agentIdentityId]"
            },
            "agentIdentityAppId": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Resources/deploymentScripts', variables('deploymentScriptName')), '2023-08-01').outputs.agentIdentityAppId]"
            },
            "agentIdentityPrincipalId": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Resources/deploymentScripts', variables('deploymentScriptName')), '2023-08-01').outputs.agentIdentityPrincipalId]"
            },
            "agentDisplayName": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Resources/deploymentScripts', variables('deploymentScriptName')), '2023-08-01').outputs.agentDisplayName]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'agentIdentityBlueprint')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "condition": "[parameters('vnetEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "serviceVirtualNetworkEarly",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "vNetName": {
            "value": "[variables('serviceVirtualNetworkName')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "3111291406551580618"
            }
          },
          "parameters": {
            "vNetName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the virtual network."
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Specifies the location."
              }
            },
            "peSubnetName": {
              "type": "string",
              "defaultValue": "private-endpoints-subnet",
              "metadata": {
                "description": "Specifies the name of the subnet for the Service Bus private endpoint."
              }
            },
            "appSubnetName": {
              "type": "string",
              "defaultValue": "app",
              "metadata": {
                "description": "Specifies the name of the subnet for Function App virtual network integration."
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            }
          },
          "resources": [
            {
              "type": "Microsoft.Network/virtualNetworks",
              "apiVersion": "2023-05-01",
              "name": "[parameters('vNetName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "addressSpace": {
                  "addressPrefixes": [
                    "10.0.0.0/16"
                  ]
                },
                "encryption": {
                  "enabled": false,
                  "enforcement": "AllowUnencrypted"
                },
                "subnets": [
                  {
                    "name": "[parameters('peSubnetName')]",
                    "id": "[resourceId('Microsoft.Network/virtualNetworks/subnets', parameters('vNetName'), 'private-endpoints-subnet')]",
                    "properties": {
                      "addressPrefixes": [
                        "10.0.1.0/24"
                      ],
                      "delegations": [],
                      "privateEndpointNetworkPolicies": "Disabled",
                      "privateLinkServiceNetworkPolicies": "Enabled"
                    },
                    "type": "Microsoft.Network/virtualNetworks/subnets"
                  },
                  {
                    "name": "[parameters('appSubnetName')]",
                    "id": "[resourceId('Microsoft.Network/virtualNetworks/subnets', parameters('vNetName'), 'app')]",
                    "properties": {
                      "addressPrefixes": [
                        "10.0.2.0/24"
                      ],
                      "delegations": [],
                      "privateEndpointNetworkPolicies": "Disabled",
                      "privateLinkServiceNetworkPolicies": "Enabled"
                    },
                    "type": "Microsoft.Network/virtualNetworks/subnets"
                  }
                ],
                "virtualNetworkPeerings": [],
                "enableDdosProtection": false
              }
            }
          ],
          "outputs": {
            "peSubnetName": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Network/virtualNetworks', parameters('vNetName')), '2023-05-01').subnets[0].name]"
            },
            "peSubnetID": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Network/virtualNetworks', parameters('vNetName')), '2023-05-01').subnets[0].id]"
            },
            "appSubnetName": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Network/virtualNetworks', parameters('vNetName')), '2023-05-01').subnets[1].name]"
            },
            "appSubnetID": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Network/virtualNetworks', parameters('vNetName')), '2023-05-01').subnets[1].id]"
            }
          }
        }
      },
      "dependsOn": [
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "containerRegistry",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "containerRegistryName": {
            "value": "[format('{0}{1}', variables('abbrs').containerRegistryRegistries, variables('resourceToken'))]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "sku": {
            "value": "Standard"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "1975803023402811"
            }
          },
          "parameters": {
            "containerRegistryName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Azure Container Registry"
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Location for the container registry"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for the container registry"
              }
            },
            "sku": {
              "type": "string",
              "defaultValue": "Standard",
              "allowedValues": [
                "Basic",
                "Standard",
                "Premium"
              ],
              "metadata": {
                "description": "SKU for the container registry"
              }
            },
            "adminUserEnabled": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enable admin user"
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.ContainerRegistry/registries",
              "apiVersion": "2023-07-01",
              "name": "[parameters('containerRegistryName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "sku": {
                "name": "[parameters('sku')]"
              },
              "properties": {
                "adminUserEnabled": "[parameters('adminUserEnabled')]",
                "publicNetworkAccess": "Enabled",
                "networkRuleBypassOptions": "AzureServices"
              }
            }
          ],
          "outputs": {
            "containerRegistryId": {
              "type": "string",
              "value": "[resourceId('Microsoft.ContainerRegistry/registries', parameters('containerRegistryName'))]"
            },
            "containerRegistryName": {
              "type": "string",
              "value": "[parameters('containerRegistryName')]"
            },
            "containerRegistryLoginServer": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.ContainerRegistry/registries', parameters('containerRegistryName')), '2023-07-01').loginServer]"
            }
          }
        }
      },
      "dependsOn": [
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "condition": "[parameters('grafanaEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "azureMonitorWorkspace",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "name": {
            "value": "[variables('azureMonitorWorkspaceName')]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "publicNetworkAccess": {
            "value": "Enabled"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "1984079737053311755"
            }
          },
          "parameters": {
            "name": {
              "type": "string",
              "metadata": {
                "description": "Name of the Azure Monitor Workspace"
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Location for the Azure Monitor Workspace"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for the Azure Monitor Workspace"
              }
            },
            "publicNetworkAccess": {
              "type": "string",
              "defaultValue": "Enabled",
              "allowedValues": [
                "Enabled",
                "Disabled"
              ],
              "metadata": {
                "description": "Enable public network access"
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.Monitor/accounts",
              "apiVersion": "2023-04-03",
              "name": "[parameters('name')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "publicNetworkAccess": "[parameters('publicNetworkAccess')]"
              }
            }
          ],
          "outputs": {
            "id": {
              "type": "string",
              "metadata": {
                "description": "The resource ID of the Azure Monitor Workspace"
              },
              "value": "[resourceId('Microsoft.Monitor/accounts', parameters('name'))]"
            },
            "name": {
              "type": "string",
              "metadata": {
                "description": "The name of the Azure Monitor Workspace"
              },
              "value": "[parameters('name')]"
            },
            "prometheusQueryEndpoint": {
              "type": "string",
              "metadata": {
                "description": "The Prometheus query endpoint"
              },
              "value": "[reference(resourceId('Microsoft.Monitor/accounts', parameters('name')), '2023-04-03').metrics.prometheusQueryEndpoint]"
            },
            "dataCollectionRuleId": {
              "type": "string",
              "metadata": {
                "description": "The default data collection rule resource ID"
              },
              "value": "[reference(resourceId('Microsoft.Monitor/accounts', parameters('name')), '2023-04-03').defaultIngestionSettings.dataCollectionRuleResourceId]"
            },
            "dataCollectionEndpointId": {
              "type": "string",
              "metadata": {
                "description": "The default data collection endpoint resource ID"
              },
              "value": "[reference(resourceId('Microsoft.Monitor/accounts', parameters('name')), '2023-04-03').defaultIngestionSettings.dataCollectionEndpointResourceId]"
            }
          }
        }
      },
      "dependsOn": [
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "aksCluster",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "aksClusterName": {
            "value": "[format('{0}{1}', variables('abbrs').containerServiceManagedClusters, variables('resourceToken'))]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "kubernetesVersion": {
            "value": "1.32.0"
          },
          "systemNodePoolVmSize": {
            "value": "Standard_DS2_v2"
          },
          "systemNodePoolCount": {
            "value": 2
          },
          "userAssignedIdentityId": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'aksUserAssignedIdentity'), '2025-04-01').outputs.identityId.value]"
          },
          "logAnalyticsWorkspaceId": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'monitoring'), '2025-04-01').outputs.logAnalyticsWorkspaceId.value]"
          },
          "subnetId": "[if(parameters('vnetEnabled'), createObject('value', format('{0}/providers/Microsoft.Network/virtualNetworks/{1}/subnets/{2}', subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), variables('serviceVirtualNetworkName'), variables('serviceVirtualNetworkAppSubnetName'))), createObject('value', ''))]",
          "enablePrometheus": {
            "value": "[parameters('grafanaEnabled')]"
          },
          "azureMonitorWorkspaceId": "[if(parameters('grafanaEnabled'), createObject('value', reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'azureMonitorWorkspace'), '2025-04-01').outputs.id.value), createObject('value', ''))]"
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "7021916576402583270"
            }
          },
          "parameters": {
            "aksClusterName": {
              "type": "string",
              "metadata": {
                "description": "Name of the AKS cluster"
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Location for the AKS cluster"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for the AKS cluster"
              }
            },
            "kubernetesVersion": {
              "type": "string",
              "defaultValue": "1.32.0",
              "metadata": {
                "description": "Kubernetes version"
              }
            },
            "systemNodePoolVmSize": {
              "type": "string",
              "defaultValue": "Standard_DS2_v2",
              "metadata": {
                "description": "System node pool VM size"
              }
            },
            "systemNodePoolCount": {
              "type": "int",
              "defaultValue": 2,
              "metadata": {
                "description": "System node pool count"
              }
            },
            "userAssignedIdentityId": {
              "type": "string",
              "metadata": {
                "description": "User assigned managed identity ID for AKS"
              }
            },
            "logAnalyticsWorkspaceId": {
              "type": "string",
              "metadata": {
                "description": "Log Analytics workspace ID"
              }
            },
            "subnetId": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Virtual Network Subnet ID"
              }
            },
            "enableAzureRbac": {
              "type": "bool",
              "defaultValue": true,
              "metadata": {
                "description": "Enable Azure AD RBAC"
              }
            },
            "enableMonitoring": {
              "type": "bool",
              "defaultValue": true,
              "metadata": {
                "description": "Enable monitoring"
              }
            },
            "skuTier": {
              "type": "string",
              "defaultValue": "Standard",
              "allowedValues": [
                "Free",
                "Standard"
              ],
              "metadata": {
                "description": "AKS SKU tier - Free or Standard"
              }
            },
            "azureMonitorWorkspaceId": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Azure Monitor Workspace ID for Prometheus metrics"
              }
            },
            "enablePrometheus": {
              "type": "bool",
              "defaultValue": true,
              "metadata": {
                "description": "Enable Prometheus metrics collection"
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.ContainerService/managedClusters",
              "apiVersion": "2024-02-01",
              "name": "[parameters('aksClusterName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "sku": {
                "name": "Base",
                "tier": "[parameters('skuTier')]"
              },
              "identity": {
                "type": "UserAssigned",
                "userAssignedIdentities": {
                  "[format('{0}', parameters('userAssignedIdentityId'))]": {}
                }
              },
              "properties": {
                "kubernetesVersion": "[parameters('kubernetesVersion')]",
                "dnsPrefix": "[parameters('aksClusterName')]",
                "enableRBAC": true,
                "aadProfile": {
                  "managed": true,
                  "enableAzureRBAC": "[parameters('enableAzureRbac')]"
                },
                "agentPoolProfiles": [
                  {
                    "name": "system",
                    "count": "[parameters('systemNodePoolCount')]",
                    "vmSize": "[parameters('systemNodePoolVmSize')]",
                    "osType": "Linux",
                    "mode": "System",
                    "type": "VirtualMachineScaleSets",
                    "enableAutoScaling": true,
                    "minCount": "[parameters('systemNodePoolCount')]",
                    "maxCount": "[add(parameters('systemNodePoolCount'), 2)]",
                    "vnetSubnetID": "[if(not(empty(parameters('subnetId'))), parameters('subnetId'), null())]",
                    "tags": "[parameters('tags')]"
                  }
                ],
                "networkProfile": {
                  "networkPlugin": "azure",
                  "networkPolicy": "azure",
                  "serviceCidr": "10.240.0.0/16",
                  "dnsServiceIP": "10.240.0.10",
                  "loadBalancerSku": "standard"
                },
                "addonProfiles": "[if(parameters('enableMonitoring'), createObject('omsagent', createObject('enabled', true(), 'config', createObject('logAnalyticsWorkspaceResourceID', parameters('logAnalyticsWorkspaceId')))), createObject())]",
                "oidcIssuerProfile": {
                  "enabled": true
                },
                "securityProfile": {
                  "workloadIdentity": {
                    "enabled": true
                  }
                },
                "azureMonitorProfile": "[if(and(parameters('enablePrometheus'), not(empty(parameters('azureMonitorWorkspaceId')))), createObject('metrics', createObject('enabled', true(), 'kubeStateMetrics', createObject('metricLabelsAllowlist', '*', 'metricAnnotationsAllowList', '*'))), null())]"
              }
            }
          ],
          "outputs": {
            "aksClusterId": {
              "type": "string",
              "value": "[resourceId('Microsoft.ContainerService/managedClusters', parameters('aksClusterName'))]"
            },
            "aksClusterName": {
              "type": "string",
              "value": "[parameters('aksClusterName')]"
            },
            "aksClusterFqdn": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.ContainerService/managedClusters', parameters('aksClusterName')), '2024-02-01').fqdn]"
            },
            "aksClusterOidcIssuerUrl": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.ContainerService/managedClusters', parameters('aksClusterName')), '2024-02-01').oidcIssuerProfile.issuerURL]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'aksUserAssignedIdentity')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'azureMonitorWorkspace')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'monitoring')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'serviceVirtualNetworkEarly')]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "mcpPublicIp",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "publicIpName": {
            "value": "[format('pip-mcp-{0}', variables('resourceToken'))]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "dnsLabel": {
            "value": "[format('mcp-{0}', variables('resourceToken'))]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "13292431849469641923"
            }
          },
          "parameters": {
            "publicIpName": {
              "type": "string",
              "metadata": {
                "description": "Name of the public IP address"
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Location for the public IP"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for the resource"
              }
            },
            "sku": {
              "type": "string",
              "defaultValue": "Standard",
              "metadata": {
                "description": "SKU for the public IP (Standard required for LoadBalancer)"
              }
            },
            "allocationMethod": {
              "type": "string",
              "defaultValue": "Static",
              "metadata": {
                "description": "Allocation method (Static required for LoadBalancer)"
              }
            },
            "dnsLabel": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "DNS label for the public IP (optional)"
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.Network/publicIPAddresses",
              "apiVersion": "2023-05-01",
              "name": "[parameters('publicIpName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "sku": {
                "name": "[parameters('sku')]",
                "tier": "Regional"
              },
              "properties": {
                "publicIPAllocationMethod": "[parameters('allocationMethod')]",
                "dnsSettings": "[if(not(empty(parameters('dnsLabel'))), createObject('domainNameLabel', parameters('dnsLabel')), null())]"
              }
            }
          ],
          "outputs": {
            "publicIpId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/publicIPAddresses', parameters('publicIpName'))]"
            },
            "publicIpAddress": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Network/publicIPAddresses', parameters('publicIpName')), '2023-05-01').ipAddress]"
            },
            "publicIpFqdn": {
              "type": "string",
              "value": "[if(not(empty(parameters('dnsLabel'))), reference(resourceId('Microsoft.Network/publicIPAddresses', parameters('publicIpName')), '2023-05-01').dnsSettings.fqdn, '')]"
            }
          }
        }
      },
      "dependsOn": [
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "acrPullRoleAssignment",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "containerRegistryName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'containerRegistry'), '2025-04-01').outputs.containerRegistryName.value]"
          },
          "roleDefinitionID": {
            "value": "[variables('acrPullRoleDefinitionId')]"
          },
          "principalID": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'aksUserAssignedIdentity'), '2025-04-01').outputs.identityPrincipalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "11611680302285947865"
            }
          },
          "parameters": {
            "principalID": {
              "type": "string"
            },
            "roleDefinitionID": {
              "type": "string"
            },
            "containerRegistryName": {
              "type": "string"
            },
            "nameSuffix": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Optional suffix to make role assignment name unique across deployments"
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.ContainerRegistry/registries', parameters('containerRegistryName'))]",
              "name": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.ContainerRegistry/registries', parameters('containerRegistryName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.ContainerRegistry/registries', parameters('containerRegistryName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalId": "[parameters('principalID')]",
                "principalType": "ServicePrincipal"
              }
            }
          ],
          "outputs": {
            "roleAssignmentName": {
              "type": "string",
              "value": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.ContainerRegistry/registries', parameters('containerRegistryName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.ContainerRegistry/registries', parameters('containerRegistryName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'aksCluster')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'aksUserAssignedIdentity')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'containerRegistry')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "condition": "[parameters('agentIdentityEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "agentFederatedCredential",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "aksClusterName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'aksCluster'), '2025-04-01').outputs.aksClusterName.value]"
          },
          "serviceAccountNamespace": {
            "value": "mcp-agents"
          },
          "serviceAccountName": {
            "value": "mcp-agent-sa"
          },
          "identityClientId": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'nextBestActionAgentIdentity'), '2025-04-01').outputs.agentIdentityAppId.value]"
          },
          "identityPrincipalId": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'nextBestActionAgentIdentity'), '2025-04-01').outputs.agentIdentityPrincipalId.value]"
          },
          "federatedCredentialName": {
            "value": "aks-mcp-agent-fed"
          },
          "configurationIdentityResourceId": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity'), '2025-04-01').outputs.identityId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "11931322277500981369"
            }
          },
          "parameters": {
            "aksClusterName": {
              "type": "string",
              "metadata": {
                "description": "Name of the AKS cluster"
              }
            },
            "serviceAccountNamespace": {
              "type": "string",
              "metadata": {
                "description": "Namespace for the Kubernetes service account"
              }
            },
            "serviceAccountName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Kubernetes service account"
              }
            },
            "identityClientId": {
              "type": "string",
              "metadata": {
                "description": "App ID (client ID) of the Agent Identity or User Assigned Identity"
              }
            },
            "identityPrincipalId": {
              "type": "string",
              "metadata": {
                "description": "Principal ID of the Agent Identity or User Assigned Identity"
              }
            },
            "federatedCredentialName": {
              "type": "string",
              "metadata": {
                "description": "Name for the federated credential"
              }
            },
            "subjectIdentifier": {
              "type": "string",
              "defaultValue": "[format('system:serviceaccount:{0}:{1}', parameters('serviceAccountNamespace'), parameters('serviceAccountName'))]",
              "metadata": {
                "description": "Subject identifier for the service account (format: system:serviceaccount:namespace:serviceAccountName)"
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Location for deployment scripts"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for resources"
              }
            },
            "configurationIdentityResourceId": {
              "type": "string",
              "metadata": {
                "description": "Resource ID of a managed identity with permissions to configure federated credentials"
              }
            }
          },
          "variables": {
            "deploymentScriptName": "[format('ds-fed-cred-{0}', uniqueString(parameters('identityClientId'), parameters('serviceAccountName')))]"
          },
          "resources": [
            {
              "type": "Microsoft.Resources/deploymentScripts",
              "apiVersion": "2023-08-01",
              "name": "[variables('deploymentScriptName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "kind": "AzurePowerShell",
              "identity": {
                "type": "UserAssigned",
                "userAssignedIdentities": {
                  "[format('{0}', parameters('configurationIdentityResourceId'))]": {}
                }
              },
              "properties": {
                "azPowerShellVersion": "12.0",
                "timeout": "PT30M",
                "retentionInterval": "P1D",
                "cleanupPreference": "OnSuccess",
                "arguments": "[format('-IdentityPrincipalId \"{0}\" -FederatedCredentialName \"{1}\" -OidcIssuerUrl \"{2}\" -Subject \"{3}\"', parameters('identityPrincipalId'), parameters('federatedCredentialName'), reference(resourceId('Microsoft.ContainerService/managedClusters', parameters('aksClusterName')), '2024-02-01').oidcIssuerProfile.issuerURL, parameters('subjectIdentifier'))]",
                "scriptContent": "      param(\n        [string]$IdentityPrincipalId,\n        [string]$FederatedCredentialName,\n        [string]$OidcIssuerUrl,\n        [string]$Subject\n      )\n\n      # Install Microsoft.Graph modules if needed\n      $modules = @('Microsoft.Graph.Authentication', 'Microsoft.Graph.Applications')\n      foreach ($module in $modules) {\n        if (-not (Get-Module -ListAvailable -Name $module)) {\n          Install-Module -Name $module -Force -Scope CurrentUser -AllowClobber\n        }\n        Import-Module $module -Force\n      }\n\n      # Connect to Microsoft Graph using managed identity\n      Connect-MgGraph -Identity -NoWelcome\n\n      # Get the service principal (agent identity)\n      $sp = Get-MgServicePrincipal -ServicePrincipalId $IdentityPrincipalId -ErrorAction SilentlyContinue\n\n      if (-not $sp) {\n        Write-Error \"Service Principal not found with ID: $IdentityPrincipalId\"\n        throw \"Service principal not found\"\n      }\n\n      # Get the associated application\n      $app = Get-MgApplication -Filter \"appId eq '$($sp.AppId)'\" -ErrorAction SilentlyContinue\n\n      if (-not $app) {\n        # For agent identities, the federated credential is added to the blueprint, not the agent identity itself\n        # Try to get the blueprint application\n        Write-Host \"Application not found for service principal. Agent identities inherit credentials from their blueprint.\"\n        Write-Host \"Skipping federated credential creation - ensure the blueprint has appropriate credentials configured.\"\n        \n        $DeploymentScriptOutputs = @{}\n        $DeploymentScriptOutputs['status'] = 'skipped'\n        $DeploymentScriptOutputs['message'] = 'Agent identities use blueprint credentials'\n        return\n      }\n\n      # Check if federated credential already exists\n      $existingCreds = Get-MgApplicationFederatedIdentityCredential -ApplicationId $app.Id -ErrorAction SilentlyContinue\n      $existingCred = $existingCreds | Where-Object { $_.Name -eq $FederatedCredentialName }\n\n      if ($existingCred) {\n        Write-Host \"Federated credential '$FederatedCredentialName' already exists\"\n        $DeploymentScriptOutputs = @{}\n        $DeploymentScriptOutputs['status'] = 'exists'\n        $DeploymentScriptOutputs['credentialId'] = $existingCred.Id\n        return\n      }\n\n      # Create federated identity credential\n      $credBody = @{\n        name = $FederatedCredentialName\n        issuer = $OidcIssuerUrl\n        subject = $Subject\n        audiences = @('api://AzureADTokenExchange')\n        description = \"AKS Workload Identity for MCP Agent\"\n      }\n\n      try {\n        $headers = @{\n          'OData-Version' = '4.0'\n          'Content-Type' = 'application/json'\n        }\n        \n        $newCred = Invoke-MgGraphRequest -Method POST -Uri \"https://graph.microsoft.com/beta/applications/$($app.Id)/federatedIdentityCredentials\" -Body ($credBody | ConvertTo-Json) -Headers $headers\n        Write-Host \"Created federated identity credential: $FederatedCredentialName\"\n        \n        $DeploymentScriptOutputs = @{}\n        $DeploymentScriptOutputs['status'] = 'created'\n        $DeploymentScriptOutputs['credentialId'] = $newCred.id\n      } catch {\n        Write-Error \"Failed to create federated identity credential: $_\"\n        throw\n      }\n    "
              }
            }
          ],
          "outputs": {
            "oidcIssuerUrl": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.ContainerService/managedClusters', parameters('aksClusterName')), '2024-02-01').oidcIssuerProfile.issuerURL]"
            },
            "subjectIdentifier": {
              "type": "string",
              "value": "[parameters('subjectIdentifier')]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'aksCluster')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'nextBestActionAgentIdentity')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "storage",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "name": "[if(not(empty(parameters('storageAccountName'))), createObject('value', parameters('storageAccountName')), createObject('value', format('{0}{1}', variables('abbrs').storageStorageAccounts, variables('resourceToken'))))]",
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "containers": {
            "value": [
              {
                "name": "[variables('deploymentStorageContainerName')]"
              },
              {
                "name": "snippets"
              }
            ]
          },
          "publicNetworkAccess": "[if(parameters('vnetEnabled'), createObject('value', 'Disabled'), createObject('value', 'Enabled'))]",
          "networkAcls": "[if(not(parameters('vnetEnabled')), createObject('value', createObject()), createObject('value', createObject('defaultAction', 'Deny')))]",
          "allowSharedKeyAccess": {
            "value": true
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "11821237599742914072"
            }
          },
          "parameters": {
            "name": {
              "type": "string"
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]"
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            },
            "allowBlobPublicAccess": {
              "type": "bool",
              "defaultValue": false
            },
            "publicNetworkAccess": {
              "type": "string",
              "defaultValue": "Enabled",
              "allowedValues": [
                "Enabled",
                "Disabled"
              ]
            },
            "containers": {
              "type": "array",
              "defaultValue": []
            },
            "kind": {
              "type": "string",
              "defaultValue": "StorageV2"
            },
            "minimumTlsVersion": {
              "type": "string",
              "defaultValue": "TLS1_2"
            },
            "sku": {
              "type": "object",
              "defaultValue": {
                "name": "Standard_LRS"
              }
            },
            "networkAcls": {
              "type": "object",
              "defaultValue": {
                "bypass": "AzureServices",
                "defaultAction": "Allow"
              }
            },
            "allowSharedKeyAccess": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Controls whether Shared Key authorization is permitted. Leave disabled to enforce managed identity only access."
              }
            }
          },
          "resources": [
            {
              "copy": {
                "name": "storage::blobServices::container",
                "count": "[length(parameters('containers'))]"
              },
              "condition": "[not(empty(parameters('containers')))]",
              "type": "Microsoft.Storage/storageAccounts/blobServices/containers",
              "apiVersion": "2023-01-01",
              "name": "[format('{0}/{1}/{2}', parameters('name'), 'default', parameters('containers')[copyIndex()].name)]",
              "properties": {
                "publicAccess": "[coalesce(tryGet(parameters('containers')[copyIndex()], 'publicAccess'), 'None')]"
              },
              "dependsOn": [
                "[resourceId('Microsoft.Storage/storageAccounts/blobServices', parameters('name'), 'default')]"
              ]
            },
            {
              "condition": "[not(empty(parameters('containers')))]",
              "type": "Microsoft.Storage/storageAccounts/blobServices",
              "apiVersion": "2023-01-01",
              "name": "[format('{0}/{1}', parameters('name'), 'default')]",
              "dependsOn": [
                "[resourceId('Microsoft.Storage/storageAccounts', parameters('name'))]"
              ]
            },
            {
              "type": "Microsoft.Storage/storageAccounts",
              "apiVersion": "2023-01-01",
              "name": "[parameters('name')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "kind": "[parameters('kind')]",
              "sku": "[parameters('sku')]",
              "properties": {
                "minimumTlsVersion": "[parameters('minimumTlsVersion')]",
                "allowBlobPublicAccess": "[parameters('allowBlobPublicAccess')]",
                "publicNetworkAccess": "[parameters('publicNetworkAccess')]",
                "allowSharedKeyAccess": "[parameters('allowSharedKeyAccess')]",
                "networkAcls": "[parameters('networkAcls')]"
              }
            }
          ],
          "outputs": {
            "name": {
              "type": "string",
              "value": "[parameters('name')]"
            },
            "primaryEndpoints": {
              "type": "object",
              "value": "[reference(resourceId('Microsoft.Storage/storageAccounts', parameters('name')), '2023-01-01').primaryEndpoints]"
            }
          }
        }
      },
      "dependsOn": [
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "blobRoleAssignmentMcp",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "storageAccountName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'storage'), '2025-04-01').outputs.name.value]"
          },
          "roleDefinitionID": {
            "value": "[variables('StorageBlobDataOwner')]"
          },
          "principalID": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity'), '2025-04-01').outputs.identityPrincipalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "9036671573385799596"
            }
          },
          "parameters": {
            "principalID": {
              "type": "string"
            },
            "roleDefinitionID": {
              "type": "string"
            },
            "storageAccountName": {
              "type": "string"
            },
            "nameSuffix": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Optional suffix to make role assignment name unique across deployments"
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName'))]",
              "name": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalId": "[parameters('principalID')]",
                "principalType": "ServicePrincipal"
              }
            }
          ],
          "outputs": {
            "ROLE_ASSIGNMENT_NAME": {
              "type": "string",
              "value": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'storage')]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "queueRoleAssignmentMcp",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "storageAccountName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'storage'), '2025-04-01').outputs.name.value]"
          },
          "roleDefinitionID": {
            "value": "[variables('StorageQueueDataContributor')]"
          },
          "principalID": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity'), '2025-04-01').outputs.identityPrincipalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "9036671573385799596"
            }
          },
          "parameters": {
            "principalID": {
              "type": "string"
            },
            "roleDefinitionID": {
              "type": "string"
            },
            "storageAccountName": {
              "type": "string"
            },
            "nameSuffix": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Optional suffix to make role assignment name unique across deployments"
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName'))]",
              "name": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalId": "[parameters('principalID')]",
                "principalType": "ServicePrincipal"
              }
            }
          ],
          "outputs": {
            "ROLE_ASSIGNMENT_NAME": {
              "type": "string",
              "value": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'storage')]"
      ]
    },
    {
      "condition": "[parameters('vnetEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "serviceVirtualNetwork",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "vNetName": {
            "value": "[variables('serviceVirtualNetworkName')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "3111291406551580618"
            }
          },
          "parameters": {
            "vNetName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the virtual network."
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Specifies the location."
              }
            },
            "peSubnetName": {
              "type": "string",
              "defaultValue": "private-endpoints-subnet",
              "metadata": {
                "description": "Specifies the name of the subnet for the Service Bus private endpoint."
              }
            },
            "appSubnetName": {
              "type": "string",
              "defaultValue": "app",
              "metadata": {
                "description": "Specifies the name of the subnet for Function App virtual network integration."
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            }
          },
          "resources": [
            {
              "type": "Microsoft.Network/virtualNetworks",
              "apiVersion": "2023-05-01",
              "name": "[parameters('vNetName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "addressSpace": {
                  "addressPrefixes": [
                    "10.0.0.0/16"
                  ]
                },
                "encryption": {
                  "enabled": false,
                  "enforcement": "AllowUnencrypted"
                },
                "subnets": [
                  {
                    "name": "[parameters('peSubnetName')]",
                    "id": "[resourceId('Microsoft.Network/virtualNetworks/subnets', parameters('vNetName'), 'private-endpoints-subnet')]",
                    "properties": {
                      "addressPrefixes": [
                        "10.0.1.0/24"
                      ],
                      "delegations": [],
                      "privateEndpointNetworkPolicies": "Disabled",
                      "privateLinkServiceNetworkPolicies": "Enabled"
                    },
                    "type": "Microsoft.Network/virtualNetworks/subnets"
                  },
                  {
                    "name": "[parameters('appSubnetName')]",
                    "id": "[resourceId('Microsoft.Network/virtualNetworks/subnets', parameters('vNetName'), 'app')]",
                    "properties": {
                      "addressPrefixes": [
                        "10.0.2.0/24"
                      ],
                      "delegations": [],
                      "privateEndpointNetworkPolicies": "Disabled",
                      "privateLinkServiceNetworkPolicies": "Enabled"
                    },
                    "type": "Microsoft.Network/virtualNetworks/subnets"
                  }
                ],
                "virtualNetworkPeerings": [],
                "enableDdosProtection": false
              }
            }
          ],
          "outputs": {
            "peSubnetName": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Network/virtualNetworks', parameters('vNetName')), '2023-05-01').subnets[0].name]"
            },
            "peSubnetID": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Network/virtualNetworks', parameters('vNetName')), '2023-05-01').subnets[0].id]"
            },
            "appSubnetName": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Network/virtualNetworks', parameters('vNetName')), '2023-05-01').subnets[1].name]"
            },
            "appSubnetID": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Network/virtualNetworks', parameters('vNetName')), '2023-05-01').subnets[1].id]"
            }
          }
        }
      },
      "dependsOn": [
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "condition": "[parameters('vnetEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "servicePrivateEndpoint",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "virtualNetworkName": {
            "value": "[variables('serviceVirtualNetworkName')]"
          },
          "subnetName": "[if(parameters('vnetEnabled'), createObject('value', variables('serviceVirtualNetworkPrivateEndpointSubnetName')), createObject('value', ''))]",
          "resourceName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'storage'), '2025-04-01').outputs.name.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "15585570690045108483"
            }
          },
          "parameters": {
            "virtualNetworkName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the virtual network."
              }
            },
            "subnetName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the subnet which contains the virtual machine."
              }
            },
            "resourceName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the resource name of the Storage resource with an endpoint."
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Specifies the location."
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            }
          },
          "variables": {
            "blobPrivateDNSZoneName": "[format('privatelink.blob.{0}', environment().suffixes.storage)]",
            "blobPrivateDnsZoneVirtualNetworkLinkName": "[format('{0}-blob-link-{1}', parameters('resourceName'), take(toLower(uniqueString(parameters('resourceName'), parameters('virtualNetworkName'))), 4))]",
            "queuePrivateDNSZoneName": "[format('privatelink.queue.{0}', environment().suffixes.storage)]",
            "queuePrivateDnsZoneVirtualNetworkLinkName": "[format('{0}-queue-link-{1}', parameters('resourceName'), take(toLower(uniqueString(parameters('resourceName'), parameters('virtualNetworkName'))), 4))]"
          },
          "resources": [
            {
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2020-06-01",
              "name": "[variables('blobPrivateDNSZoneName')]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {}
            },
            {
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2020-06-01",
              "name": "[variables('queuePrivateDNSZoneName')]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {}
            },
            {
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('blobPrivateDNSZoneName'), variables('blobPrivateDnsZoneVirtualNetworkLinkName'))]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.Network/privateDnsZones', variables('blobPrivateDNSZoneName'))]"
              ]
            },
            {
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('queuePrivateDNSZoneName'), variables('queuePrivateDnsZoneVirtualNetworkLinkName'))]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.Network/privateDnsZones', variables('queuePrivateDNSZoneName'))]"
              ]
            },
            {
              "type": "Microsoft.Network/privateEndpoints",
              "apiVersion": "2021-08-01",
              "name": "blob-private-endpoint",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "privateLinkServiceConnections": [
                  {
                    "name": "blobPrivateLinkConnection",
                    "properties": {
                      "privateLinkServiceId": "[resourceId('Microsoft.Storage/storageAccounts', parameters('resourceName'))]",
                      "groupIds": [
                        "blob"
                      ]
                    }
                  }
                ],
                "subnet": {
                  "id": "[format('{0}/subnets/{1}', resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName')), parameters('subnetName'))]"
                }
              }
            },
            {
              "type": "Microsoft.Network/privateEndpoints/privateDnsZoneGroups",
              "apiVersion": "2022-01-01",
              "name": "[format('{0}/{1}', 'blob-private-endpoint', 'blobPrivateDnsZoneGroup')]",
              "properties": {
                "privateDnsZoneConfigs": [
                  {
                    "name": "storageBlobARecord",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('blobPrivateDNSZoneName'))]"
                    }
                  }
                ]
              },
              "dependsOn": [
                "[resourceId('Microsoft.Network/privateDnsZones', variables('blobPrivateDNSZoneName'))]",
                "[resourceId('Microsoft.Network/privateEndpoints', 'blob-private-endpoint')]"
              ]
            },
            {
              "type": "Microsoft.Network/privateEndpoints",
              "apiVersion": "2021-08-01",
              "name": "queue-private-endpoint",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "privateLinkServiceConnections": [
                  {
                    "name": "queuePrivateLinkConnection",
                    "properties": {
                      "privateLinkServiceId": "[resourceId('Microsoft.Storage/storageAccounts', parameters('resourceName'))]",
                      "groupIds": [
                        "queue"
                      ]
                    }
                  }
                ],
                "subnet": {
                  "id": "[format('{0}/subnets/{1}', resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName')), parameters('subnetName'))]"
                }
              }
            },
            {
              "type": "Microsoft.Network/privateEndpoints/privateDnsZoneGroups",
              "apiVersion": "2022-01-01",
              "name": "[format('{0}/{1}', 'queue-private-endpoint', 'queuePrivateDnsZoneGroup')]",
              "properties": {
                "privateDnsZoneConfigs": [
                  {
                    "name": "storageQueueARecord",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('queuePrivateDNSZoneName'))]"
                    }
                  }
                ]
              },
              "dependsOn": [
                "[resourceId('Microsoft.Network/privateDnsZones', variables('queuePrivateDNSZoneName'))]",
                "[resourceId('Microsoft.Network/privateEndpoints', 'queue-private-endpoint')]"
              ]
            }
          ]
        }
      },
      "dependsOn": [
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'serviceVirtualNetwork')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'storage')]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "foundry",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "foundryName": {
            "value": "[variables('foundryResourceName')]"
          },
          "bingName": {
            "value": "[variables('bingResourceName')]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "modelDeploymentName": {
            "value": "[parameters('foundryModelDeploymentName')]"
          },
          "modelName": {
            "value": "[parameters('foundryModelName')]"
          },
          "modelVersion": {
            "value": "[parameters('foundryModelVersion')]"
          },
          "modelCapacity": {
            "value": "[parameters('foundryModelCapacity')]"
          },
          "embeddingModelDeploymentName": {
            "value": "[parameters('embeddingModelDeploymentName')]"
          },
          "embeddingModelName": {
            "value": "[parameters('embeddingModelName')]"
          },
          "embeddingModelVersion": {
            "value": "[parameters('embeddingModelVersion')]"
          },
          "embeddingModelCapacity": {
            "value": "[parameters('embeddingModelCapacity')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "enablePrivateEndpoint": {
            "value": "[parameters('vnetEnabled')]"
          },
          "publicNetworkAccess": "[if(parameters('vnetEnabled'), createObject('value', 'Disabled'), createObject('value', 'Enabled'))]"
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "11267850484169273686"
            }
          },
          "parameters": {
            "foundryName": {
              "type": "string",
              "metadata": {
                "description": "Name of the foundry resource"
              }
            },
            "bingName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Bing Grounding resource"
              }
            },
            "location": {
              "type": "string",
              "metadata": {
                "description": "Location for all resources"
              }
            },
            "modelDeploymentName": {
              "type": "string",
              "metadata": {
                "description": "Model deployment name"
              }
            },
            "modelName": {
              "type": "string",
              "metadata": {
                "description": "Model name"
              }
            },
            "modelVersion": {
              "type": "string",
              "metadata": {
                "description": "Model version"
              }
            },
            "modelCapacity": {
              "type": "int",
              "metadata": {
                "description": "Model capacity"
              }
            },
            "embeddingModelDeploymentName": {
              "type": "string",
              "defaultValue": "text-embedding-3-large",
              "metadata": {
                "description": "Embedding model deployment name"
              }
            },
            "embeddingModelName": {
              "type": "string",
              "defaultValue": "text-embedding-3-large",
              "metadata": {
                "description": "Embedding model name"
              }
            },
            "embeddingModelVersion": {
              "type": "string",
              "defaultValue": "1",
              "metadata": {
                "description": "Embedding model version"
              }
            },
            "embeddingModelCapacity": {
              "type": "int",
              "defaultValue": 10,
              "metadata": {
                "description": "Embedding model capacity"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for resources"
              }
            },
            "enablePrivateEndpoint": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enable private endpoint"
              }
            },
            "publicNetworkAccess": {
              "type": "string",
              "defaultValue": "Enabled",
              "metadata": {
                "description": "Public network access setting"
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.Bing/accounts",
              "apiVersion": "2020-06-10",
              "name": "[parameters('bingName')]",
              "location": "global",
              "sku": {
                "name": "G1"
              },
              "kind": "Bing.Grounding",
              "properties": {
                "statisticsEnabled": false
              }
            },
            {
              "type": "Microsoft.CognitiveServices/accounts",
              "apiVersion": "2025-06-01",
              "name": "[parameters('foundryName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "sku": {
                "name": "S0"
              },
              "kind": "AIServices",
              "identity": {
                "type": "SystemAssigned"
              },
              "properties": {
                "apiProperties": {},
                "customSubDomainName": "[parameters('foundryName')]",
                "networkAcls": {
                  "defaultAction": "[if(parameters('enablePrivateEndpoint'), 'Deny', 'Allow')]",
                  "virtualNetworkRules": [],
                  "ipRules": []
                },
                "allowProjectManagement": true,
                "defaultProject": "proj-default",
                "associatedProjects": [
                  "proj-default"
                ],
                "publicNetworkAccess": "[parameters('publicNetworkAccess')]",
                "disableLocalAuth": true
              }
            },
            {
              "type": "Microsoft.CognitiveServices/accounts/capabilityHosts",
              "apiVersion": "2025-06-01",
              "name": "[format('{0}/{1}', parameters('foundryName'), 'Agents')]",
              "properties": {
                "capabilityHostKind": "Agents"
              },
              "dependsOn": [
                "[resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryName'))]"
              ]
            },
            {
              "type": "Microsoft.CognitiveServices/accounts/deployments",
              "apiVersion": "2025-06-01",
              "name": "[format('{0}/{1}', parameters('foundryName'), parameters('modelDeploymentName'))]",
              "sku": {
                "name": "GlobalStandard",
                "capacity": "[parameters('modelCapacity')]"
              },
              "properties": {
                "model": {
                  "format": "OpenAI",
                  "name": "[parameters('modelName')]",
                  "version": "[parameters('modelVersion')]"
                },
                "versionUpgradeOption": "OnceNewDefaultVersionAvailable",
                "currentCapacity": "[parameters('modelCapacity')]",
                "raiPolicyName": "Microsoft.DefaultV2"
              },
              "dependsOn": [
                "[resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryName'))]"
              ]
            },
            {
              "type": "Microsoft.CognitiveServices/accounts/deployments",
              "apiVersion": "2025-06-01",
              "name": "[format('{0}/{1}', parameters('foundryName'), parameters('embeddingModelDeploymentName'))]",
              "sku": {
                "name": "Standard",
                "capacity": "[parameters('embeddingModelCapacity')]"
              },
              "properties": {
                "model": {
                  "format": "OpenAI",
                  "name": "[parameters('embeddingModelName')]",
                  "version": "[parameters('embeddingModelVersion')]"
                },
                "versionUpgradeOption": "OnceNewDefaultVersionAvailable",
                "currentCapacity": "[parameters('embeddingModelCapacity')]",
                "raiPolicyName": "Microsoft.DefaultV2"
              },
              "dependsOn": [
                "[resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryName'))]",
                "[resourceId('Microsoft.CognitiveServices/accounts/deployments', parameters('foundryName'), parameters('modelDeploymentName'))]"
              ]
            },
            {
              "type": "Microsoft.CognitiveServices/accounts/projects",
              "apiVersion": "2025-06-01",
              "name": "[format('{0}/{1}', parameters('foundryName'), 'proj-default')]",
              "location": "[parameters('location')]",
              "kind": "AIServices",
              "identity": {
                "type": "SystemAssigned"
              },
              "properties": {
                "description": "Default project for web summarization with Bing grounding",
                "displayName": "proj-default"
              },
              "dependsOn": [
                "[resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryName'))]"
              ]
            },
            {
              "type": "Microsoft.CognitiveServices/accounts/projects/connections",
              "apiVersion": "2025-06-01",
              "name": "[format('{0}/{1}/{2}', parameters('foundryName'), 'proj-default', parameters('bingName'))]",
              "properties": {
                "authType": "ApiKey",
                "category": "ApiKey",
                "target": "https://api.bing.microsoft.com/",
                "credentials": {
                  "key": "[listKeys(resourceId('Microsoft.Bing/accounts', parameters('bingName')), '2020-06-10').key1]"
                },
                "useWorkspaceManagedIdentity": false,
                "isSharedToAll": false,
                "sharedUserList": [],
                "peRequirement": "NotRequired",
                "peStatus": "NotApplicable",
                "metadata": {
                  "type": "bing_grounding",
                  "ApiType": "Azure",
                  "ResourceId": "[resourceId('Microsoft.Bing/accounts', parameters('bingName'))]"
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.Bing/accounts', parameters('bingName'))]",
                "[resourceId('Microsoft.CognitiveServices/accounts/projects', parameters('foundryName'), 'proj-default')]"
              ]
            }
          ],
          "outputs": {
            "foundryAccountId": {
              "type": "string",
              "value": "[resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryName'))]"
            },
            "foundryAccountName": {
              "type": "string",
              "value": "[parameters('foundryName')]"
            },
            "foundryEndpoint": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryName')), '2025-06-01').endpoint]"
            },
            "projectId": {
              "type": "string",
              "value": "[resourceId('Microsoft.CognitiveServices/accounts/projects', parameters('foundryName'), 'proj-default')]"
            },
            "projectEndpoint": {
              "type": "string",
              "value": "[format('https://{0}.services.ai.azure.com/api/projects/proj-default', parameters('foundryName'))]"
            },
            "bingConnectionId": {
              "type": "string",
              "value": "[resourceId('Microsoft.CognitiveServices/accounts/projects/connections', parameters('foundryName'), 'proj-default', parameters('bingName'))]"
            },
            "bingConnectionName": {
              "type": "string",
              "value": "[parameters('bingName')]"
            },
            "bingResourceId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Bing/accounts', parameters('bingName'))]"
            },
            "modelDeploymentName": {
              "type": "string",
              "value": "[parameters('modelDeploymentName')]"
            },
            "embeddingModelDeploymentName": {
              "type": "string",
              "value": "[parameters('embeddingModelDeploymentName')]"
            }
          }
        }
      },
      "dependsOn": [
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "condition": "[parameters('vnetEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "foundryPrivateEndpoint",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "virtualNetworkName": {
            "value": "[variables('serviceVirtualNetworkName')]"
          },
          "subnetName": "[if(parameters('vnetEnabled'), createObject('value', variables('serviceVirtualNetworkPrivateEndpointSubnetName')), createObject('value', ''))]",
          "resourceName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'foundry'), '2025-04-01').outputs.foundryAccountName.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "4976174286386672263"
            }
          },
          "parameters": {
            "virtualNetworkName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the virtual network."
              }
            },
            "subnetName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the subnet which contains the private endpoints."
              }
            },
            "resourceName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the resource name of the Foundry/Cognitive Services resource."
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Specifies the location."
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            }
          },
          "variables": {
            "cognitiveServicesPrivateDNSZoneName": "privatelink.cognitiveservices.azure.com",
            "openAIPrivateDNSZoneName": "privatelink.openai.azure.com",
            "servicesAIPrivateDNSZoneName": "privatelink.services.ai.azure.com",
            "cognitiveServicesDnsZoneLinkName": "[format('{0}-cogservices-link-{1}', parameters('resourceName'), take(toLower(uniqueString(parameters('resourceName'), parameters('virtualNetworkName'))), 4))]",
            "openAIDnsZoneLinkName": "[format('{0}-openai-link-{1}', parameters('resourceName'), take(toLower(uniqueString(parameters('resourceName'), parameters('virtualNetworkName'))), 4))]",
            "servicesAIDnsZoneLinkName": "[format('{0}-servicesai-link-{1}', parameters('resourceName'), take(toLower(uniqueString(parameters('resourceName'), parameters('virtualNetworkName'))), 4))]"
          },
          "resources": [
            {
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2020-06-01",
              "name": "[variables('cognitiveServicesPrivateDNSZoneName')]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {}
            },
            {
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2020-06-01",
              "name": "[variables('openAIPrivateDNSZoneName')]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {}
            },
            {
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2020-06-01",
              "name": "[variables('servicesAIPrivateDNSZoneName')]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {}
            },
            {
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('cognitiveServicesPrivateDNSZoneName'), variables('cognitiveServicesDnsZoneLinkName'))]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.Network/privateDnsZones', variables('cognitiveServicesPrivateDNSZoneName'))]"
              ]
            },
            {
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('openAIPrivateDNSZoneName'), variables('openAIDnsZoneLinkName'))]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.Network/privateDnsZones', variables('openAIPrivateDNSZoneName'))]"
              ]
            },
            {
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('servicesAIPrivateDNSZoneName'), variables('servicesAIDnsZoneLinkName'))]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.Network/privateDnsZones', variables('servicesAIPrivateDNSZoneName'))]"
              ]
            },
            {
              "type": "Microsoft.Network/privateEndpoints",
              "apiVersion": "2021-08-01",
              "name": "[format('pe-{0}-account', parameters('resourceName'))]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "privateLinkServiceConnections": [
                  {
                    "name": "foundryAccountPrivateLinkConnection",
                    "properties": {
                      "privateLinkServiceId": "[resourceId('Microsoft.CognitiveServices/accounts', parameters('resourceName'))]",
                      "groupIds": [
                        "account"
                      ]
                    }
                  }
                ],
                "subnet": {
                  "id": "[format('{0}/subnets/{1}', resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName')), parameters('subnetName'))]"
                }
              }
            },
            {
              "type": "Microsoft.Network/privateEndpoints/privateDnsZoneGroups",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', format('pe-{0}-account', parameters('resourceName')), 'foundryPrivateDnsZoneGroup')]",
              "properties": {
                "privateDnsZoneConfigs": [
                  {
                    "name": "cognitiveservices-config",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('cognitiveServicesPrivateDNSZoneName'))]"
                    }
                  },
                  {
                    "name": "openai-config",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('openAIPrivateDNSZoneName'))]"
                    }
                  },
                  {
                    "name": "servicesai-config",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('servicesAIPrivateDNSZoneName'))]"
                    }
                  }
                ]
              },
              "dependsOn": [
                "[resourceId('Microsoft.Network/privateDnsZones', variables('cognitiveServicesPrivateDNSZoneName'))]",
                "[resourceId('Microsoft.Network/privateEndpoints', format('pe-{0}-account', parameters('resourceName')))]",
                "[resourceId('Microsoft.Network/privateDnsZones', variables('openAIPrivateDNSZoneName'))]",
                "[resourceId('Microsoft.Network/privateDnsZones', variables('servicesAIPrivateDNSZoneName'))]"
              ]
            }
          ],
          "outputs": {
            "privateEndpointId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateEndpoints', format('pe-{0}-account', parameters('resourceName')))]"
            },
            "cognitiveServicesPrivateDnsZoneId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateDnsZones', variables('cognitiveServicesPrivateDNSZoneName'))]"
            },
            "openAIPrivateDnsZoneId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateDnsZones', variables('openAIPrivateDNSZoneName'))]"
            },
            "servicesAIPrivateDnsZoneId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateDnsZones', variables('servicesAIPrivateDNSZoneName'))]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'foundry')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'serviceVirtualNetwork')]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "foundryRoleAssignmentMcp",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "foundryAccountName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'foundry'), '2025-04-01').outputs.foundryAccountName.value]"
          },
          "roleDefinitionID": {
            "value": "[variables('CognitiveServicesOpenAIUser')]"
          },
          "principalID": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity'), '2025-04-01').outputs.identityPrincipalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "9126126239255866509"
            }
          },
          "parameters": {
            "foundryAccountName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Foundry/Cognitive Services account"
              }
            },
            "roleDefinitionID": {
              "type": "string",
              "metadata": {
                "description": "The role definition ID to assign"
              }
            },
            "principalID": {
              "type": "string",
              "metadata": {
                "description": "The principal ID to assign the role to"
              }
            },
            "nameSuffix": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Optional suffix to make role assignment name unique across deployments"
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryAccountName'))]",
              "name": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryAccountName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryAccountName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalId": "[parameters('principalID')]",
                "principalType": "ServicePrincipal"
              }
            }
          ]
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'foundry')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "foundryRoleAssignmentMcpAIDeveloper",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "foundryAccountName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'foundry'), '2025-04-01').outputs.foundryAccountName.value]"
          },
          "roleDefinitionID": {
            "value": "[variables('AzureAIDeveloper')]"
          },
          "principalID": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity'), '2025-04-01').outputs.identityPrincipalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "9126126239255866509"
            }
          },
          "parameters": {
            "foundryAccountName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Foundry/Cognitive Services account"
              }
            },
            "roleDefinitionID": {
              "type": "string",
              "metadata": {
                "description": "The role definition ID to assign"
              }
            },
            "principalID": {
              "type": "string",
              "metadata": {
                "description": "The principal ID to assign the role to"
              }
            },
            "nameSuffix": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Optional suffix to make role assignment name unique across deployments"
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryAccountName'))]",
              "name": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryAccountName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryAccountName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalId": "[parameters('principalID')]",
                "principalType": "ServicePrincipal"
              }
            }
          ]
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'foundry')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "cosmosAccount",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "name": {
            "value": "[variables('cosmosResourceName')]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "enableServerless": {
            "value": true
          },
          "enableVectorSearch": {
            "value": true
          },
          "disableKeyBasedAuth": {
            "value": true
          },
          "ipRules": "[if(not(empty(parameters('developerIpAddress'))), createObject('value', createArray(parameters('developerIpAddress'))), createObject('value', createArray()))]"
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "15222396649450110444"
            },
            "description": "Create an Azure Cosmos DB for NoSQL account."
          },
          "parameters": {
            "name": {
              "type": "string"
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]"
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            },
            "enableServerless": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enables serverless for this account. Defaults to false."
              }
            },
            "disableKeyBasedAuth": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Disables key-based authentication. Defaults to false."
              }
            },
            "enableVectorSearch": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enables vector search for this account. Defaults to false."
              }
            },
            "enableNoSQLFullTextSearch": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enables NoSQL full text search for this account. Defaults to false."
              }
            },
            "ipRules": {
              "type": "array",
              "defaultValue": [],
              "metadata": {
                "description": "IP addresses or CIDR ranges allowed to access the account (for developer access)."
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.Resources/deployments",
              "apiVersion": "2025-04-01",
              "name": "cosmos-db-nosql-account",
              "properties": {
                "expressionEvaluationOptions": {
                  "scope": "inner"
                },
                "mode": "Incremental",
                "parameters": {
                  "name": {
                    "value": "[parameters('name')]"
                  },
                  "location": {
                    "value": "[parameters('location')]"
                  },
                  "tags": {
                    "value": "[parameters('tags')]"
                  },
                  "kind": {
                    "value": "GlobalDocumentDB"
                  },
                  "enableServerless": {
                    "value": "[parameters('enableServerless')]"
                  },
                  "enableNoSQLVectorSearch": {
                    "value": "[parameters('enableVectorSearch')]"
                  },
                  "enableNoSQLFullTextSearch": {
                    "value": "[parameters('enableNoSQLFullTextSearch')]"
                  },
                  "disableKeyBasedAuth": {
                    "value": "[parameters('disableKeyBasedAuth')]"
                  },
                  "ipRules": {
                    "value": "[parameters('ipRules')]"
                  }
                },
                "template": {
                  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
                  "contentVersion": "1.0.0.0",
                  "metadata": {
                    "_generator": {
                      "name": "bicep",
                      "version": "0.40.2.10011",
                      "templateHash": "12681544576585599810"
                    },
                    "description": "Create an Azure Cosmos DB account."
                  },
                  "parameters": {
                    "name": {
                      "type": "string"
                    },
                    "location": {
                      "type": "string",
                      "defaultValue": "[resourceGroup().location]"
                    },
                    "tags": {
                      "type": "object",
                      "defaultValue": {}
                    },
                    "kind": {
                      "type": "string",
                      "defaultValue": "GlobalDocumentDB",
                      "allowedValues": [
                        "GlobalDocumentDB"
                      ],
                      "metadata": {
                        "description": "Sets the kind of account."
                      }
                    },
                    "enableServerless": {
                      "type": "bool",
                      "defaultValue": true,
                      "metadata": {
                        "description": "Enables serverless for this account. Defaults to false."
                      }
                    },
                    "enableNoSQLVectorSearch": {
                      "type": "bool",
                      "defaultValue": false,
                      "metadata": {
                        "description": "Enables NoSQL vector search for this account. Defaults to false."
                      }
                    },
                    "enableNoSQLFullTextSearch": {
                      "type": "bool",
                      "defaultValue": false,
                      "metadata": {
                        "description": "Enables NoSQL full text search for this account. Defaults to false."
                      }
                    },
                    "disableKeyBasedAuth": {
                      "type": "bool",
                      "defaultValue": false,
                      "metadata": {
                        "description": "Disables key-based authentication. Defaults to false."
                      }
                    },
                    "ipRules": {
                      "type": "array",
                      "defaultValue": [],
                      "metadata": {
                        "description": "IP addresses or CIDR ranges allowed to access the account (for developer access)."
                      }
                    }
                  },
                  "resources": [
                    {
                      "type": "Microsoft.DocumentDB/databaseAccounts",
                      "apiVersion": "2024-05-15",
                      "name": "[parameters('name')]",
                      "location": "[parameters('location')]",
                      "tags": "[parameters('tags')]",
                      "kind": "[parameters('kind')]",
                      "properties": {
                        "copy": [
                          {
                            "name": "ipRules",
                            "count": "[length(parameters('ipRules'))]",
                            "input": {
                              "ipAddressOrRange": "[parameters('ipRules')[copyIndex('ipRules')]]"
                            }
                          }
                        ],
                        "consistencyPolicy": {
                          "defaultConsistencyLevel": "Session"
                        },
                        "databaseAccountOfferType": "Standard",
                        "locations": [
                          {
                            "locationName": "[parameters('location')]",
                            "failoverPriority": 0,
                            "isZoneRedundant": false
                          }
                        ],
                        "enableAutomaticFailover": false,
                        "enableMultipleWriteLocations": false,
                        "disableLocalAuth": "[parameters('disableKeyBasedAuth')]",
                        "publicNetworkAccess": "[if(empty(parameters('ipRules')), 'Disabled', 'SecuredByPerimeter')]",
                        "capabilities": "[union(if(parameters('enableServerless'), createArray(createObject('name', 'EnableServerless')), createArray()), if(parameters('enableNoSQLVectorSearch'), createArray(createObject('name', 'EnableNoSQLVectorSearch')), createArray()), if(parameters('enableNoSQLFullTextSearch'), createArray(createObject('name', 'EnableNoSQLFullTextSearch')), createArray()))]"
                      }
                    }
                  ],
                  "outputs": {
                    "endpoint": {
                      "type": "string",
                      "value": "[reference(resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('name')), '2024-05-15').documentEndpoint]"
                    },
                    "name": {
                      "type": "string",
                      "value": "[parameters('name')]"
                    }
                  }
                }
              }
            }
          ],
          "outputs": {
            "endpoint": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Resources/deployments', 'cosmos-db-nosql-account'), '2025-04-01').outputs.endpoint.value]"
            },
            "name": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Resources/deployments', 'cosmos-db-nosql-account'), '2025-04-01').outputs.name.value]"
            }
          }
        }
      },
      "dependsOn": [
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "cosmosDatabase",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "name": {
            "value": "[parameters('cosmosDatabaseName')]"
          },
          "parentAccountName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount'), '2025-04-01').outputs.name.value]"
          },
          "tags": {
            "value": "[variables('tags')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "3793172173489490565"
            },
            "description": "Create an Azure Cosmos DB for NoSQL database."
          },
          "parameters": {
            "name": {
              "type": "string"
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            },
            "parentAccountName": {
              "type": "string",
              "metadata": {
                "description": "Name of the parent Azure Cosmos DB account."
              }
            },
            "setThroughput": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enables throughput setting at this resource level. Defaults to false."
              }
            },
            "autoscale": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enables autoscale. If setThroughput is enabled, defaults to false."
              }
            },
            "throughput": {
              "type": "int",
              "defaultValue": 400,
              "metadata": {
                "description": "The amount of throughput set. If setThroughput is enabled, defaults to 400."
              }
            }
          },
          "variables": {
            "options": "[if(parameters('setThroughput'), if(parameters('autoscale'), createObject('autoscaleSettings', createObject('maxThroughput', parameters('throughput'))), createObject('throughput', parameters('throughput'))), createObject())]"
          },
          "resources": [
            {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}', parameters('parentAccountName'), parameters('name'))]",
              "tags": "[parameters('tags')]",
              "properties": {
                "options": "[variables('options')]",
                "resource": {
                  "id": "[parameters('name')]"
                }
              }
            }
          ],
          "outputs": {
            "name": {
              "type": "string",
              "value": "[parameters('name')]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "cosmosTasksContainer",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "name": {
            "value": "tasks"
          },
          "parentAccountName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount'), '2025-04-01').outputs.name.value]"
          },
          "parentDatabaseName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosDatabase'), '2025-04-01').outputs.name.value]"
          },
          "partitionKeyPaths": {
            "value": [
              "/id"
            ]
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "vectorEmbeddingPolicy": {
            "value": {
              "vectorEmbeddings": [
                {
                  "path": "/embedding",
                  "dataType": "float32",
                  "dimensions": 3072,
                  "distanceFunction": "cosine"
                }
              ]
            }
          },
          "indexingPolicy": {
            "value": {
              "automatic": true,
              "indexingMode": "consistent",
              "includedPaths": [
                {
                  "path": "/*"
                }
              ],
              "excludedPaths": [
                {
                  "path": "/embedding/*"
                }
              ],
              "vectorIndexes": [
                {
                  "path": "/embedding",
                  "type": "quantizedFlat"
                }
              ]
            }
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.0",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "8403318465767338866"
            },
            "description": "Create an Azure Cosmos DB for NoSQL container."
          },
          "parameters": {
            "name": {
              "type": "string"
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            },
            "parentAccountName": {
              "type": "string",
              "metadata": {
                "description": "Name of the parent Azure Cosmos DB account."
              }
            },
            "parentDatabaseName": {
              "type": "string",
              "metadata": {
                "description": "Name of the parent Azure Cosmos DB database."
              }
            },
            "setThroughput": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enables throughput setting at this resource level. Defaults to true."
              }
            },
            "autoscale": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enables autoscale. If setThroughput is enabled, defaults to false."
              }
            },
            "throughput": {
              "type": "int",
              "defaultValue": 400,
              "metadata": {
                "description": "The amount of throughput set. If setThroughput is enabled, defaults to 400."
              }
            },
            "partitionKeyPaths": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "defaultValue": [
                "/id"
              ],
              "metadata": {
                "description": "List of hierarhical partition key paths. Defaults to an array that only contains /id."
              }
            },
            "indexingPolicy": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Optional custom indexing policy for the container."
              }
            },
            "vectorEmbeddingPolicy": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Optional vector embedding policy for the container."
              }
            },
            "fullTextPolicy": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Optional full text policy for the container."
              }
            }
          },
          "variables": {
            "options": "[if(parameters('setThroughput'), if(parameters('autoscale'), createObject('autoscaleSettings', createObject('maxThroughput', parameters('throughput'))), createObject('throughput', parameters('throughput'))), createObject())]"
          },
          "resources": {
            "account": {
              "existing": true,
              "type": "Microsoft.DocumentDB/databaseAccounts",
              "apiVersion": "2024-05-15",
              "name": "[parameters('parentAccountName')]"
            },
            "database": {
              "existing": true,
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}', parameters('parentAccountName'), parameters('parentDatabaseName'))]"
            },
            "container": {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases/containers",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}/{2}', parameters('parentAccountName'), parameters('parentDatabaseName'), parameters('name'))]",
              "tags": "[parameters('tags')]",
              "properties": {
                "options": "[variables('options')]",
                "resource": "[union(createObject('id', parameters('name'), 'partitionKey', createObject('paths', parameters('partitionKeyPaths'), 'kind', 'MultiHash', 'version', 2)), if(not(empty(parameters('indexingPolicy'))), createObject('indexingPolicy', parameters('indexingPolicy')), createObject()), if(not(empty(parameters('vectorEmbeddingPolicy'))), createObject('vectorEmbeddingPolicy', parameters('vectorEmbeddingPolicy')), createObject()), if(not(empty(parameters('fullTextPolicy'))), createObject('fullTextPolicy', parameters('fullTextPolicy')), createObject()))]"
              }
            }
          },
          "outputs": {
            "name": {
              "type": "string",
              "value": "[parameters('name')]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosDatabase')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "cosmosPlansContainer",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "name": {
            "value": "plans"
          },
          "parentAccountName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount'), '2025-04-01').outputs.name.value]"
          },
          "parentDatabaseName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosDatabase'), '2025-04-01').outputs.name.value]"
          },
          "partitionKeyPaths": {
            "value": [
              "/taskId"
            ]
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "indexingPolicy": {
            "value": {
              "automatic": true,
              "indexingMode": "consistent",
              "includedPaths": [
                {
                  "path": "/*"
                }
              ]
            }
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.0",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "8403318465767338866"
            },
            "description": "Create an Azure Cosmos DB for NoSQL container."
          },
          "parameters": {
            "name": {
              "type": "string"
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            },
            "parentAccountName": {
              "type": "string",
              "metadata": {
                "description": "Name of the parent Azure Cosmos DB account."
              }
            },
            "parentDatabaseName": {
              "type": "string",
              "metadata": {
                "description": "Name of the parent Azure Cosmos DB database."
              }
            },
            "setThroughput": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enables throughput setting at this resource level. Defaults to true."
              }
            },
            "autoscale": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enables autoscale. If setThroughput is enabled, defaults to false."
              }
            },
            "throughput": {
              "type": "int",
              "defaultValue": 400,
              "metadata": {
                "description": "The amount of throughput set. If setThroughput is enabled, defaults to 400."
              }
            },
            "partitionKeyPaths": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "defaultValue": [
                "/id"
              ],
              "metadata": {
                "description": "List of hierarhical partition key paths. Defaults to an array that only contains /id."
              }
            },
            "indexingPolicy": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Optional custom indexing policy for the container."
              }
            },
            "vectorEmbeddingPolicy": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Optional vector embedding policy for the container."
              }
            },
            "fullTextPolicy": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Optional full text policy for the container."
              }
            }
          },
          "variables": {
            "options": "[if(parameters('setThroughput'), if(parameters('autoscale'), createObject('autoscaleSettings', createObject('maxThroughput', parameters('throughput'))), createObject('throughput', parameters('throughput'))), createObject())]"
          },
          "resources": {
            "account": {
              "existing": true,
              "type": "Microsoft.DocumentDB/databaseAccounts",
              "apiVersion": "2024-05-15",
              "name": "[parameters('parentAccountName')]"
            },
            "database": {
              "existing": true,
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}', parameters('parentAccountName'), parameters('parentDatabaseName'))]"
            },
            "container": {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases/containers",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}/{2}', parameters('parentAccountName'), parameters('parentDatabaseName'), parameters('name'))]",
              "tags": "[parameters('tags')]",
              "properties": {
                "options": "[variables('options')]",
                "resource": "[union(createObject('id', parameters('name'), 'partitionKey', createObject('paths', parameters('partitionKeyPaths'), 'kind', 'MultiHash', 'version', 2)), if(not(empty(parameters('indexingPolicy'))), createObject('indexingPolicy', parameters('indexingPolicy')), createObject()), if(not(empty(parameters('vectorEmbeddingPolicy'))), createObject('vectorEmbeddingPolicy', parameters('vectorEmbeddingPolicy')), createObject()), if(not(empty(parameters('fullTextPolicy'))), createObject('fullTextPolicy', parameters('fullTextPolicy')), createObject()))]"
              }
            }
          },
          "outputs": {
            "name": {
              "type": "string",
              "value": "[parameters('name')]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosDatabase')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "cosmosShortTermMemoryContainer",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "name": {
            "value": "short_term_memory"
          },
          "parentAccountName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount'), '2025-04-01').outputs.name.value]"
          },
          "parentDatabaseName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosDatabase'), '2025-04-01').outputs.name.value]"
          },
          "partitionKeyPaths": {
            "value": [
              "/session_id"
            ]
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "vectorEmbeddingPolicy": {
            "value": {
              "vectorEmbeddings": [
                {
                  "path": "/embedding",
                  "dataType": "float32",
                  "dimensions": 3072,
                  "distanceFunction": "cosine"
                }
              ]
            }
          },
          "indexingPolicy": {
            "value": {
              "automatic": true,
              "indexingMode": "consistent",
              "includedPaths": [
                {
                  "path": "/*"
                }
              ],
              "excludedPaths": [
                {
                  "path": "/embedding/*"
                }
              ],
              "vectorIndexes": [
                {
                  "path": "/embedding",
                  "type": "quantizedFlat"
                }
              ]
            }
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.0",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "8403318465767338866"
            },
            "description": "Create an Azure Cosmos DB for NoSQL container."
          },
          "parameters": {
            "name": {
              "type": "string"
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            },
            "parentAccountName": {
              "type": "string",
              "metadata": {
                "description": "Name of the parent Azure Cosmos DB account."
              }
            },
            "parentDatabaseName": {
              "type": "string",
              "metadata": {
                "description": "Name of the parent Azure Cosmos DB database."
              }
            },
            "setThroughput": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enables throughput setting at this resource level. Defaults to true."
              }
            },
            "autoscale": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enables autoscale. If setThroughput is enabled, defaults to false."
              }
            },
            "throughput": {
              "type": "int",
              "defaultValue": 400,
              "metadata": {
                "description": "The amount of throughput set. If setThroughput is enabled, defaults to 400."
              }
            },
            "partitionKeyPaths": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "defaultValue": [
                "/id"
              ],
              "metadata": {
                "description": "List of hierarhical partition key paths. Defaults to an array that only contains /id."
              }
            },
            "indexingPolicy": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Optional custom indexing policy for the container."
              }
            },
            "vectorEmbeddingPolicy": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Optional vector embedding policy for the container."
              }
            },
            "fullTextPolicy": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Optional full text policy for the container."
              }
            }
          },
          "variables": {
            "options": "[if(parameters('setThroughput'), if(parameters('autoscale'), createObject('autoscaleSettings', createObject('maxThroughput', parameters('throughput'))), createObject('throughput', parameters('throughput'))), createObject())]"
          },
          "resources": {
            "account": {
              "existing": true,
              "type": "Microsoft.DocumentDB/databaseAccounts",
              "apiVersion": "2024-05-15",
              "name": "[parameters('parentAccountName')]"
            },
            "database": {
              "existing": true,
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}', parameters('parentAccountName'), parameters('parentDatabaseName'))]"
            },
            "container": {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases/containers",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}/{2}', parameters('parentAccountName'), parameters('parentDatabaseName'), parameters('name'))]",
              "tags": "[parameters('tags')]",
              "properties": {
                "options": "[variables('options')]",
                "resource": "[union(createObject('id', parameters('name'), 'partitionKey', createObject('paths', parameters('partitionKeyPaths'), 'kind', 'MultiHash', 'version', 2)), if(not(empty(parameters('indexingPolicy'))), createObject('indexingPolicy', parameters('indexingPolicy')), createObject()), if(not(empty(parameters('vectorEmbeddingPolicy'))), createObject('vectorEmbeddingPolicy', parameters('vectorEmbeddingPolicy')), createObject()), if(not(empty(parameters('fullTextPolicy'))), createObject('fullTextPolicy', parameters('fullTextPolicy')), createObject()))]"
              }
            }
          },
          "outputs": {
            "name": {
              "type": "string",
              "value": "[parameters('name')]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosDatabase')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "lightningCosmos",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "parentAccountName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount'), '2025-04-01').outputs.name.value]"
          },
          "databaseName": {
            "value": "agent_rl"
          },
          "tags": {
            "value": "[variables('tags')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "7340452622311462920"
            }
          },
          "parameters": {
            "parentAccountName": {
              "type": "string",
              "metadata": {
                "description": "Name of the parent Azure Cosmos DB account."
              }
            },
            "databaseName": {
              "type": "string",
              "defaultValue": "agent_rl",
              "metadata": {
                "description": "Name of the Lightning database (default: agent_rl)."
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for all resources."
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}', parameters('parentAccountName'), parameters('databaseName'))]",
              "tags": "[parameters('tags')]",
              "properties": {
                "resource": {
                  "id": "[parameters('databaseName')]"
                }
              }
            },
            {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases/containers",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}/{2}', parameters('parentAccountName'), parameters('databaseName'), 'rl_episodes')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "resource": {
                  "id": "rl_episodes",
                  "partitionKey": {
                    "paths": [
                      "/agent_id"
                    ],
                    "kind": "Hash",
                    "version": 2
                  },
                  "indexingPolicy": {
                    "automatic": true,
                    "indexingMode": "consistent",
                    "includedPaths": [
                      {
                        "path": "/*"
                      }
                    ],
                    "excludedPaths": [
                      {
                        "path": "/\"_etag\"/?"
                      }
                    ]
                  },
                  "defaultTtl": -1
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.DocumentDB/databaseAccounts/sqlDatabases', parameters('parentAccountName'), parameters('databaseName'))]"
              ]
            },
            {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases/containers",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}/{2}', parameters('parentAccountName'), parameters('databaseName'), 'rl_rewards')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "resource": {
                  "id": "rl_rewards",
                  "partitionKey": {
                    "paths": [
                      "/agent_id"
                    ],
                    "kind": "Hash",
                    "version": 2
                  },
                  "indexingPolicy": {
                    "automatic": true,
                    "indexingMode": "consistent",
                    "includedPaths": [
                      {
                        "path": "/*"
                      }
                    ],
                    "excludedPaths": [
                      {
                        "path": "/\"_etag\"/?"
                      }
                    ]
                  }
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.DocumentDB/databaseAccounts/sqlDatabases', parameters('parentAccountName'), parameters('databaseName'))]"
              ]
            },
            {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases/containers",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}/{2}', parameters('parentAccountName'), parameters('databaseName'), 'rl_datasets')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "resource": {
                  "id": "rl_datasets",
                  "partitionKey": {
                    "paths": [
                      "/agent_id"
                    ],
                    "kind": "Hash",
                    "version": 2
                  },
                  "indexingPolicy": {
                    "automatic": true,
                    "indexingMode": "consistent",
                    "includedPaths": [
                      {
                        "path": "/*"
                      }
                    ],
                    "excludedPaths": [
                      {
                        "path": "/\"_etag\"/?"
                      }
                    ]
                  }
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.DocumentDB/databaseAccounts/sqlDatabases', parameters('parentAccountName'), parameters('databaseName'))]"
              ]
            },
            {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases/containers",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}/{2}', parameters('parentAccountName'), parameters('databaseName'), 'rl_training_runs')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "resource": {
                  "id": "rl_training_runs",
                  "partitionKey": {
                    "paths": [
                      "/agent_id"
                    ],
                    "kind": "Hash",
                    "version": 2
                  },
                  "indexingPolicy": {
                    "automatic": true,
                    "indexingMode": "consistent",
                    "includedPaths": [
                      {
                        "path": "/*"
                      }
                    ],
                    "excludedPaths": [
                      {
                        "path": "/\"_etag\"/?"
                      }
                    ]
                  }
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.DocumentDB/databaseAccounts/sqlDatabases', parameters('parentAccountName'), parameters('databaseName'))]"
              ]
            },
            {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases/containers",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}/{2}', parameters('parentAccountName'), parameters('databaseName'), 'rl_deployments')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "resource": {
                  "id": "rl_deployments",
                  "partitionKey": {
                    "paths": [
                      "/agent_id"
                    ],
                    "kind": "Hash",
                    "version": 2
                  },
                  "indexingPolicy": {
                    "automatic": true,
                    "indexingMode": "consistent",
                    "includedPaths": [
                      {
                        "path": "/*"
                      }
                    ],
                    "excludedPaths": [
                      {
                        "path": "/\"_etag\"/?"
                      }
                    ]
                  }
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.DocumentDB/databaseAccounts/sqlDatabases', parameters('parentAccountName'), parameters('databaseName'))]"
              ]
            }
          ],
          "outputs": {
            "databaseName": {
              "type": "string",
              "value": "[parameters('databaseName')]"
            },
            "episodesContainerName": {
              "type": "string",
              "value": "rl_episodes"
            },
            "rewardsContainerName": {
              "type": "string",
              "value": "rl_rewards"
            },
            "datasetsContainerName": {
              "type": "string",
              "value": "rl_datasets"
            },
            "trainingRunsContainerName": {
              "type": "string",
              "value": "rl_training_runs"
            },
            "deploymentsContainerName": {
              "type": "string",
              "value": "rl_deployments"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "condition": "[parameters('vnetEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "cosmosPrivateEndpoint",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "virtualNetworkName": {
            "value": "[variables('serviceVirtualNetworkName')]"
          },
          "subnetName": "[if(parameters('vnetEnabled'), createObject('value', variables('serviceVirtualNetworkPrivateEndpointSubnetName')), createObject('value', ''))]",
          "resourceName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount'), '2025-04-01').outputs.name.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "3527345132894700106"
            }
          },
          "parameters": {
            "virtualNetworkName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the virtual network."
              }
            },
            "subnetName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the subnet which contains the private endpoints."
              }
            },
            "resourceName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the resource name of the Cosmos DB account."
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Specifies the location."
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            }
          },
          "variables": {
            "cosmosPrivateDNSZoneName": "privatelink.documents.azure.com",
            "cosmosPrivateDnsZoneVirtualNetworkLinkName": "[format('{0}-cosmos-link-{1}', parameters('resourceName'), take(toLower(uniqueString(parameters('resourceName'), parameters('virtualNetworkName'))), 4))]"
          },
          "resources": [
            {
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2020-06-01",
              "name": "[variables('cosmosPrivateDNSZoneName')]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {}
            },
            {
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('cosmosPrivateDNSZoneName'), variables('cosmosPrivateDnsZoneVirtualNetworkLinkName'))]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.Network/privateDnsZones', variables('cosmosPrivateDNSZoneName'))]"
              ]
            },
            {
              "type": "Microsoft.Network/privateEndpoints",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}-cosmos-private-endpoint', parameters('resourceName'))]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "privateLinkServiceConnections": [
                  {
                    "name": "cosmosPrivateLinkConnection",
                    "properties": {
                      "privateLinkServiceId": "[resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('resourceName'))]",
                      "groupIds": [
                        "Sql"
                      ]
                    }
                  }
                ],
                "subnet": {
                  "id": "[format('{0}/subnets/{1}', resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName')), parameters('subnetName'))]"
                }
              }
            },
            {
              "type": "Microsoft.Network/privateEndpoints/privateDnsZoneGroups",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', format('{0}-cosmos-private-endpoint', parameters('resourceName')), 'cosmosPrivateDnsZoneGroup')]",
              "properties": {
                "privateDnsZoneConfigs": [
                  {
                    "name": "config1",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('cosmosPrivateDNSZoneName'))]"
                    }
                  }
                ]
              },
              "dependsOn": [
                "[resourceId('Microsoft.Network/privateDnsZones', variables('cosmosPrivateDNSZoneName'))]",
                "[resourceId('Microsoft.Network/privateEndpoints', format('{0}-cosmos-private-endpoint', parameters('resourceName')))]"
              ]
            }
          ],
          "outputs": {
            "privateEndpointId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateEndpoints', format('{0}-cosmos-private-endpoint', parameters('resourceName')))]"
            },
            "privateDnsZoneId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateDnsZones', variables('cosmosPrivateDNSZoneName'))]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'serviceVirtualNetwork')]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "cosmosRoleAssignmentMcp",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "cosmosAccountName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount'), '2025-04-01').outputs.name.value]"
          },
          "roleDefinitionID": {
            "value": "[variables('CosmosDBDataContributor')]"
          },
          "principalID": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity'), '2025-04-01').outputs.identityPrincipalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "14872110188757982160"
            }
          },
          "parameters": {
            "cosmosAccountName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Cosmos DB account."
              }
            },
            "roleDefinitionID": {
              "type": "string",
              "metadata": {
                "description": "Role definition ID to assign."
              }
            },
            "principalID": {
              "type": "string",
              "metadata": {
                "description": "Principal ID to assign the role to."
              }
            },
            "principalType": {
              "type": "string",
              "defaultValue": "ServicePrincipal",
              "metadata": {
                "description": "Principal type: User, Group, or ServicePrincipal."
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlRoleAssignments",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}', parameters('cosmosAccountName'), guid(resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName')), parameters('principalID'), parameters('roleDefinitionID')))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[format('{0}/sqlRoleDefinitions/{1}', resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName')), parameters('roleDefinitionID'))]",
                "scope": "[resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName'))]"
              }
            }
          ],
          "outputs": {
            "roleAssignmentId": {
              "type": "string",
              "value": "[resourceId('Microsoft.DocumentDB/databaseAccounts/sqlRoleAssignments', parameters('cosmosAccountName'), guid(resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName')), parameters('principalID'), parameters('roleDefinitionID')))]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "condition": "[not(empty(parameters('developerPrincipalId')))]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "cosmosRoleAssignmentDeveloper",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "cosmosAccountName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount'), '2025-04-01').outputs.name.value]"
          },
          "roleDefinitionID": {
            "value": "[variables('CosmosDBDataContributor')]"
          },
          "principalID": {
            "value": "[parameters('developerPrincipalId')]"
          },
          "principalType": {
            "value": "User"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "14872110188757982160"
            }
          },
          "parameters": {
            "cosmosAccountName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Cosmos DB account."
              }
            },
            "roleDefinitionID": {
              "type": "string",
              "metadata": {
                "description": "Role definition ID to assign."
              }
            },
            "principalID": {
              "type": "string",
              "metadata": {
                "description": "Principal ID to assign the role to."
              }
            },
            "principalType": {
              "type": "string",
              "defaultValue": "ServicePrincipal",
              "metadata": {
                "description": "Principal type: User, Group, or ServicePrincipal."
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlRoleAssignments",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}', parameters('cosmosAccountName'), guid(resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName')), parameters('principalID'), parameters('roleDefinitionID')))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[format('{0}/sqlRoleDefinitions/{1}', resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName')), parameters('roleDefinitionID'))]",
                "scope": "[resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName'))]"
              }
            }
          ],
          "outputs": {
            "roleAssignmentId": {
              "type": "string",
              "value": "[resourceId('Microsoft.DocumentDB/databaseAccounts/sqlRoleAssignments', parameters('cosmosAccountName'), guid(resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName')), parameters('principalID'), parameters('roleDefinitionID')))]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "searchService",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "name": {
            "value": "[variables('searchResourceName')]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "sku": {
            "value": "basic"
          },
          "replicaCount": {
            "value": 1
          },
          "partitionCount": {
            "value": 1
          },
          "semanticSearch": {
            "value": "standard"
          },
          "publicNetworkAccess": "[if(parameters('vnetEnabled'), createObject('value', 'Disabled'), createObject('value', 'Enabled'))]",
          "disableLocalAuth": {
            "value": true
          },
          "enablePrivateEndpoint": {
            "value": "[parameters('vnetEnabled')]"
          },
          "virtualNetworkName": "[if(parameters('vnetEnabled'), createObject('value', variables('serviceVirtualNetworkName')), createObject('value', ''))]",
          "subnetName": "[if(parameters('vnetEnabled'), createObject('value', variables('serviceVirtualNetworkPrivateEndpointSubnetName')), createObject('value', ''))]"
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "3504706731025803791"
            }
          },
          "parameters": {
            "name": {
              "type": "string",
              "metadata": {
                "description": "Name of the Azure AI Search service"
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Location for the resource"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for the resource"
              }
            },
            "sku": {
              "type": "string",
              "defaultValue": "basic",
              "allowedValues": [
                "basic",
                "standard",
                "standard2",
                "standard3"
              ],
              "metadata": {
                "description": "SKU for the search service"
              }
            },
            "replicaCount": {
              "type": "int",
              "defaultValue": 1,
              "minValue": 1,
              "maxValue": 12,
              "metadata": {
                "description": "Number of replicas (1-12 for standard, 1-3 for basic)"
              }
            },
            "partitionCount": {
              "type": "int",
              "defaultValue": 1,
              "allowedValues": [
                1,
                2,
                3,
                4,
                6,
                12
              ],
              "metadata": {
                "description": "Number of partitions (1, 2, 3, 4, 6, or 12)"
              }
            },
            "semanticSearch": {
              "type": "string",
              "defaultValue": "standard",
              "allowedValues": [
                "disabled",
                "free",
                "standard"
              ],
              "metadata": {
                "description": "Enable semantic search capability"
              }
            },
            "publicNetworkAccess": {
              "type": "string",
              "defaultValue": "Enabled",
              "allowedValues": [
                "Enabled",
                "Disabled"
              ],
              "metadata": {
                "description": "Public network access setting"
              }
            },
            "disableLocalAuth": {
              "type": "bool",
              "defaultValue": true,
              "metadata": {
                "description": "Disable local authentication (API keys)"
              }
            },
            "enablePrivateEndpoint": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enable private endpoint"
              }
            },
            "virtualNetworkName": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Virtual network name for private endpoint"
              }
            },
            "subnetName": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Subnet name for private endpoint"
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.Search/searchServices",
              "apiVersion": "2024-06-01-preview",
              "name": "[parameters('name')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "identity": {
                "type": "SystemAssigned"
              },
              "sku": {
                "name": "[parameters('sku')]"
              },
              "properties": {
                "replicaCount": "[parameters('replicaCount')]",
                "partitionCount": "[parameters('partitionCount')]",
                "hostingMode": "default",
                "publicNetworkAccess": "[parameters('publicNetworkAccess')]",
                "networkRuleSet": {
                  "bypass": "AzurePortal"
                },
                "disableLocalAuth": "[parameters('disableLocalAuth')]",
                "authOptions": "[if(parameters('disableLocalAuth'), null(), createObject('aadOrApiKey', createObject('aadAuthFailureMode', 'http401WithBearerChallenge')))]",
                "semanticSearch": "[parameters('semanticSearch')]"
              }
            },
            {
              "condition": "[parameters('enablePrivateEndpoint')]",
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2024-06-01",
              "name": "privatelink.search.windows.net",
              "location": "global",
              "tags": "[parameters('tags')]"
            },
            {
              "condition": "[and(parameters('enablePrivateEndpoint'), not(empty(parameters('virtualNetworkName'))))]",
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2024-06-01",
              "name": "[format('{0}/{1}', 'privatelink.search.windows.net', format('{0}-dns-link', parameters('name')))]",
              "location": "global",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.Network/privateDnsZones', 'privatelink.search.windows.net')]"
              ]
            },
            {
              "condition": "[and(and(parameters('enablePrivateEndpoint'), not(empty(parameters('virtualNetworkName')))), not(empty(parameters('subnetName'))))]",
              "type": "Microsoft.Network/privateEndpoints",
              "apiVersion": "2024-05-01",
              "name": "[format('{0}-pe', parameters('name'))]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "subnet": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks/subnets', parameters('virtualNetworkName'), parameters('subnetName'))]"
                },
                "privateLinkServiceConnections": [
                  {
                    "name": "[format('{0}-psc', parameters('name'))]",
                    "properties": {
                      "privateLinkServiceId": "[resourceId('Microsoft.Search/searchServices', parameters('name'))]",
                      "groupIds": [
                        "searchService"
                      ]
                    }
                  }
                ]
              },
              "dependsOn": [
                "[resourceId('Microsoft.Search/searchServices', parameters('name'))]"
              ]
            },
            {
              "condition": "[parameters('enablePrivateEndpoint')]",
              "type": "Microsoft.Network/privateEndpoints/privateDnsZoneGroups",
              "apiVersion": "2024-05-01",
              "name": "[format('{0}/{1}', format('{0}-pe', parameters('name')), 'default')]",
              "properties": {
                "privateDnsZoneConfigs": [
                  {
                    "name": "privatelink-search-windows-net",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', 'privatelink.search.windows.net')]"
                    }
                  }
                ]
              },
              "dependsOn": [
                "[resourceId('Microsoft.Network/privateDnsZones', 'privatelink.search.windows.net')]",
                "[resourceId('Microsoft.Network/privateEndpoints', format('{0}-pe', parameters('name')))]"
              ]
            }
          ],
          "outputs": {
            "name": {
              "type": "string",
              "value": "[parameters('name')]"
            },
            "endpoint": {
              "type": "string",
              "value": "[format('https://{0}.search.windows.net', parameters('name'))]"
            },
            "principalId": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Search/searchServices', parameters('name')), '2024-06-01-preview', 'full').identity.principalId]"
            },
            "resourceId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Search/searchServices', parameters('name'))]"
            }
          }
        }
      },
      "dependsOn": [
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'serviceVirtualNetwork')]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "searchRoleAssignmentMcp",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "searchServiceName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'searchService'), '2025-04-01').outputs.name.value]"
          },
          "roleDefinitionID": {
            "value": "[variables('SearchIndexDataContributor')]"
          },
          "principalID": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity'), '2025-04-01').outputs.identityPrincipalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "14343078434519577167"
            }
          },
          "parameters": {
            "searchServiceName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Azure AI Search service"
              }
            },
            "roleDefinitionID": {
              "type": "string",
              "metadata": {
                "description": "Role Definition ID to assign"
              }
            },
            "principalID": {
              "type": "string",
              "metadata": {
                "description": "Principal ID to assign the role to"
              }
            },
            "principalType": {
              "type": "string",
              "defaultValue": "ServicePrincipal",
              "allowedValues": [
                "ServicePrincipal",
                "User",
                "Group"
              ],
              "metadata": {
                "description": "Principal type (ServicePrincipal, User, Group)"
              }
            },
            "nameSuffix": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Optional suffix to make role assignment name unique across deployments"
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.Search/searchServices', parameters('searchServiceName'))]",
              "name": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalId": "[parameters('principalID')]",
                "principalType": "[parameters('principalType')]"
              }
            }
          ],
          "outputs": {
            "roleAssignmentId": {
              "type": "string",
              "value": "[extensionResourceId(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), 'Microsoft.Authorization/roleAssignments', if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix'))))]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'searchService')]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "searchServiceRoleAssignmentMcp",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "searchServiceName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'searchService'), '2025-04-01').outputs.name.value]"
          },
          "roleDefinitionID": {
            "value": "[variables('SearchServiceContributor')]"
          },
          "principalID": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity'), '2025-04-01').outputs.identityPrincipalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "14343078434519577167"
            }
          },
          "parameters": {
            "searchServiceName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Azure AI Search service"
              }
            },
            "roleDefinitionID": {
              "type": "string",
              "metadata": {
                "description": "Role Definition ID to assign"
              }
            },
            "principalID": {
              "type": "string",
              "metadata": {
                "description": "Principal ID to assign the role to"
              }
            },
            "principalType": {
              "type": "string",
              "defaultValue": "ServicePrincipal",
              "allowedValues": [
                "ServicePrincipal",
                "User",
                "Group"
              ],
              "metadata": {
                "description": "Principal type (ServicePrincipal, User, Group)"
              }
            },
            "nameSuffix": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Optional suffix to make role assignment name unique across deployments"
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.Search/searchServices', parameters('searchServiceName'))]",
              "name": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalId": "[parameters('principalID')]",
                "principalType": "[parameters('principalType')]"
              }
            }
          ],
          "outputs": {
            "roleAssignmentId": {
              "type": "string",
              "value": "[extensionResourceId(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), 'Microsoft.Authorization/roleAssignments', if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix'))))]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'searchService')]"
      ]
    },
    {
      "condition": "[parameters('fabricEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "fabricCapacity",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "name": {
            "value": "[variables('fabricResourceName')]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "skuName": {
            "value": "[parameters('fabricSkuName')]"
          },
          "adminMembers": "[if(not(empty(parameters('fabricAdminEmail'))), createObject('value', createArray(parameters('fabricAdminEmail'))), createObject('value', createArray()))]"
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "2295998011058780504"
            }
          },
          "parameters": {
            "name": {
              "type": "string",
              "metadata": {
                "description": "Name of the Fabric capacity"
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Location for the Fabric capacity"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for the Fabric capacity"
              }
            },
            "skuName": {
              "type": "string",
              "defaultValue": "F2",
              "allowedValues": [
                "F2",
                "F4",
                "F8",
                "F16",
                "F32",
                "F64",
                "F128",
                "F256",
                "F512",
                "F1024",
                "F2048"
              ],
              "metadata": {
                "description": "SKU name for the Fabric capacity (F2, F4, F8, F16, F32, F64, F128, F256, F512, F1024, F2048)"
              }
            },
            "adminMembers": {
              "type": "array",
              "metadata": {
                "description": "List of admin members (email addresses) for the Fabric capacity"
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.Fabric/capacities",
              "apiVersion": "2023-11-01",
              "name": "[parameters('name')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "sku": {
                "name": "[parameters('skuName')]",
                "tier": "Fabric"
              },
              "properties": {
                "administration": {
                  "members": "[parameters('adminMembers')]"
                }
              }
            }
          ],
          "outputs": {
            "id": {
              "type": "string",
              "value": "[resourceId('Microsoft.Fabric/capacities', parameters('name'))]"
            },
            "name": {
              "type": "string",
              "value": "[parameters('name')]"
            },
            "state": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Fabric/capacities', parameters('name')), '2023-11-01').state]"
            }
          }
        }
      },
      "dependsOn": [
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "condition": "[and(parameters('fabricEnabled'), parameters('vnetEnabled'))]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "fabricPrivateEndpoint",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "virtualNetworkName": {
            "value": "[variables('serviceVirtualNetworkName')]"
          },
          "subnetName": "[if(parameters('vnetEnabled'), createObject('value', variables('serviceVirtualNetworkPrivateEndpointSubnetName')), createObject('value', ''))]",
          "fabricCapacityId": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'fabricCapacity'), '2025-04-01').outputs.id.value]"
          },
          "fabricCapacityName": {
            "value": "[variables('fabricResourceName')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "13956740895608471205"
            }
          },
          "parameters": {
            "virtualNetworkName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the virtual network."
              }
            },
            "subnetName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the subnet which contains the private endpoints."
              }
            },
            "fabricCapacityId": {
              "type": "string",
              "metadata": {
                "description": "Specifies the resource ID of the Fabric capacity."
              }
            },
            "fabricCapacityName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the Fabric capacity (for naming conventions)."
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Specifies the location."
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for all resources."
              }
            }
          },
          "variables": {
            "fabricDfsPrivateDNSZoneName": "privatelink.dfs.fabric.microsoft.com",
            "fabricBlobPrivateDNSZoneName": "privatelink.blob.fabric.microsoft.com",
            "fabricApiPrivateDNSZoneName": "privatelink.api.fabric.microsoft.com",
            "onelakeDfsPrivateDNSZoneName": "[format('privatelink.dfs.{0}', environment().suffixes.storage)]",
            "fabricDfsDnsZoneLinkName": "[format('{0}-fabric-dfs-link-{1}', parameters('fabricCapacityName'), take(toLower(uniqueString(parameters('fabricCapacityName'), parameters('virtualNetworkName'))), 4))]",
            "fabricBlobDnsZoneLinkName": "[format('{0}-fabric-blob-link-{1}', parameters('fabricCapacityName'), take(toLower(uniqueString(parameters('fabricCapacityName'), parameters('virtualNetworkName'))), 4))]",
            "fabricApiDnsZoneLinkName": "[format('{0}-fabric-api-link-{1}', parameters('fabricCapacityName'), take(toLower(uniqueString(parameters('fabricCapacityName'), parameters('virtualNetworkName'))), 4))]",
            "onelakeDfsDnsZoneLinkName": "[format('{0}-onelake-dfs-link-{1}', parameters('fabricCapacityName'), take(toLower(uniqueString(parameters('fabricCapacityName'), parameters('virtualNetworkName'))), 4))]"
          },
          "resources": [
            {
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2020-06-01",
              "name": "[variables('fabricDfsPrivateDNSZoneName')]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {}
            },
            {
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2020-06-01",
              "name": "[variables('fabricBlobPrivateDNSZoneName')]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {}
            },
            {
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2020-06-01",
              "name": "[variables('fabricApiPrivateDNSZoneName')]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {}
            },
            {
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2020-06-01",
              "name": "[variables('onelakeDfsPrivateDNSZoneName')]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {}
            },
            {
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('fabricDfsPrivateDNSZoneName'), variables('fabricDfsDnsZoneLinkName'))]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.Network/privateDnsZones', variables('fabricDfsPrivateDNSZoneName'))]"
              ]
            },
            {
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('fabricBlobPrivateDNSZoneName'), variables('fabricBlobDnsZoneLinkName'))]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.Network/privateDnsZones', variables('fabricBlobPrivateDNSZoneName'))]"
              ]
            },
            {
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('fabricApiPrivateDNSZoneName'), variables('fabricApiDnsZoneLinkName'))]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.Network/privateDnsZones', variables('fabricApiPrivateDNSZoneName'))]"
              ]
            },
            {
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('onelakeDfsPrivateDNSZoneName'), variables('onelakeDfsDnsZoneLinkName'))]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.Network/privateDnsZones', variables('onelakeDfsPrivateDNSZoneName'))]"
              ]
            },
            {
              "type": "Microsoft.Network/privateEndpoints",
              "apiVersion": "2021-08-01",
              "name": "[format('pe-{0}-onelake', parameters('fabricCapacityName'))]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "privateLinkServiceConnections": [
                  {
                    "name": "onelakePrivateLinkConnection",
                    "properties": {
                      "privateLinkServiceId": "[parameters('fabricCapacityId')]",
                      "groupIds": [
                        "onelake"
                      ]
                    }
                  }
                ],
                "subnet": {
                  "id": "[format('{0}/subnets/{1}', resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName')), parameters('subnetName'))]"
                }
              }
            },
            {
              "type": "Microsoft.Network/privateEndpoints/privateDnsZoneGroups",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', format('pe-{0}-onelake', parameters('fabricCapacityName')), 'onelakePrivateDnsZoneGroup')]",
              "properties": {
                "privateDnsZoneConfigs": [
                  {
                    "name": "fabric-dfs-config",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('fabricDfsPrivateDNSZoneName'))]"
                    }
                  },
                  {
                    "name": "fabric-blob-config",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('fabricBlobPrivateDNSZoneName'))]"
                    }
                  },
                  {
                    "name": "fabric-api-config",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('fabricApiPrivateDNSZoneName'))]"
                    }
                  },
                  {
                    "name": "onelake-dfs-config",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('onelakeDfsPrivateDNSZoneName'))]"
                    }
                  }
                ]
              },
              "dependsOn": [
                "[resourceId('Microsoft.Network/privateDnsZones', variables('fabricApiPrivateDNSZoneName'))]",
                "[resourceId('Microsoft.Network/privateDnsZones', variables('fabricBlobPrivateDNSZoneName'))]",
                "[resourceId('Microsoft.Network/privateDnsZones', variables('fabricDfsPrivateDNSZoneName'))]",
                "[resourceId('Microsoft.Network/privateDnsZones', variables('onelakeDfsPrivateDNSZoneName'))]",
                "[resourceId('Microsoft.Network/privateEndpoints', format('pe-{0}-onelake', parameters('fabricCapacityName')))]"
              ]
            },
            {
              "type": "Microsoft.Network/privateDnsZones/A",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('fabricDfsPrivateDNSZoneName'), 'onelake')]",
              "properties": {
                "ttl": 3600,
                "aRecords": [
                  {
                    "ipv4Address": "[reference(resourceId('Microsoft.Network/privateEndpoints', format('pe-{0}-onelake', parameters('fabricCapacityName'))), '2021-08-01').customDnsConfigs[0].ipAddresses[0]]"
                  }
                ]
              },
              "dependsOn": [
                "[resourceId('Microsoft.Network/privateDnsZones', variables('fabricDfsPrivateDNSZoneName'))]",
                "[resourceId('Microsoft.Network/privateEndpoints', format('pe-{0}-onelake', parameters('fabricCapacityName')))]"
              ]
            },
            {
              "type": "Microsoft.Network/privateDnsZones/A",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('fabricBlobPrivateDNSZoneName'), 'onelake')]",
              "properties": {
                "ttl": 3600,
                "aRecords": [
                  {
                    "ipv4Address": "[reference(resourceId('Microsoft.Network/privateEndpoints', format('pe-{0}-onelake', parameters('fabricCapacityName'))), '2021-08-01').customDnsConfigs[0].ipAddresses[0]]"
                  }
                ]
              },
              "dependsOn": [
                "[resourceId('Microsoft.Network/privateDnsZones', variables('fabricBlobPrivateDNSZoneName'))]",
                "[resourceId('Microsoft.Network/privateEndpoints', format('pe-{0}-onelake', parameters('fabricCapacityName')))]"
              ]
            }
          ],
          "outputs": {
            "privateEndpointId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateEndpoints', format('pe-{0}-onelake', parameters('fabricCapacityName')))]"
            },
            "fabricDfsPrivateDnsZoneId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateDnsZones', variables('fabricDfsPrivateDNSZoneName'))]"
            },
            "fabricBlobPrivateDnsZoneId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateDnsZones', variables('fabricBlobPrivateDNSZoneName'))]"
            },
            "fabricApiPrivateDnsZoneId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateDnsZones', variables('fabricApiPrivateDNSZoneName'))]"
            },
            "onelakeDfsPrivateDnsZoneId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateDnsZones', variables('onelakeDfsPrivateDNSZoneName'))]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'fabricCapacity')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'serviceVirtualNetwork')]"
      ]
    },
    {
      "condition": "[and(and(parameters('fabricEnabled'), parameters('fabricDataAgentsEnabled')), parameters('agentIdentityEnabled'))]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "fabricDataAgents",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "agentPrincipalId": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'nextBestActionAgentIdentity'), '2025-04-01').outputs.agentIdentityPrincipalId.value]"
          },
          "fabricCapacityId": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'fabricCapacity'), '2025-04-01').outputs.id.value]"
          },
          "fabricCapacityName": {
            "value": "[variables('fabricResourceName')]"
          },
          "fabricWorkspaceId": {
            "value": "[parameters('fabricWorkspaceId')]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "fabricDataAgentsEnabled": {
            "value": "[parameters('fabricDataAgentsEnabled')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "9657824003683952405"
            }
          },
          "parameters": {
            "agentPrincipalId": {
              "type": "string",
              "metadata": {
                "description": "Principal ID of the agent identity"
              }
            },
            "fabricCapacityId": {
              "type": "string",
              "metadata": {
                "description": "Resource ID of the Fabric capacity"
              }
            },
            "fabricCapacityName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Fabric capacity"
              }
            },
            "fabricWorkspaceId": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Fabric workspace ID for data agents"
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Location for Fabric resources"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for all resources"
              }
            },
            "fabricDataAgentsEnabled": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enable Fabric Data Agents (default: false)"
              }
            },
            "deploymentSuffix": {
              "type": "string",
              "defaultValue": "fabric-data-v1",
              "metadata": {
                "description": "Unique suffix for role assignment names"
              }
            }
          },
          "variables": {
            "FabricReader": "acdd72a7-3385-48ef-bd42-f606fba81ae7",
            "FabricContributor": "b24988ac-6180-42a0-ab88-20f7382dd24c",
            "StorageBlobDataReader": "2a2b9908-6ea1-4ae2-8e65-a410df84e7d1",
            "StorageBlobDataContributor": "ba92f5b4-2d11-453d-a403-e96b0029c9fe"
          },
          "resources": [
            {
              "condition": "[parameters('fabricDataAgentsEnabled')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.Fabric/capacities', parameters('fabricCapacityName'))]",
              "name": "[guid(resourceId('Microsoft.Fabric/capacities', parameters('fabricCapacityName')), parameters('agentPrincipalId'), variables('FabricReader'), parameters('deploymentSuffix'))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', variables('FabricReader'))]",
                "principalId": "[parameters('agentPrincipalId')]",
                "principalType": "ServicePrincipal",
                "description": "Allows Fabric Data Agents to view workspace and resources"
              }
            },
            {
              "condition": "[parameters('fabricDataAgentsEnabled')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.Fabric/capacities', parameters('fabricCapacityName'))]",
              "name": "[guid(resourceId('Microsoft.Fabric/capacities', parameters('fabricCapacityName')), parameters('agentPrincipalId'), variables('FabricContributor'), parameters('deploymentSuffix'))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', variables('FabricContributor'))]",
                "principalId": "[parameters('agentPrincipalId')]",
                "principalType": "ServicePrincipal",
                "description": "Allows Fabric Data Agents to manage lakehouses, warehouses, and pipelines"
              }
            },
            {
              "condition": "[parameters('fabricDataAgentsEnabled')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.Fabric/capacities', parameters('fabricCapacityName'))]",
              "name": "[guid(resourceId('Microsoft.Fabric/capacities', parameters('fabricCapacityName')), parameters('agentPrincipalId'), variables('StorageBlobDataContributor'), parameters('deploymentSuffix'), 'onelake')]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', variables('StorageBlobDataContributor'))]",
                "principalId": "[parameters('agentPrincipalId')]",
                "principalType": "ServicePrincipal",
                "description": "Allows Fabric Data Agents to read/write data through OneLake"
              }
            }
          ],
          "outputs": {
            "fabricReaderRoleAssignmentId": {
              "type": "string",
              "value": "[if(parameters('fabricDataAgentsEnabled'), extensionResourceId(resourceId('Microsoft.Fabric/capacities', parameters('fabricCapacityName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.Fabric/capacities', parameters('fabricCapacityName')), parameters('agentPrincipalId'), variables('FabricReader'), parameters('deploymentSuffix'))), '')]"
            },
            "fabricContributorRoleAssignmentId": {
              "type": "string",
              "value": "[if(parameters('fabricDataAgentsEnabled'), extensionResourceId(resourceId('Microsoft.Fabric/capacities', parameters('fabricCapacityName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.Fabric/capacities', parameters('fabricCapacityName')), parameters('agentPrincipalId'), variables('FabricContributor'), parameters('deploymentSuffix'))), '')]"
            },
            "onelakeDataContributorRoleAssignmentId": {
              "type": "string",
              "value": "[if(parameters('fabricDataAgentsEnabled'), extensionResourceId(resourceId('Microsoft.Fabric/capacities', parameters('fabricCapacityName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.Fabric/capacities', parameters('fabricCapacityName')), parameters('agentPrincipalId'), variables('StorageBlobDataContributor'), parameters('deploymentSuffix'), 'onelake')), '')]"
            },
            "fabricWorkspaceId": {
              "type": "string",
              "value": "[parameters('fabricWorkspaceId')]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'fabricCapacity')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'nextBestActionAgentIdentity')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "monitoring",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "logAnalyticsName": "[if(not(empty(parameters('logAnalyticsName'))), createObject('value', parameters('logAnalyticsName')), createObject('value', format('{0}{1}', variables('abbrs').operationalInsightsWorkspaces, variables('resourceToken'))))]",
          "applicationInsightsName": "[if(not(empty(parameters('applicationInsightsName'))), createObject('value', parameters('applicationInsightsName')), createObject('value', format('{0}{1}', variables('abbrs').insightsComponents, variables('resourceToken'))))]",
          "disableLocalAuth": {
            "value": "[parameters('disableLocalAuth')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "13839394874808683128"
            }
          },
          "parameters": {
            "logAnalyticsName": {
              "type": "string"
            },
            "applicationInsightsName": {
              "type": "string"
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]"
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            },
            "disableLocalAuth": {
              "type": "bool",
              "defaultValue": false
            }
          },
          "resources": [
            {
              "type": "Microsoft.Resources/deployments",
              "apiVersion": "2025-04-01",
              "name": "loganalytics",
              "properties": {
                "expressionEvaluationOptions": {
                  "scope": "inner"
                },
                "mode": "Incremental",
                "parameters": {
                  "name": {
                    "value": "[parameters('logAnalyticsName')]"
                  },
                  "location": {
                    "value": "[parameters('location')]"
                  },
                  "tags": {
                    "value": "[parameters('tags')]"
                  }
                },
                "template": {
                  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
                  "contentVersion": "1.0.0.0",
                  "metadata": {
                    "_generator": {
                      "name": "bicep",
                      "version": "0.40.2.10011",
                      "templateHash": "3781048324742497191"
                    }
                  },
                  "parameters": {
                    "name": {
                      "type": "string"
                    },
                    "location": {
                      "type": "string",
                      "defaultValue": "[resourceGroup().location]"
                    },
                    "tags": {
                      "type": "object",
                      "defaultValue": {}
                    }
                  },
                  "resources": [
                    {
                      "type": "Microsoft.OperationalInsights/workspaces",
                      "apiVersion": "2021-12-01-preview",
                      "name": "[parameters('name')]",
                      "location": "[parameters('location')]",
                      "tags": "[parameters('tags')]",
                      "properties": {
                        "retentionInDays": 30,
                        "features": {
                          "searchVersion": 1
                        },
                        "sku": {
                          "name": "PerGB2018"
                        }
                      }
                    }
                  ],
                  "outputs": {
                    "id": {
                      "type": "string",
                      "value": "[resourceId('Microsoft.OperationalInsights/workspaces', parameters('name'))]"
                    },
                    "name": {
                      "type": "string",
                      "value": "[parameters('name')]"
                    }
                  }
                }
              }
            },
            {
              "type": "Microsoft.Resources/deployments",
              "apiVersion": "2025-04-01",
              "name": "applicationinsights",
              "properties": {
                "expressionEvaluationOptions": {
                  "scope": "inner"
                },
                "mode": "Incremental",
                "parameters": {
                  "name": {
                    "value": "[parameters('applicationInsightsName')]"
                  },
                  "location": {
                    "value": "[parameters('location')]"
                  },
                  "tags": {
                    "value": "[parameters('tags')]"
                  },
                  "logAnalyticsWorkspaceId": {
                    "value": "[reference(resourceId('Microsoft.Resources/deployments', 'loganalytics'), '2025-04-01').outputs.id.value]"
                  },
                  "disableLocalAuth": {
                    "value": "[parameters('disableLocalAuth')]"
                  }
                },
                "template": {
                  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
                  "contentVersion": "1.0.0.0",
                  "metadata": {
                    "_generator": {
                      "name": "bicep",
                      "version": "0.40.2.10011",
                      "templateHash": "16089782685203879253"
                    }
                  },
                  "parameters": {
                    "name": {
                      "type": "string"
                    },
                    "location": {
                      "type": "string",
                      "defaultValue": "[resourceGroup().location]"
                    },
                    "tags": {
                      "type": "object",
                      "defaultValue": {}
                    },
                    "logAnalyticsWorkspaceId": {
                      "type": "string"
                    },
                    "disableLocalAuth": {
                      "type": "bool",
                      "defaultValue": false
                    }
                  },
                  "resources": [
                    {
                      "type": "Microsoft.Insights/components",
                      "apiVersion": "2020-02-02",
                      "name": "[parameters('name')]",
                      "location": "[parameters('location')]",
                      "tags": "[parameters('tags')]",
                      "kind": "web",
                      "properties": {
                        "Application_Type": "web",
                        "WorkspaceResourceId": "[parameters('logAnalyticsWorkspaceId')]",
                        "DisableLocalAuth": "[parameters('disableLocalAuth')]"
                      }
                    }
                  ],
                  "outputs": {
                    "connectionString": {
                      "type": "string",
                      "value": "[reference(resourceId('Microsoft.Insights/components', parameters('name')), '2020-02-02').ConnectionString]"
                    },
                    "instrumentationKey": {
                      "type": "string",
                      "value": "[reference(resourceId('Microsoft.Insights/components', parameters('name')), '2020-02-02').InstrumentationKey]"
                    },
                    "name": {
                      "type": "string",
                      "value": "[parameters('name')]"
                    }
                  }
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.Resources/deployments', 'loganalytics')]"
              ]
            }
          ],
          "outputs": {
            "applicationInsightsConnectionString": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Resources/deployments', 'applicationinsights'), '2025-04-01').outputs.connectionString.value]"
            },
            "applicationInsightsInstrumentationKey": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Resources/deployments', 'applicationinsights'), '2025-04-01').outputs.instrumentationKey.value]"
            },
            "applicationInsightsName": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Resources/deployments', 'applicationinsights'), '2025-04-01').outputs.name.value]"
            },
            "logAnalyticsWorkspaceId": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Resources/deployments', 'loganalytics'), '2025-04-01').outputs.id.value]"
            },
            "logAnalyticsWorkspaceName": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Resources/deployments', 'loganalytics'), '2025-04-01').outputs.name.value]"
            }
          }
        }
      },
      "dependsOn": [
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "condition": "[parameters('grafanaEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "prometheusDcrAssociation",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "aksClusterName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'aksCluster'), '2025-04-01').outputs.aksClusterName.value]"
          },
          "dataCollectionRuleId": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'azureMonitorWorkspace'), '2025-04-01').outputs.dataCollectionRuleId.value]"
          },
          "dataCollectionEndpointId": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'azureMonitorWorkspace'), '2025-04-01').outputs.dataCollectionEndpointId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "9298638312194360564"
            }
          },
          "parameters": {
            "aksClusterName": {
              "type": "string",
              "metadata": {
                "description": "Name of the AKS cluster"
              }
            },
            "dataCollectionRuleId": {
              "type": "string",
              "metadata": {
                "description": "Data Collection Rule ID for Prometheus metrics"
              }
            },
            "dataCollectionEndpointId": {
              "type": "string",
              "metadata": {
                "description": "Data Collection Endpoint ID for Prometheus metrics"
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.Insights/dataCollectionRuleAssociations",
              "apiVersion": "2022-06-01",
              "scope": "[resourceId('Microsoft.ContainerService/managedClusters', parameters('aksClusterName'))]",
              "name": "configurationAccessEndpoint",
              "properties": {
                "dataCollectionEndpointId": "[parameters('dataCollectionEndpointId')]"
              }
            },
            {
              "type": "Microsoft.Insights/dataCollectionRuleAssociations",
              "apiVersion": "2022-06-01",
              "scope": "[resourceId('Microsoft.ContainerService/managedClusters', parameters('aksClusterName'))]",
              "name": "ContainerInsightsMetricsExtension",
              "properties": {
                "dataCollectionRuleId": "[parameters('dataCollectionRuleId')]",
                "description": "Association of data collection rule for Prometheus metrics"
              }
            }
          ],
          "outputs": {
            "dataCollectionRuleAssociationName": {
              "type": "string",
              "value": "ContainerInsightsMetricsExtension"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'aksCluster')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'azureMonitorWorkspace')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "condition": "[parameters('grafanaEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "grafana",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "grafanaName": {
            "value": "[variables('grafanaResourceName')]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "skuName": {
            "value": "Standard"
          },
          "publicNetworkAccess": {
            "value": "Enabled"
          },
          "enableSystemAssignedIdentity": {
            "value": true
          },
          "azureMonitorWorkspaceId": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'azureMonitorWorkspace'), '2025-04-01').outputs.id.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "14274915210634511607"
            }
          },
          "parameters": {
            "grafanaName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Azure Managed Grafana instance"
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Location for the Grafana resource"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for the resource"
              }
            },
            "skuName": {
              "type": "string",
              "defaultValue": "Standard",
              "allowedValues": [
                "Standard",
                "Essential"
              ],
              "metadata": {
                "description": "SKU name for Grafana - Standard or Essential"
              }
            },
            "publicNetworkAccess": {
              "type": "string",
              "defaultValue": "Enabled",
              "allowedValues": [
                "Enabled",
                "Disabled"
              ],
              "metadata": {
                "description": "Enable public network access"
              }
            },
            "zoneRedundancy": {
              "type": "string",
              "defaultValue": "Disabled",
              "allowedValues": [
                "Enabled",
                "Disabled"
              ],
              "metadata": {
                "description": "Enable zone redundancy"
              }
            },
            "apiKeyEnabled": {
              "type": "string",
              "defaultValue": "Disabled",
              "allowedValues": [
                "Enabled",
                "Disabled"
              ],
              "metadata": {
                "description": "Enable API key authentication"
              }
            },
            "deterministicOutboundIP": {
              "type": "string",
              "defaultValue": "Disabled",
              "allowedValues": [
                "Enabled",
                "Disabled"
              ],
              "metadata": {
                "description": "Enable deterministic outbound IP"
              }
            },
            "enableSystemAssignedIdentity": {
              "type": "bool",
              "defaultValue": true,
              "metadata": {
                "description": "Enable system assigned managed identity"
              }
            },
            "azureMonitorWorkspaceId": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Azure Monitor Workspace Resource ID for Prometheus integration"
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.Dashboard/grafana",
              "apiVersion": "2024-10-01",
              "name": "[parameters('grafanaName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "sku": {
                "name": "[parameters('skuName')]"
              },
              "identity": {
                "type": "[if(parameters('enableSystemAssignedIdentity'), 'SystemAssigned', 'None')]"
              },
              "properties": {
                "publicNetworkAccess": "[parameters('publicNetworkAccess')]",
                "zoneRedundancy": "[parameters('zoneRedundancy')]",
                "apiKey": "[parameters('apiKeyEnabled')]",
                "deterministicOutboundIP": "[parameters('deterministicOutboundIP')]",
                "grafanaIntegrations": "[if(not(empty(parameters('azureMonitorWorkspaceId'))), createObject('azureMonitorWorkspaceIntegrations', createArray(createObject('azureMonitorWorkspaceResourceId', parameters('azureMonitorWorkspaceId')))), null())]",
                "grafanaConfigurations": {
                  "users": {
                    "viewersCanEdit": true
                  }
                }
              }
            }
          ],
          "outputs": {
            "id": {
              "type": "string",
              "metadata": {
                "description": "The resource ID of the Grafana instance"
              },
              "value": "[resourceId('Microsoft.Dashboard/grafana', parameters('grafanaName'))]"
            },
            "name": {
              "type": "string",
              "metadata": {
                "description": "The name of the Grafana instance"
              },
              "value": "[parameters('grafanaName')]"
            },
            "endpoint": {
              "type": "string",
              "metadata": {
                "description": "The endpoint URL of the Grafana instance"
              },
              "value": "[reference(resourceId('Microsoft.Dashboard/grafana', parameters('grafanaName')), '2024-10-01').endpoint]"
            },
            "principalId": {
              "type": "string",
              "metadata": {
                "description": "The principal ID of the system-assigned managed identity"
              },
              "value": "[if(parameters('enableSystemAssignedIdentity'), reference(resourceId('Microsoft.Dashboard/grafana', parameters('grafanaName')), '2024-10-01', 'full').identity.principalId, '')]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'azureMonitorWorkspace')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "condition": "[parameters('grafanaEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "grafanaLogAnalyticsRole",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "resourceName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'monitoring'), '2025-04-01').outputs.logAnalyticsWorkspaceName.value]"
          },
          "resourceType": {
            "value": "logAnalytics"
          },
          "roleDefinitionID": {
            "value": "[variables('MonitoringReader')]"
          },
          "principalID": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'grafana'), '2025-04-01').outputs.principalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "5693799871670433091"
            }
          },
          "parameters": {
            "resourceName": {
              "type": "string",
              "metadata": {
                "description": "Name of the resource to grant access to"
              }
            },
            "resourceType": {
              "type": "string",
              "allowedValues": [
                "logAnalytics",
                "aks",
                "appInsights",
                "azureMonitorWorkspace"
              ],
              "metadata": {
                "description": "Type of resource for role assignment scope"
              }
            },
            "roleDefinitionID": {
              "type": "string",
              "metadata": {
                "description": "Role Definition ID to assign"
              }
            },
            "principalID": {
              "type": "string",
              "metadata": {
                "description": "Principal ID to grant access to"
              }
            },
            "principalType": {
              "type": "string",
              "defaultValue": "ServicePrincipal",
              "allowedValues": [
                "ServicePrincipal",
                "User",
                "Group"
              ],
              "metadata": {
                "description": "Principal type for role assignment"
              }
            }
          },
          "resources": [
            {
              "condition": "[equals(parameters('resourceType'), 'logAnalytics')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.OperationalInsights/workspaces', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.OperationalInsights/workspaces', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              }
            },
            {
              "condition": "[equals(parameters('resourceType'), 'aks')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.ContainerService/managedClusters', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.ContainerService/managedClusters', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              }
            },
            {
              "condition": "[equals(parameters('resourceType'), 'appInsights')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.Insights/components', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.Insights/components', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              }
            },
            {
              "condition": "[equals(parameters('resourceType'), 'azureMonitorWorkspace')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.Monitor/accounts', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.Monitor/accounts', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              }
            }
          ]
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'grafana')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'monitoring')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "condition": "[parameters('grafanaEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "grafanaAksRole",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "resourceName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'aksCluster'), '2025-04-01').outputs.aksClusterName.value]"
          },
          "resourceType": {
            "value": "aks"
          },
          "roleDefinitionID": {
            "value": "[variables('ReaderRole')]"
          },
          "principalID": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'grafana'), '2025-04-01').outputs.principalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "5693799871670433091"
            }
          },
          "parameters": {
            "resourceName": {
              "type": "string",
              "metadata": {
                "description": "Name of the resource to grant access to"
              }
            },
            "resourceType": {
              "type": "string",
              "allowedValues": [
                "logAnalytics",
                "aks",
                "appInsights",
                "azureMonitorWorkspace"
              ],
              "metadata": {
                "description": "Type of resource for role assignment scope"
              }
            },
            "roleDefinitionID": {
              "type": "string",
              "metadata": {
                "description": "Role Definition ID to assign"
              }
            },
            "principalID": {
              "type": "string",
              "metadata": {
                "description": "Principal ID to grant access to"
              }
            },
            "principalType": {
              "type": "string",
              "defaultValue": "ServicePrincipal",
              "allowedValues": [
                "ServicePrincipal",
                "User",
                "Group"
              ],
              "metadata": {
                "description": "Principal type for role assignment"
              }
            }
          },
          "resources": [
            {
              "condition": "[equals(parameters('resourceType'), 'logAnalytics')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.OperationalInsights/workspaces', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.OperationalInsights/workspaces', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              }
            },
            {
              "condition": "[equals(parameters('resourceType'), 'aks')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.ContainerService/managedClusters', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.ContainerService/managedClusters', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              }
            },
            {
              "condition": "[equals(parameters('resourceType'), 'appInsights')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.Insights/components', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.Insights/components', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              }
            },
            {
              "condition": "[equals(parameters('resourceType'), 'azureMonitorWorkspace')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.Monitor/accounts', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.Monitor/accounts', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              }
            }
          ]
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'aksCluster')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'grafana')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "condition": "[parameters('grafanaEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "grafanaAppInsightsRole",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "resourceName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'monitoring'), '2025-04-01').outputs.applicationInsightsName.value]"
          },
          "resourceType": {
            "value": "appInsights"
          },
          "roleDefinitionID": {
            "value": "[variables('MonitoringReader')]"
          },
          "principalID": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'grafana'), '2025-04-01').outputs.principalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "5693799871670433091"
            }
          },
          "parameters": {
            "resourceName": {
              "type": "string",
              "metadata": {
                "description": "Name of the resource to grant access to"
              }
            },
            "resourceType": {
              "type": "string",
              "allowedValues": [
                "logAnalytics",
                "aks",
                "appInsights",
                "azureMonitorWorkspace"
              ],
              "metadata": {
                "description": "Type of resource for role assignment scope"
              }
            },
            "roleDefinitionID": {
              "type": "string",
              "metadata": {
                "description": "Role Definition ID to assign"
              }
            },
            "principalID": {
              "type": "string",
              "metadata": {
                "description": "Principal ID to grant access to"
              }
            },
            "principalType": {
              "type": "string",
              "defaultValue": "ServicePrincipal",
              "allowedValues": [
                "ServicePrincipal",
                "User",
                "Group"
              ],
              "metadata": {
                "description": "Principal type for role assignment"
              }
            }
          },
          "resources": [
            {
              "condition": "[equals(parameters('resourceType'), 'logAnalytics')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.OperationalInsights/workspaces', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.OperationalInsights/workspaces', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              }
            },
            {
              "condition": "[equals(parameters('resourceType'), 'aks')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.ContainerService/managedClusters', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.ContainerService/managedClusters', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              }
            },
            {
              "condition": "[equals(parameters('resourceType'), 'appInsights')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.Insights/components', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.Insights/components', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              }
            },
            {
              "condition": "[equals(parameters('resourceType'), 'azureMonitorWorkspace')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.Monitor/accounts', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.Monitor/accounts', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              }
            }
          ]
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'grafana')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'monitoring')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "condition": "[parameters('grafanaEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "grafanaAzureMonitorWorkspaceRole",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "resourceName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'azureMonitorWorkspace'), '2025-04-01').outputs.name.value]"
          },
          "resourceType": {
            "value": "azureMonitorWorkspace"
          },
          "roleDefinitionID": {
            "value": "[variables('MonitoringDataReader')]"
          },
          "principalID": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'grafana'), '2025-04-01').outputs.principalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "5693799871670433091"
            }
          },
          "parameters": {
            "resourceName": {
              "type": "string",
              "metadata": {
                "description": "Name of the resource to grant access to"
              }
            },
            "resourceType": {
              "type": "string",
              "allowedValues": [
                "logAnalytics",
                "aks",
                "appInsights",
                "azureMonitorWorkspace"
              ],
              "metadata": {
                "description": "Type of resource for role assignment scope"
              }
            },
            "roleDefinitionID": {
              "type": "string",
              "metadata": {
                "description": "Role Definition ID to assign"
              }
            },
            "principalID": {
              "type": "string",
              "metadata": {
                "description": "Principal ID to grant access to"
              }
            },
            "principalType": {
              "type": "string",
              "defaultValue": "ServicePrincipal",
              "allowedValues": [
                "ServicePrincipal",
                "User",
                "Group"
              ],
              "metadata": {
                "description": "Principal type for role assignment"
              }
            }
          },
          "resources": [
            {
              "condition": "[equals(parameters('resourceType'), 'logAnalytics')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.OperationalInsights/workspaces', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.OperationalInsights/workspaces', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              }
            },
            {
              "condition": "[equals(parameters('resourceType'), 'aks')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.ContainerService/managedClusters', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.ContainerService/managedClusters', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              }
            },
            {
              "condition": "[equals(parameters('resourceType'), 'appInsights')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.Insights/components', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.Insights/components', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              }
            },
            {
              "condition": "[equals(parameters('resourceType'), 'azureMonitorWorkspace')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.Monitor/accounts', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.Monitor/accounts', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              }
            }
          ]
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'azureMonitorWorkspace')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'grafana')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "appInsightsRoleAssignmentMcp",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "appInsightsName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'monitoring'), '2025-04-01').outputs.applicationInsightsName.value]"
          },
          "roleDefinitionID": {
            "value": "[variables('monitoringRoleDefinitionId')]"
          },
          "principalID": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity'), '2025-04-01').outputs.identityPrincipalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "10378639561665210744"
            }
          },
          "parameters": {
            "principalID": {
              "type": "string"
            },
            "roleDefinitionID": {
              "type": "string"
            },
            "appInsightsName": {
              "type": "string"
            },
            "nameSuffix": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Optional suffix to make role assignment name unique across deployments"
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.Insights/components', parameters('appInsightsName'))]",
              "name": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.Insights/components', parameters('appInsightsName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.Insights/components', parameters('appInsightsName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalId": "[parameters('principalID')]",
                "principalType": "ServicePrincipal"
              }
            }
          ],
          "outputs": {
            "ROLE_ASSIGNMENT_NAME": {
              "type": "string",
              "value": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.Insights/components', parameters('appInsightsName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.Insights/components', parameters('appInsightsName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'monitoring')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "condition": "[parameters('agentIdentityEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "agentRoleAssignments",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "agentPrincipalId": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'nextBestActionAgentIdentity'), '2025-04-01').outputs.agentIdentityPrincipalId.value]"
          },
          "cosmosAccountName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount'), '2025-04-01').outputs.name.value]"
          },
          "searchServiceName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'searchService'), '2025-04-01').outputs.name.value]"
          },
          "storageAccountName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'storage'), '2025-04-01').outputs.name.value]"
          },
          "foundryAccountName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'foundry'), '2025-04-01').outputs.foundryAccountName.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "14487151876603163638"
            }
          },
          "parameters": {
            "agentPrincipalId": {
              "type": "string",
              "metadata": {
                "description": "Principal ID of the agent identity"
              }
            },
            "cosmosAccountName": {
              "type": "string",
              "metadata": {
                "description": "Cosmos DB account name"
              }
            },
            "searchServiceName": {
              "type": "string",
              "metadata": {
                "description": "Azure AI Search service name"
              }
            },
            "storageAccountName": {
              "type": "string",
              "metadata": {
                "description": "Storage account name"
              }
            },
            "foundryAccountName": {
              "type": "string",
              "metadata": {
                "description": "Azure AI Foundry account name"
              }
            },
            "deploymentSuffix": {
              "type": "string",
              "defaultValue": "agent-v1",
              "metadata": {
                "description": "Unique suffix for role assignment names to ensure idempotency"
              }
            }
          },
          "variables": {
            "CosmosDBDataContributor": "00000000-0000-0000-0000-000000000002",
            "SearchIndexDataContributor": "8ebe5a00-799e-43f5-93ac-243d3dce84a7",
            "SearchServiceContributor": "7ca78c08-252a-4471-8644-bb5ff32d4ba0",
            "StorageBlobDataOwner": "b7e6dc6d-f1e8-4753-8033-0f276bb0955b",
            "StorageQueueDataContributor": "974c5e8b-45b9-4653-ba55-5f855dd0fb88",
            "CognitiveServicesOpenAIUser": "5e0bd9bd-7b93-4f28-af87-19fc36ad61bd",
            "CognitiveServicesOpenAIContributor": "a001fd3d-188f-4b5d-821b-7da978bf7442"
          },
          "resources": [
            {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlRoleAssignments",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}', parameters('cosmosAccountName'), guid(resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName')), parameters('agentPrincipalId'), variables('CosmosDBDataContributor'), parameters('deploymentSuffix')))]",
              "properties": {
                "principalId": "[parameters('agentPrincipalId')]",
                "roleDefinitionId": "[format('{0}/sqlRoleDefinitions/{1}', resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName')), variables('CosmosDBDataContributor'))]",
                "scope": "[resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName'))]"
              }
            },
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.Search/searchServices', parameters('searchServiceName'))]",
              "name": "[guid(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), parameters('agentPrincipalId'), variables('SearchIndexDataContributor'), parameters('deploymentSuffix'))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', variables('SearchIndexDataContributor'))]",
                "principalId": "[parameters('agentPrincipalId')]",
                "principalType": "ServicePrincipal"
              }
            },
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.Search/searchServices', parameters('searchServiceName'))]",
              "name": "[guid(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), parameters('agentPrincipalId'), variables('SearchServiceContributor'), parameters('deploymentSuffix'))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', variables('SearchServiceContributor'))]",
                "principalId": "[parameters('agentPrincipalId')]",
                "principalType": "ServicePrincipal"
              }
            },
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName'))]",
              "name": "[guid(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), parameters('agentPrincipalId'), variables('StorageBlobDataOwner'), parameters('deploymentSuffix'))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', variables('StorageBlobDataOwner'))]",
                "principalId": "[parameters('agentPrincipalId')]",
                "principalType": "ServicePrincipal"
              }
            },
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName'))]",
              "name": "[guid(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), parameters('agentPrincipalId'), variables('StorageQueueDataContributor'), parameters('deploymentSuffix'))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', variables('StorageQueueDataContributor'))]",
                "principalId": "[parameters('agentPrincipalId')]",
                "principalType": "ServicePrincipal"
              }
            },
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryAccountName'))]",
              "name": "[guid(resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryAccountName')), parameters('agentPrincipalId'), variables('CognitiveServicesOpenAIUser'), parameters('deploymentSuffix'))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', variables('CognitiveServicesOpenAIUser'))]",
                "principalId": "[parameters('agentPrincipalId')]",
                "principalType": "ServicePrincipal"
              }
            },
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryAccountName'))]",
              "name": "[guid(resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryAccountName')), parameters('agentPrincipalId'), variables('CognitiveServicesOpenAIContributor'), parameters('deploymentSuffix'))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', variables('CognitiveServicesOpenAIContributor'))]",
                "principalId": "[parameters('agentPrincipalId')]",
                "principalType": "ServicePrincipal"
              }
            }
          ],
          "outputs": {
            "cosmosRoleAssignmentId": {
              "type": "string",
              "value": "[resourceId('Microsoft.DocumentDB/databaseAccounts/sqlRoleAssignments', parameters('cosmosAccountName'), guid(resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName')), parameters('agentPrincipalId'), variables('CosmosDBDataContributor'), parameters('deploymentSuffix')))]"
            },
            "searchIndexRoleAssignmentId": {
              "type": "string",
              "value": "[extensionResourceId(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), parameters('agentPrincipalId'), variables('SearchIndexDataContributor'), parameters('deploymentSuffix')))]"
            },
            "searchServiceRoleAssignmentId": {
              "type": "string",
              "value": "[extensionResourceId(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), parameters('agentPrincipalId'), variables('SearchServiceContributor'), parameters('deploymentSuffix')))]"
            },
            "storageBlobRoleAssignmentId": {
              "type": "string",
              "value": "[extensionResourceId(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), parameters('agentPrincipalId'), variables('StorageBlobDataOwner'), parameters('deploymentSuffix')))]"
            },
            "storageQueueRoleAssignmentId": {
              "type": "string",
              "value": "[extensionResourceId(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), parameters('agentPrincipalId'), variables('StorageQueueDataContributor'), parameters('deploymentSuffix')))]"
            },
            "foundryOpenAIUserRoleAssignmentId": {
              "type": "string",
              "value": "[extensionResourceId(resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryAccountName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryAccountName')), parameters('agentPrincipalId'), variables('CognitiveServicesOpenAIUser'), parameters('deploymentSuffix')))]"
            },
            "foundryOpenAIContributorRoleAssignmentId": {
              "type": "string",
              "value": "[extensionResourceId(resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryAccountName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryAccountName')), parameters('agentPrincipalId'), variables('CognitiveServicesOpenAIContributor'), parameters('deploymentSuffix')))]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'foundry')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'nextBestActionAgentIdentity')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'searchService')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'storage')]"
      ]
    },
    {
      "condition": "[parameters('agentIdentityEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "appInsightsRoleAssignmentAgent",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "appInsightsName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'monitoring'), '2025-04-01').outputs.applicationInsightsName.value]"
          },
          "roleDefinitionID": {
            "value": "[variables('monitoringRoleDefinitionId')]"
          },
          "principalID": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'nextBestActionAgentIdentity'), '2025-04-01').outputs.agentIdentityPrincipalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "10378639561665210744"
            }
          },
          "parameters": {
            "principalID": {
              "type": "string"
            },
            "roleDefinitionID": {
              "type": "string"
            },
            "appInsightsName": {
              "type": "string"
            },
            "nameSuffix": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Optional suffix to make role assignment name unique across deployments"
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.Insights/components', parameters('appInsightsName'))]",
              "name": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.Insights/components', parameters('appInsightsName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.Insights/components', parameters('appInsightsName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalId": "[parameters('principalID')]",
                "principalType": "ServicePrincipal"
              }
            }
          ],
          "outputs": {
            "ROLE_ASSIGNMENT_NAME": {
              "type": "string",
              "value": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.Insights/components', parameters('appInsightsName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.Insights/components', parameters('appInsightsName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'monitoring')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'nextBestActionAgentIdentity')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "condition": "[parameters('approvalLogicAppEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "agentsApprovalLogicApp",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "logicAppName": {
            "value": "[format('{0}approval-{1}', variables('abbrs').logicWorkflows, variables('resourceToken'))]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "cosmosDbAccountName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount'), '2025-04-01').outputs.name.value]"
          },
          "cosmosDbDatabaseName": {
            "value": "[parameters('cosmosDatabaseName')]"
          },
          "cosmosDbContainerName": {
            "value": "approvals"
          },
          "teamsChannelId": {
            "value": "[parameters('teamsChannelId')]"
          },
          "teamsGroupId": {
            "value": "[parameters('teamsGroupId')]"
          },
          "approvalTimeoutHours": {
            "value": "[parameters('approvalTimeoutHours')]"
          },
          "userAssignedIdentityId": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity'), '2025-04-01').outputs.identityId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "7051954686553992697"
            }
          },
          "parameters": {
            "logicAppName": {
              "type": "string",
              "metadata": {
                "description": "The name of the Logic App"
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "The location for all resources"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags to apply to all resources"
              }
            },
            "cosmosDbAccountName": {
              "type": "string",
              "metadata": {
                "description": "The CosmosDB account name for audit logging"
              }
            },
            "cosmosDbDatabaseName": {
              "type": "string",
              "defaultValue": "mcpdb",
              "metadata": {
                "description": "The CosmosDB database name"
              }
            },
            "cosmosDbContainerName": {
              "type": "string",
              "defaultValue": "approvals",
              "metadata": {
                "description": "The CosmosDB container name for approvals"
              }
            },
            "teamsChannelId": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "The Teams channel ID for approval notifications"
              }
            },
            "teamsGroupId": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "The Teams group/team ID for approval notifications"
              }
            },
            "approvalTimeoutHours": {
              "type": "int",
              "defaultValue": 2,
              "metadata": {
                "description": "Approval timeout in hours"
              }
            },
            "userAssignedIdentityId": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "The user-assigned managed identity ID"
              }
            }
          },
          "variables": {
            "CosmosDBDataContributor": "00000000-0000-0000-0000-000000000002",
            "cosmosConnectionName": "[format('{0}-cosmos', parameters('logicAppName'))]",
            "teamsConnectionName": "[format('{0}-teams', parameters('logicAppName'))]"
          },
          "resources": [
            {
              "type": "Microsoft.Web/connections",
              "apiVersion": "2016-06-01",
              "name": "[variables('cosmosConnectionName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "displayName": "CosmosDB Connection for Approvals",
                "api": {
                  "id": "[subscriptionResourceId('Microsoft.Web/locations/managedApis', parameters('location'), 'documentdb')]"
                },
                "parameterValues": {
                  "databaseAccount": "[parameters('cosmosDbAccountName')]",
                  "accessKey": "[listKeys(resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosDbAccountName')), '2024-05-15').primaryMasterKey]"
                }
              }
            },
            {
              "type": "Microsoft.Web/connections",
              "apiVersion": "2016-06-01",
              "name": "[variables('teamsConnectionName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "displayName": "Teams Connection for Approvals",
                "api": {
                  "id": "[subscriptionResourceId('Microsoft.Web/locations/managedApis', parameters('location'), 'teams')]"
                }
              }
            },
            {
              "type": "Microsoft.Logic/workflows",
              "apiVersion": "2019-05-01",
              "name": "[parameters('logicAppName')]",
              "location": "[parameters('location')]",
              "tags": "[union(parameters('tags'), createObject('azd-service-name', 'agents-approval-workflow'))]",
              "identity": "[if(empty(parameters('userAssignedIdentityId')), createObject('type', 'SystemAssigned'), createObject('type', 'UserAssigned', 'userAssignedIdentities', createObject(format('{0}', parameters('userAssignedIdentityId')), createObject())))]",
              "properties": {
                "state": "Enabled",
                "definition": {
                  "$schema": "https://schema.management.azure.com/providers/Microsoft.Logic/schemas/2016-06-01/workflowdefinition.json#",
                  "contentVersion": "1.0.0.0",
                  "parameters": {
                    "$connections": {
                      "defaultValue": {},
                      "type": "Object"
                    },
                    "teamsChannelId": {
                      "defaultValue": "[parameters('teamsChannelId')]",
                      "type": "String"
                    },
                    "teamsGroupId": {
                      "defaultValue": "[parameters('teamsGroupId')]",
                      "type": "String"
                    },
                    "approvalTimeoutHours": {
                      "defaultValue": "[parameters('approvalTimeoutHours')]",
                      "type": "Int"
                    },
                    "cosmosDbEndpoint": {
                      "defaultValue": "[format('https://{0}.documents.azure.com', parameters('cosmosDbAccountName'))]",
                      "type": "String"
                    }
                  },
                  "triggers": {
                    "When_an_HTTP_request_is_received": {
                      "type": "Request",
                      "kind": "Http",
                      "inputs": {
                        "schema": {
                          "type": "object",
                          "properties": {
                            "approval_id": {
                              "type": "string"
                            },
                            "task": {
                              "type": "string"
                            },
                            "environment": {
                              "type": "string"
                            },
                            "cluster": {
                              "type": "string"
                            },
                            "namespace": {
                              "type": "string"
                            },
                            "image_tags": {
                              "type": "array"
                            },
                            "commit_sha": {
                              "type": "string"
                            },
                            "requested_by": {
                              "type": "string"
                            },
                            "callback_url": {
                              "type": "string"
                            }
                          },
                          "required": [
                            "approval_id",
                            "task",
                            "environment",
                            "cluster",
                            "callback_url"
                          ]
                        }
                      }
                    }
                  },
                  "actions": {
                    "Initialize_Approval_Record": {
                      "type": "InitializeVariable",
                      "runAfter": {},
                      "inputs": {
                        "variables": [
                          {
                            "name": "approvalRecord",
                            "type": "object",
                            "value": {
                              "approval_id": "@{triggerBody()?['approval_id']}",
                              "task": "@{triggerBody()?['task']}",
                              "environment": "@{triggerBody()?['environment']}",
                              "status": "pending",
                              "created_at": "@{utcNow()}"
                            }
                          }
                        ]
                      }
                    },
                    "Start_Teams_Approval": {
                      "type": "ApiConnectionWebhook",
                      "runAfter": {
                        "Initialize_Approval_Record": [
                          "Succeeded"
                        ]
                      },
                      "inputs": {
                        "host": {
                          "connection": {
                            "name": "@parameters('$connections')['teams']['connectionId']"
                          }
                        },
                        "body": {
                          "notificationUrl": "@{listCallbackUrl()}",
                          "message": {
                            "title": "CI/CD Deployment Approval - @{triggerBody()?['environment']}",
                            "details": "Deployment to @{triggerBody()?['cluster']} requested"
                          },
                          "approvalType": "CustomResponse",
                          "customResponses": [
                            {
                              "response": "Approve",
                              "comment": {
                                "isOptional": true
                              }
                            },
                            {
                              "response": "Reject",
                              "comment": {
                                "isOptional": false
                              }
                            }
                          ]
                        },
                        "path": "/v2/approvals/create"
                      },
                      "limit": {
                        "timeout": "PT@{parameters('approvalTimeoutHours')}H"
                      }
                    },
                    "Notify_Agent_Of_Decision": {
                      "type": "Http",
                      "runAfter": {
                        "Start_Teams_Approval": [
                          "Succeeded"
                        ]
                      },
                      "inputs": {
                        "method": "POST",
                        "uri": "@{triggerBody()?['callback_url']}",
                        "body": {
                          "approval_id": "@{triggerBody()?['approval_id']}",
                          "decision": "@{body('Start_Teams_Approval')?['outcome']}",
                          "approved_by": "@{body('Start_Teams_Approval')?['responder']?['displayName']}",
                          "timestamp": "@{utcNow()}"
                        },
                        "headers": {
                          "Content-Type": "application/json"
                        }
                      }
                    },
                    "Response": {
                      "type": "Response",
                      "runAfter": {
                        "Notify_Agent_Of_Decision": [
                          "Succeeded"
                        ]
                      },
                      "inputs": {
                        "statusCode": 200,
                        "body": "@variables('approvalRecord')"
                      }
                    }
                  }
                },
                "parameters": {
                  "$connections": {
                    "value": {
                      "documentdb": {
                        "connectionId": "[resourceId('Microsoft.Web/connections', variables('cosmosConnectionName'))]",
                        "connectionName": "documentdb",
                        "id": "[subscriptionResourceId('Microsoft.Web/locations/managedApis', parameters('location'), 'documentdb')]"
                      },
                      "teams": {
                        "connectionId": "[resourceId('Microsoft.Web/connections', variables('teamsConnectionName'))]",
                        "connectionName": "teams",
                        "id": "[subscriptionResourceId('Microsoft.Web/locations/managedApis', parameters('location'), 'teams')]"
                      }
                    }
                  }
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.Web/connections', variables('cosmosConnectionName'))]",
                "[resourceId('Microsoft.Web/connections', variables('teamsConnectionName'))]"
              ]
            },
            {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlRoleAssignments",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}', parameters('cosmosDbAccountName'), guid(resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosDbAccountName')), resourceId('Microsoft.Logic/workflows', parameters('logicAppName')), variables('CosmosDBDataContributor'), 'logicapp'))]",
              "properties": {
                "principalId": "[reference(resourceId('Microsoft.Logic/workflows', parameters('logicAppName')), '2019-05-01', 'full').identity.principalId]",
                "roleDefinitionId": "[format('{0}/sqlRoleDefinitions/{1}', resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosDbAccountName')), variables('CosmosDBDataContributor'))]",
                "scope": "[resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosDbAccountName'))]"
              },
              "dependsOn": [
                "[resourceId('Microsoft.Logic/workflows', parameters('logicAppName'))]"
              ]
            },
            {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases/containers",
              "apiVersion": "2023-04-15",
              "name": "[format('{0}/{1}/{2}', parameters('cosmosDbAccountName'), parameters('cosmosDbDatabaseName'), parameters('cosmosDbContainerName'))]",
              "properties": {
                "resource": {
                  "id": "[parameters('cosmosDbContainerName')]",
                  "partitionKey": {
                    "paths": [
                      "/environment"
                    ],
                    "kind": "Hash"
                  },
                  "indexingPolicy": {
                    "indexingMode": "consistent",
                    "includedPaths": [
                      {
                        "path": "/*"
                      }
                    ],
                    "excludedPaths": [
                      {
                        "path": "/\"_etag\"/?"
                      }
                    ]
                  },
                  "defaultTtl": -1
                }
              }
            }
          ],
          "outputs": {
            "logicAppTriggerUrl": {
              "type": "string",
              "metadata": {
                "description": "The Logic App trigger URL for approval requests"
              },
              "value": "[listCallbackUrl(format('{0}/triggers/When_an_HTTP_request_is_received', resourceId('Microsoft.Logic/workflows', parameters('logicAppName'))), '2019-05-01').value]"
            },
            "logicAppId": {
              "type": "string",
              "metadata": {
                "description": "The Logic App resource ID"
              },
              "value": "[resourceId('Microsoft.Logic/workflows', parameters('logicAppName'))]"
            },
            "logicAppName": {
              "type": "string",
              "metadata": {
                "description": "The Logic App name"
              },
              "value": "[parameters('logicAppName')]"
            },
            "logicAppPrincipalId": {
              "type": "string",
              "metadata": {
                "description": "The Logic App managed identity principal ID"
              },
              "value": "[reference(resourceId('Microsoft.Logic/workflows', parameters('logicAppName')), '2019-05-01', 'full').identity.principalId]"
            },
            "approvalsContainerName": {
              "type": "string",
              "metadata": {
                "description": "The approvals container name"
              },
              "value": "[parameters('cosmosDbContainerName')]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "condition": "[and(parameters('defenderEnabled'), not(empty(parameters('defenderSecurityContactEmail'))))]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "defender",
      "location": "[deployment().location]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "securityContactEmail": {
            "value": "[parameters('defenderSecurityContactEmail')]"
          },
          "securityContactPhone": {
            "value": "[parameters('defenderSecurityContactPhone')]"
          },
          "enableDefenderForContainers": {
            "value": "[parameters('defenderForContainersEnabled')]"
          },
          "enableDefenderForKeyVault": {
            "value": "[parameters('defenderForKeyVaultEnabled')]"
          },
          "enableDefenderForCosmosDB": {
            "value": "[parameters('defenderForCosmosDBEnabled')]"
          },
          "enableDefenderForAPIs": {
            "value": "[parameters('defenderForAPIsEnabled')]"
          },
          "enableDefenderForResourceManager": {
            "value": "[parameters('defenderForResourceManagerEnabled')]"
          },
          "enableDefenderForContainerRegistry": {
            "value": "[parameters('defenderForContainerRegistryEnabled')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2018-05-01/subscriptionDeploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "16546419597969339712"
            }
          },
          "parameters": {
            "securityContactEmail": {
              "type": "string",
              "metadata": {
                "description": "Email address for security contact notifications"
              }
            },
            "securityContactPhone": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Phone number for security contact notifications"
              }
            },
            "enableDefenderForContainers": {
              "type": "bool",
              "defaultValue": true,
              "metadata": {
                "description": "Enable Defender for Containers"
              }
            },
            "enableDefenderForKeyVault": {
              "type": "bool",
              "defaultValue": true,
              "metadata": {
                "description": "Enable Defender for Key Vault"
              }
            },
            "enableDefenderForCosmosDB": {
              "type": "bool",
              "defaultValue": true,
              "metadata": {
                "description": "Enable Defender for Azure Cosmos DB"
              }
            },
            "enableDefenderForAPIs": {
              "type": "bool",
              "defaultValue": true,
              "metadata": {
                "description": "Enable Defender for APIs (API Management)"
              }
            },
            "enableDefenderForResourceManager": {
              "type": "bool",
              "defaultValue": true,
              "metadata": {
                "description": "Enable Defender for Resource Manager"
              }
            },
            "enableDefenderForContainerRegistry": {
              "type": "bool",
              "defaultValue": true,
              "metadata": {
                "description": "Enable Defender for Container Registries"
              }
            }
          },
          "resources": [
            {
              "condition": "[parameters('enableDefenderForContainers')]",
              "type": "Microsoft.Security/pricings",
              "apiVersion": "2024-01-01",
              "name": "Containers",
              "properties": {
                "pricingTier": "Standard",
                "subPlan": "P2",
                "extensions": [
                  {
                    "name": "ContainerRegistriesVulnerabilityAssessments",
                    "isEnabled": "True"
                  },
                  {
                    "name": "AgentlessDiscoveryForKubernetes",
                    "isEnabled": "True"
                  },
                  {
                    "name": "AgentlessVmScanning",
                    "isEnabled": "True"
                  }
                ]
              }
            },
            {
              "condition": "[parameters('enableDefenderForKeyVault')]",
              "type": "Microsoft.Security/pricings",
              "apiVersion": "2024-01-01",
              "name": "KeyVaults",
              "properties": {
                "pricingTier": "Standard"
              }
            },
            {
              "condition": "[parameters('enableDefenderForCosmosDB')]",
              "type": "Microsoft.Security/pricings",
              "apiVersion": "2024-01-01",
              "name": "CosmosDbs",
              "properties": {
                "pricingTier": "Standard"
              }
            },
            {
              "condition": "[parameters('enableDefenderForAPIs')]",
              "type": "Microsoft.Security/pricings",
              "apiVersion": "2024-01-01",
              "name": "Api",
              "properties": {
                "pricingTier": "Standard",
                "subPlan": "P1"
              }
            },
            {
              "condition": "[parameters('enableDefenderForResourceManager')]",
              "type": "Microsoft.Security/pricings",
              "apiVersion": "2024-01-01",
              "name": "Arm",
              "properties": {
                "pricingTier": "Standard"
              }
            },
            {
              "condition": "[parameters('enableDefenderForContainerRegistry')]",
              "type": "Microsoft.Security/pricings",
              "apiVersion": "2024-01-01",
              "name": "ContainerRegistry",
              "properties": {
                "pricingTier": "Standard"
              }
            },
            {
              "type": "Microsoft.Security/securityContacts",
              "apiVersion": "2020-01-01-preview",
              "name": "default",
              "properties": {
                "emails": "[parameters('securityContactEmail')]",
                "phone": "[parameters('securityContactPhone')]",
                "alertNotifications": {
                  "state": "On",
                  "minimalSeverity": "Medium"
                },
                "notificationsByRole": {
                  "state": "On",
                  "roles": [
                    "Owner"
                  ]
                }
              }
            },
            {
              "type": "Microsoft.Security/autoProvisioningSettings",
              "apiVersion": "2017-08-01-preview",
              "name": "default",
              "properties": {
                "autoProvision": "On"
              }
            }
          ],
          "outputs": {
            "defenderForContainersEnabled": {
              "type": "bool",
              "value": "[parameters('enableDefenderForContainers')]"
            },
            "defenderForKeyVaultEnabled": {
              "type": "bool",
              "value": "[parameters('enableDefenderForKeyVault')]"
            },
            "defenderForCosmosDBEnabled": {
              "type": "bool",
              "value": "[parameters('enableDefenderForCosmosDB')]"
            },
            "defenderForAPIsEnabled": {
              "type": "bool",
              "value": "[parameters('enableDefenderForAPIs')]"
            },
            "defenderForResourceManagerEnabled": {
              "type": "bool",
              "value": "[parameters('enableDefenderForResourceManager')]"
            },
            "securityContactConfigured": {
              "type": "bool",
              "value": true
            }
          }
        }
      }
    },
    {
      "condition": "[parameters('purviewEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "purviewAccount",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "name": {
            "value": "[variables('purviewResourceName')]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "managedIdentityType": {
            "value": "SystemAssigned"
          },
          "publicNetworkAccess": "[if(parameters('vnetEnabled'), createObject('value', 'Disabled'), createObject('value', 'Enabled'))]"
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "6999092489626464191"
            },
            "description": "Create a Microsoft Purview account for data governance and compliance."
          },
          "parameters": {
            "name": {
              "type": "string"
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]"
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            },
            "managedIdentityType": {
              "type": "string",
              "defaultValue": "SystemAssigned",
              "allowedValues": [
                "SystemAssigned",
                "UserAssigned",
                "SystemAssigned,UserAssigned"
              ],
              "metadata": {
                "description": "Managed identity type for the Purview account"
              }
            },
            "publicNetworkAccess": {
              "type": "string",
              "defaultValue": "Disabled",
              "allowedValues": [
                "Enabled",
                "Disabled"
              ],
              "metadata": {
                "description": "Public network access configuration"
              }
            },
            "managedResourceGroupName": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Managed resource group name for Purview managed resources"
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.Purview/accounts",
              "apiVersion": "2021-12-01",
              "name": "[parameters('name')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "identity": {
                "type": "[parameters('managedIdentityType')]"
              },
              "properties": {
                "publicNetworkAccess": "[parameters('publicNetworkAccess')]",
                "managedResourceGroupName": "[if(not(empty(parameters('managedResourceGroupName'))), parameters('managedResourceGroupName'), format('{0}-managed-rg', parameters('name')))]"
              }
            }
          ],
          "outputs": {
            "id": {
              "type": "string",
              "value": "[resourceId('Microsoft.Purview/accounts', parameters('name'))]"
            },
            "name": {
              "type": "string",
              "value": "[parameters('name')]"
            },
            "endpoint": {
              "type": "string",
              "value": "[format('https://{0}.purview.azure.com', parameters('name'))]"
            },
            "catalogEndpoint": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Purview/accounts', parameters('name')), '2021-12-01').endpoints.catalog]"
            },
            "scanEndpoint": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Purview/accounts', parameters('name')), '2021-12-01').endpoints.scan]"
            },
            "principalId": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Purview/accounts', parameters('name')), '2021-12-01', 'full').identity.principalId]"
            },
            "managedResourceGroupName": {
              "type": "string",
              "value": "[reference(resourceId('Microsoft.Purview/accounts', parameters('name')), '2021-12-01').managedResources.resourceGroup]"
            }
          }
        }
      },
      "dependsOn": [
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "condition": "[and(parameters('purviewEnabled'), parameters('vnetEnabled'))]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "purviewPrivateEndpoint",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "virtualNetworkName": {
            "value": "[variables('serviceVirtualNetworkName')]"
          },
          "subnetName": "[if(parameters('vnetEnabled'), createObject('value', variables('serviceVirtualNetworkPrivateEndpointSubnetName')), createObject('value', ''))]",
          "resourceName": {
            "value": "[variables('purviewResourceName')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "9995743730417929651"
            }
          },
          "parameters": {
            "virtualNetworkName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the virtual network."
              }
            },
            "subnetName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the subnet which contains the private endpoints."
              }
            },
            "resourceName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the resource name of the Purview account."
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Specifies the location."
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            }
          },
          "variables": {
            "purviewPrivateDNSZoneNames": [
              "privatelink.purview.azure.com",
              "privatelink.purviewstudio.azure.com"
            ]
          },
          "resources": [
            {
              "copy": {
                "name": "purviewPrivateDnsZones",
                "count": "[length(variables('purviewPrivateDNSZoneNames'))]"
              },
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2020-06-01",
              "name": "[variables('purviewPrivateDNSZoneNames')[copyIndex()]]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {}
            },
            {
              "copy": {
                "name": "purviewPrivateDnsZoneVirtualNetworkLinks",
                "count": "[length(variables('purviewPrivateDNSZoneNames'))]"
              },
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('purviewPrivateDNSZoneNames')[copyIndex()], format('{0}-purview-link-{1}-{2}', parameters('resourceName'), copyIndex(), take(toLower(uniqueString(parameters('resourceName'), parameters('virtualNetworkName'))), 4)))]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.Network/privateDnsZones', variables('purviewPrivateDNSZoneNames')[copyIndex()])]"
              ]
            },
            {
              "type": "Microsoft.Network/privateEndpoints",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}-account-private-endpoint', parameters('resourceName'))]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "privateLinkServiceConnections": [
                  {
                    "name": "purviewAccountPrivateLinkConnection",
                    "properties": {
                      "privateLinkServiceId": "[resourceId('Microsoft.Purview/accounts', parameters('resourceName'))]",
                      "groupIds": [
                        "account"
                      ]
                    }
                  }
                ],
                "subnet": {
                  "id": "[format('{0}/subnets/{1}', resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName')), parameters('subnetName'))]"
                }
              }
            },
            {
              "type": "Microsoft.Network/privateEndpoints/privateDnsZoneGroups",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', format('{0}-account-private-endpoint', parameters('resourceName')), 'purviewAccountPrivateDnsZoneGroup')]",
              "properties": {
                "privateDnsZoneConfigs": [
                  {
                    "name": "config-account",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('purviewPrivateDNSZoneNames')[0])]"
                    }
                  }
                ]
              },
              "dependsOn": [
                "[resourceId('Microsoft.Network/privateEndpoints', format('{0}-account-private-endpoint', parameters('resourceName')))]",
                "[resourceId('Microsoft.Network/privateDnsZones', variables('purviewPrivateDNSZoneNames')[0])]"
              ]
            },
            {
              "type": "Microsoft.Network/privateEndpoints",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}-portal-private-endpoint', parameters('resourceName'))]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "privateLinkServiceConnections": [
                  {
                    "name": "purviewPortalPrivateLinkConnection",
                    "properties": {
                      "privateLinkServiceId": "[resourceId('Microsoft.Purview/accounts', parameters('resourceName'))]",
                      "groupIds": [
                        "portal"
                      ]
                    }
                  }
                ],
                "subnet": {
                  "id": "[format('{0}/subnets/{1}', resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName')), parameters('subnetName'))]"
                }
              }
            },
            {
              "type": "Microsoft.Network/privateEndpoints/privateDnsZoneGroups",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', format('{0}-portal-private-endpoint', parameters('resourceName')), 'purviewPortalPrivateDnsZoneGroup')]",
              "properties": {
                "privateDnsZoneConfigs": [
                  {
                    "name": "config-portal",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('purviewPrivateDNSZoneNames')[1])]"
                    }
                  }
                ]
              },
              "dependsOn": [
                "[resourceId('Microsoft.Network/privateEndpoints', format('{0}-portal-private-endpoint', parameters('resourceName')))]",
                "[resourceId('Microsoft.Network/privateDnsZones', variables('purviewPrivateDNSZoneNames')[1])]"
              ]
            }
          ],
          "outputs": {
            "accountPrivateEndpointId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateEndpoints', format('{0}-account-private-endpoint', parameters('resourceName')))]"
            },
            "portalPrivateEndpointId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateEndpoints', format('{0}-portal-private-endpoint', parameters('resourceName')))]"
            },
            "privateDnsZoneIds": {
              "type": "array",
              "copy": {
                "count": "[length(variables('purviewPrivateDNSZoneNames'))]",
                "input": "[resourceId('Microsoft.Network/privateDnsZones', variables('purviewPrivateDNSZoneNames')[copyIndex()])]"
              }
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'purviewAccount')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'serviceVirtualNetwork')]"
      ]
    },
    {
      "condition": "[and(parameters('purviewEnabled'), parameters('agentIdentityEnabled'))]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "purviewAgentRole",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "purviewAccountName": {
            "value": "[variables('purviewResourceName')]"
          },
          "roleDefinitionID": {
            "value": "[variables('PurviewDataReader')]"
          },
          "principalID": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'nextBestActionAgentIdentity'), '2025-04-01').outputs.agentIdentityPrincipalId.value]"
          },
          "principalType": {
            "value": "ServicePrincipal"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "14153658865631901674"
            }
          },
          "parameters": {
            "purviewAccountName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Purview account."
              }
            },
            "roleDefinitionID": {
              "type": "string",
              "metadata": {
                "description": "Role definition ID to assign (use built-in Azure RBAC roles)."
              }
            },
            "principalID": {
              "type": "string",
              "metadata": {
                "description": "Principal ID to assign the role to."
              }
            },
            "principalType": {
              "type": "string",
              "defaultValue": "ServicePrincipal",
              "metadata": {
                "description": "Principal type: User, Group, or ServicePrincipal."
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.Purview/accounts', parameters('purviewAccountName'))]",
              "name": "[guid(resourceId('Microsoft.Purview/accounts', parameters('purviewAccountName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              }
            }
          ],
          "outputs": {
            "roleAssignmentId": {
              "type": "string",
              "value": "[extensionResourceId(resourceId('Microsoft.Purview/accounts', parameters('purviewAccountName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.Purview/accounts', parameters('purviewAccountName')), parameters('principalID'), parameters('roleDefinitionID')))]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'nextBestActionAgentIdentity')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    },
    {
      "condition": "[parameters('purviewEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "purviewScanCosmosRole",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "cosmosAccountName": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount'), '2025-04-01').outputs.name.value]"
          },
          "roleDefinitionID": {
            "value": "00000000-0000-0000-0000-000000000001"
          },
          "principalID": {
            "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'purviewAccount'), '2025-04-01').outputs.principalId.value]"
          },
          "principalType": {
            "value": "ServicePrincipal"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "14872110188757982160"
            }
          },
          "parameters": {
            "cosmosAccountName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Cosmos DB account."
              }
            },
            "roleDefinitionID": {
              "type": "string",
              "metadata": {
                "description": "Role definition ID to assign."
              }
            },
            "principalID": {
              "type": "string",
              "metadata": {
                "description": "Principal ID to assign the role to."
              }
            },
            "principalType": {
              "type": "string",
              "defaultValue": "ServicePrincipal",
              "metadata": {
                "description": "Principal type: User, Group, or ServicePrincipal."
              }
            }
          },
          "resources": [
            {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlRoleAssignments",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}', parameters('cosmosAccountName'), guid(resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName')), parameters('principalID'), parameters('roleDefinitionID')))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[format('{0}/sqlRoleDefinitions/{1}', resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName')), parameters('roleDefinitionID'))]",
                "scope": "[resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName'))]"
              }
            }
          ],
          "outputs": {
            "roleAssignmentId": {
              "type": "string",
              "value": "[resourceId('Microsoft.DocumentDB/databaseAccounts/sqlRoleAssignments', parameters('cosmosAccountName'), guid(resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName')), parameters('principalID'), parameters('roleDefinitionID')))]"
            }
          }
        }
      },
      "dependsOn": [
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount')]",
        "[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'purviewAccount')]",
        "[subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName'))))]"
      ]
    }
  ],
  "outputs": {
    "APPLICATIONINSIGHTS_CONNECTION_STRING": {
      "type": "string",
      "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'monitoring'), '2025-04-01').outputs.applicationInsightsConnectionString.value]"
    },
    "AZURE_LOCATION": {
      "type": "string",
      "value": "[parameters('location')]"
    },
    "AZURE_TENANT_ID": {
      "type": "string",
      "value": "[tenant().tenantId]"
    },
    "AKS_CLUSTER_NAME": {
      "type": "string",
      "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'aksCluster'), '2025-04-01').outputs.aksClusterName.value]"
    },
    "CONTAINER_REGISTRY": {
      "type": "string",
      "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'containerRegistry'), '2025-04-01').outputs.containerRegistryLoginServer.value]"
    },
    "AZURE_STORAGE_ACCOUNT_URL": {
      "type": "string",
      "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'storage'), '2025-04-01').outputs.primaryEndpoints.value.blob]"
    },
    "MCP_SERVER_IDENTITY_CLIENT_ID": {
      "type": "string",
      "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpUserAssignedIdentity'), '2025-04-01').outputs.identityClientId.value]"
    },
    "SERVICE_API_ENDPOINTS": {
      "type": "array",
      "value": [
        "[format('{0}/mcp/sse', reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', variables('apiManagementName')), '2025-04-01').outputs.gatewayUrl.value)]"
      ]
    },
    "APIM_GATEWAY_URL": {
      "type": "string",
      "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', variables('apiManagementName')), '2025-04-01').outputs.gatewayUrl.value]"
    },
    "MCP_BASE_URL": {
      "type": "string",
      "value": "[format('{0}/mcp', reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', variables('apiManagementName')), '2025-04-01').outputs.gatewayUrl.value)]"
    },
    "MCP_OAUTH_AUTHORIZE_URL": {
      "type": "string",
      "value": "[format('{0}/mcp/oauth/authorize', reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', variables('apiManagementName')), '2025-04-01').outputs.gatewayUrl.value)]"
    },
    "MCP_OAUTH_TOKEN_URL": {
      "type": "string",
      "value": "[format('{0}/mcp/oauth/token', reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', variables('apiManagementName')), '2025-04-01').outputs.gatewayUrl.value)]"
    },
    "MCP_CLIENT_ID": {
      "type": "string",
      "value": "[parameters('existingEntraAppId')]"
    },
    "AZURE_RESOURCE_GROUP_NAME": {
      "type": "string",
      "value": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]"
    },
    "AZURE_SUBSCRIPTION_ID": {
      "type": "string",
      "value": "[subscription().subscriptionId]"
    },
    "MCP_PUBLIC_IP_ADDRESS": {
      "type": "string",
      "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'mcpPublicIp'), '2025-04-01').outputs.publicIpAddress.value]"
    },
    "MCP_PUBLIC_IP_NAME": {
      "type": "string",
      "value": "[format('pip-mcp-{0}', variables('resourceToken'))]"
    },
    "FOUNDRY_PROJECT_ENDPOINT": {
      "type": "string",
      "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'foundry'), '2025-04-01').outputs.projectEndpoint.value]"
    },
    "FOUNDRY_MODEL_DEPLOYMENT_NAME": {
      "type": "string",
      "value": "[parameters('foundryModelDeploymentName')]"
    },
    "FOUNDRY_ACCOUNT_NAME": {
      "type": "string",
      "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'foundry'), '2025-04-01').outputs.foundryAccountName.value]"
    },
    "EMBEDDING_MODEL_DEPLOYMENT_NAME": {
      "type": "string",
      "value": "[parameters('embeddingModelDeploymentName')]"
    },
    "COSMOSDB_ENDPOINT": {
      "type": "string",
      "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount'), '2025-04-01').outputs.endpoint.value]"
    },
    "COSMOSDB_DATABASE_NAME": {
      "type": "string",
      "value": "[parameters('cosmosDatabaseName')]"
    },
    "COSMOSDB_ACCOUNT_NAME": {
      "type": "string",
      "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount'), '2025-04-01').outputs.name.value]"
    },
    "COSMOS_ACCOUNT_URI": {
      "type": "string",
      "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'cosmosAccount'), '2025-04-01').outputs.endpoint.value]"
    },
    "COSMOS_DATABASE_NAME": {
      "type": "string",
      "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'lightningCosmos'), '2025-04-01').outputs.databaseName.value]"
    },
    "AZURE_SEARCH_ENDPOINT": {
      "type": "string",
      "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'searchService'), '2025-04-01').outputs.endpoint.value]"
    },
    "AZURE_SEARCH_INDEX_NAME": {
      "type": "string",
      "value": "[parameters('searchIndexName')]"
    },
    "AZURE_SEARCH_SERVICE_NAME": {
      "type": "string",
      "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'searchService'), '2025-04-01').outputs.name.value]"
    },
    "ONTOLOGY_CONTAINER_NAME": {
      "type": "string",
      "value": "[variables('ontologyContainerName')]"
    },
    "ONTOLOGY_STORAGE_URL": {
      "type": "string",
      "value": "[format('{0}{1}', reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'storage'), '2025-04-01').outputs.primaryEndpoints.value.blob, variables('ontologyContainerName'))]"
    },
    "FABRIC_CAPACITY_NAME": {
      "type": "string",
      "value": "[if(parameters('fabricEnabled'), reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'fabricCapacity'), '2025-04-01').outputs.name.value, '')]"
    },
    "FABRIC_ENABLED": {
      "type": "bool",
      "value": "[parameters('fabricEnabled')]"
    },
    "FABRIC_ONELAKE_DFS_ENDPOINT": {
      "type": "string",
      "value": "[if(parameters('fabricEnabled'), 'https://onelake.dfs.fabric.microsoft.com', '')]"
    },
    "FABRIC_ONELAKE_BLOB_ENDPOINT": {
      "type": "string",
      "value": "[if(parameters('fabricEnabled'), 'https://onelake.blob.fabric.microsoft.com', '')]"
    },
    "FABRIC_DATA_AGENTS_ENABLED": {
      "type": "bool",
      "value": "[parameters('fabricDataAgentsEnabled')]"
    },
    "FABRIC_WORKSPACE_ID": {
      "type": "string",
      "value": "[parameters('fabricWorkspaceId')]"
    },
    "FABRIC_API_ENDPOINT": {
      "type": "string",
      "value": "[if(parameters('fabricEnabled'), 'https://api.fabric.microsoft.com/v1', '')]"
    },
    "AGENT_IDENTITY_ENABLED": {
      "type": "bool",
      "value": "[parameters('agentIdentityEnabled')]"
    },
    "AGENT_IDENTITY_BLUEPRINT_APP_ID": {
      "type": "string",
      "value": "[if(parameters('agentIdentityEnabled'), reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'agentIdentityBlueprint'), '2025-04-01').outputs.blueprintAppId.value, '')]"
    },
    "AGENT_IDENTITY_APP_ID": {
      "type": "string",
      "value": "[if(parameters('agentIdentityEnabled'), reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'nextBestActionAgentIdentity'), '2025-04-01').outputs.agentIdentityAppId.value, '')]"
    },
    "AGENT_IDENTITY_PRINCIPAL_ID": {
      "type": "string",
      "value": "[if(parameters('agentIdentityEnabled'), reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'nextBestActionAgentIdentity'), '2025-04-01').outputs.agentIdentityPrincipalId.value, '')]"
    },
    "AGENT_IDENTITY_DISPLAY_NAME": {
      "type": "string",
      "value": "[if(parameters('agentIdentityEnabled'), reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'nextBestActionAgentIdentity'), '2025-04-01').outputs.agentDisplayName.value, '')]"
    },
    "APPROVAL_LOGIC_APP_ENABLED": {
      "type": "bool",
      "value": "[parameters('approvalLogicAppEnabled')]"
    },
    "APPROVAL_LOGIC_APP_TRIGGER_URL": {
      "type": "string",
      "value": "[if(parameters('approvalLogicAppEnabled'), reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'agentsApprovalLogicApp'), '2025-04-01').outputs.logicAppTriggerUrl.value, '')]"
    },
    "APPROVAL_LOGIC_APP_NAME": {
      "type": "string",
      "value": "[if(parameters('approvalLogicAppEnabled'), reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'agentsApprovalLogicApp'), '2025-04-01').outputs.logicAppName.value, '')]"
    },
    "GRAFANA_ENABLED": {
      "type": "bool",
      "value": "[parameters('grafanaEnabled')]"
    },
    "GRAFANA_NAME": {
      "type": "string",
      "value": "[if(parameters('grafanaEnabled'), reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'grafana'), '2025-04-01').outputs.name.value, '')]"
    },
    "GRAFANA_ENDPOINT": {
      "type": "string",
      "value": "[if(parameters('grafanaEnabled'), reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'grafana'), '2025-04-01').outputs.endpoint.value, '')]"
    },
    "GRAFANA_RESOURCE_ID": {
      "type": "string",
      "value": "[if(parameters('grafanaEnabled'), reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'grafana'), '2025-04-01').outputs.id.value, '')]"
    },
    "DEFENDER_ENABLED": {
      "type": "bool",
      "value": "[parameters('defenderEnabled')]"
    },
    "DEFENDER_DEPLOYED": {
      "type": "bool",
      "value": "[and(parameters('defenderEnabled'), not(empty(parameters('defenderSecurityContactEmail'))))]"
    },
    "DEFENDER_FOR_CONTAINERS_ENABLED": {
      "type": "bool",
      "value": "[parameters('defenderForContainersEnabled')]"
    },
    "DEFENDER_FOR_KEY_VAULT_ENABLED": {
      "type": "bool",
      "value": "[parameters('defenderForKeyVaultEnabled')]"
    },
    "DEFENDER_FOR_COSMOS_DB_ENABLED": {
      "type": "bool",
      "value": "[parameters('defenderForCosmosDBEnabled')]"
    },
    "DEFENDER_FOR_APIS_ENABLED": {
      "type": "bool",
      "value": "[parameters('defenderForAPIsEnabled')]"
    },
    "DEFENDER_FOR_RESOURCE_MANAGER_ENABLED": {
      "type": "bool",
      "value": "[parameters('defenderForResourceManagerEnabled')]"
    },
    "PURVIEW_ENABLED": {
      "type": "bool",
      "value": "[parameters('purviewEnabled')]"
    },
    "PURVIEW_ACCOUNT_NAME": {
      "type": "string",
      "value": "[if(parameters('purviewEnabled'), reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'purviewAccount'), '2025-04-01').outputs.name.value, '')]"
    },
    "PURVIEW_ENDPOINT": {
      "type": "string",
      "value": "[if(parameters('purviewEnabled'), reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'purviewAccount'), '2025-04-01').outputs.endpoint.value, '')]"
    },
    "PURVIEW_CATALOG_ENDPOINT": {
      "type": "string",
      "value": "[if(parameters('purviewEnabled'), reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'purviewAccount'), '2025-04-01').outputs.catalogEndpoint.value, '')]"
    },
    "PURVIEW_SCAN_ENDPOINT": {
      "type": "string",
      "value": "[if(parameters('purviewEnabled'), reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'purviewAccount'), '2025-04-01').outputs.scanEndpoint.value, '')]"
    },
    "PURVIEW_MANAGED_RESOURCE_GROUP": {
      "type": "string",
      "value": "[if(parameters('purviewEnabled'), reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', subscription().subscriptionId, if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), 'Microsoft.Resources/deployments', 'purviewAccount'), '2025-04-01').outputs.managedResourceGroupName.value, '')]"
    }
  }
}