{
  "$schema": "https://schema.management.azure.com/schemas/2018-05-01/subscriptionDeploymentTemplate.json#",
  "languageVersion": "2.1-experimental",
  "contentVersion": "1.0.0.0",
  "metadata": {
    "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
    "_EXPERIMENTAL_FEATURES_ENABLED": [
      "Extensibility"
    ],
    "_generator": {
      "name": "bicep",
      "version": "0.28.1.47646",
      "templateHash": "16099000511877538652"
    }
  },
  "parameters": {
    "environmentName": {
      "type": "string",
      "minLength": 1,
      "maxLength": 64,
      "metadata": {
        "description": "Name of the the environment which is used to generate a short unique hash used in all resources."
      }
    },
    "location": {
      "type": "string",
      "allowedValues": [
        "australiaeast",
        "eastasia",
        "eastus",
        "eastus2",
        "northeurope",
        "southcentralus",
        "southeastasia",
        "swedencentral",
        "uksouth",
        "westus2",
        "eastus2euap"
      ],
      "metadata": {
        "azd": {
          "type": "location"
        },
        "description": "Primary location for all resources"
      },
      "minLength": 1
    },
    "vnetEnabled": {
      "type": "bool"
    },
    "apiServiceName": {
      "type": "string",
      "defaultValue": ""
    },
    "apiUserAssignedIdentityName": {
      "type": "string",
      "defaultValue": ""
    },
    "applicationInsightsName": {
      "type": "string",
      "defaultValue": ""
    },
    "logAnalyticsName": {
      "type": "string",
      "defaultValue": ""
    },
    "resourceGroupName": {
      "type": "string",
      "defaultValue": ""
    },
    "storageAccountName": {
      "type": "string",
      "defaultValue": ""
    },
    "vNetName": {
      "type": "string",
      "defaultValue": ""
    },
    "mcpEntraApplicationDisplayName": {
      "type": "string",
      "defaultValue": ""
    },
    "mcpEntraApplicationUniqueName": {
      "type": "string",
      "defaultValue": ""
    },
    "existingEntraAppId": {
      "type": "string",
      "defaultValue": ""
    },
    "disableLocalAuth": {
      "type": "bool",
      "defaultValue": true
    },
    "foundryName": {
      "type": "string",
      "defaultValue": ""
    },
    "foundryModelDeploymentName": {
      "type": "string",
      "defaultValue": "gpt-5.2-chat"
    },
    "foundryModelName": {
      "type": "string",
      "defaultValue": "gpt-5.2-chat"
    },
    "foundryModelVersion": {
      "type": "string",
      "defaultValue": "2025-12-11"
    },
    "foundryModelCapacity": {
      "type": "int",
      "defaultValue": 10
    },
    "embeddingModelDeploymentName": {
      "type": "string",
      "defaultValue": "text-embedding-3-large"
    },
    "embeddingModelName": {
      "type": "string",
      "defaultValue": "text-embedding-3-large"
    },
    "embeddingModelVersion": {
      "type": "string",
      "defaultValue": "1"
    },
    "embeddingModelCapacity": {
      "type": "int",
      "defaultValue": 10
    },
    "cosmosDbAccountName": {
      "type": "string",
      "defaultValue": ""
    },
    "cosmosDatabaseName": {
      "type": "string",
      "defaultValue": "mcpdb"
    },
    "searchServiceName": {
      "type": "string",
      "defaultValue": ""
    },
    "searchIndexName": {
      "type": "string",
      "defaultValue": "task-instructions"
    },
    "fabricCapacityName": {
      "type": "string",
      "defaultValue": ""
    },
    "fabricSkuName": {
      "type": "string",
      "defaultValue": "F2",
      "allowedValues": [
        "F2",
        "F4",
        "F8",
        "F16",
        "F32",
        "F64",
        "F128",
        "F256",
        "F512",
        "F1024",
        "F2048"
      ]
    },
    "fabricAdminEmail": {
      "type": "string",
      "defaultValue": ""
    },
    "fabricEnabled": {
      "type": "bool",
      "defaultValue": false
    },
    "fabricDataAgentsEnabled": {
      "type": "bool",
      "defaultValue": false,
      "metadata": {
        "description": "Enable Fabric Data Agents for lakehouse, warehouse, pipeline, and semantic model operations"
      }
    },
    "fabricWorkspaceId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Fabric workspace ID for data agents (optional - can be created separately)"
      }
    },
    "agentIdentityEnabled": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Enable Entra Agent Identity for the Next Best Action agent (preview feature)"
      }
    },
    "agentBlueprintDisplayName": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Display name for the Agent Identity Blueprint"
      }
    },
    "agentIdentityDisplayName": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Display name for the Next Best Action Agent Identity"
      }
    },
    "agentSponsorPrincipalId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Principal ID of sponsor user for agent identity (admin user)"
      }
    },
    "developerPrincipalId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Principal ID of developer user for local development Cosmos DB access (optional)"
      }
    },
    "developerIpAddress": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Developer IP address for Cosmos DB firewall access (optional, for local development)"
      }
    },
    "approvalLogicAppEnabled": {
      "type": "bool",
      "defaultValue": false,
      "metadata": {
        "description": "Enable the approval Logic App for CI/CD governance"
      }
    },
    "teamsChannelId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Teams channel ID for approval notifications"
      }
    },
    "teamsGroupId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Teams group/team ID for approval notifications"
      }
    },
    "approvalTimeoutHours": {
      "type": "int",
      "defaultValue": 2,
      "metadata": {
        "description": "Approval timeout in hours"
      }
    },
    "grafanaEnabled": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Enable Azure Managed Grafana for AKS monitoring dashboards"
      }
    },
    "grafanaName": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Name for the Azure Managed Grafana instance"
      }
    },
    "defenderEnabled": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Enable Microsoft Defender for Cloud"
      }
    },
    "defenderSecurityContactEmail": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Email address for Defender security contact notifications"
      }
    },
    "defenderSecurityContactPhone": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Phone number for Defender security contact notifications"
      }
    },
    "defenderForContainersEnabled": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Enable Defender for Containers"
      }
    },
    "defenderForKeyVaultEnabled": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Enable Defender for Key Vault"
      }
    },
    "defenderForCosmosDBEnabled": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Enable Defender for Azure Cosmos DB"
      }
    },
    "defenderForAPIsEnabled": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Enable Defender for APIs (API Management)"
      }
    },
    "defenderForResourceManagerEnabled": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Enable Defender for Resource Manager"
      }
    },
    "defenderForContainerRegistryEnabled": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Enable Defender for Container Registries"
      }
    },
    "purviewEnabled": {
      "type": "bool",
      "defaultValue": false,
      "metadata": {
        "description": "Enable Microsoft Purview for data governance and compliance"
      }
    },
    "purviewAccountName": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Name for the Microsoft Purview account"
      }
    }
  },
  "variables": {
    "$fxv#0": {
      "analysisServicesServers": "as",
      "apiManagementService": "apim-",
      "appConfigurationConfigurationStores": "appcs-",
      "applications": "app-",
      "appManagedEnvironments": "cae-",
      "appContainerApps": "ca-",
      "authorizationPolicyDefinitions": "policy-",
      "automationAutomationAccounts": "aa-",
      "blueprintBlueprints": "bp-",
      "blueprintBlueprintsArtifacts": "bpa-",
      "cacheRedis": "redis-",
      "cdnProfiles": "cdnp-",
      "cdnProfilesEndpoints": "cdne-",
      "cognitiveServicesAccounts": "cog-",
      "cognitiveServicesFormRecognizer": "cog-fr-",
      "cognitiveServicesTextAnalytics": "cog-ta-",
      "computeAvailabilitySets": "avail-",
      "computeCloudServices": "cld-",
      "computeDiskEncryptionSets": "des",
      "computeDisks": "disk",
      "computeDisksOs": "osdisk",
      "computeGalleries": "gal",
      "computeSnapshots": "snap-",
      "computeVirtualMachines": "vm",
      "computeVirtualMachineScaleSets": "vmss-",
      "containerInstanceContainerGroups": "ci",
      "containerRegistryRegistries": "cr",
      "containerServiceManagedClusters": "aks-",
      "databricksWorkspaces": "dbw-",
      "dataFactoryFactories": "adf-",
      "dataLakeAnalyticsAccounts": "dla",
      "dataLakeStoreAccounts": "dls",
      "dataMigrationServices": "dms-",
      "dBforMySQLServers": "mysql-",
      "dBforPostgreSQLServers": "psql-",
      "devicesIotHubs": "iot-",
      "devicesProvisioningServices": "provs-",
      "devicesProvisioningServicesCertificates": "pcert-",
      "documentDBDatabaseAccounts": "cosmos-",
      "eventGridDomains": "evgd-",
      "eventGridDomainsTopics": "evgt-",
      "eventGridEventSubscriptions": "evgs-",
      "eventHubNamespaces": "evhns-",
      "eventHubNamespacesEventHubs": "evh-",
      "fabricCapacities": "fc",
      "hdInsightClustersHadoop": "hadoop-",
      "hdInsightClustersHbase": "hbase-",
      "hdInsightClustersKafka": "kafka-",
      "hdInsightClustersMl": "mls-",
      "hdInsightClustersSpark": "spark-",
      "hdInsightClustersStorm": "storm-",
      "hybridComputeMachines": "arcs-",
      "insightsActionGroups": "ag-",
      "insightsComponents": "appi-",
      "keyVaultVaults": "kv-",
      "kubernetesConnectedClusters": "arck",
      "kustoClusters": "dec",
      "kustoClustersDatabases": "dedb",
      "logicIntegrationAccounts": "ia-",
      "logicWorkflows": "logic-",
      "machineLearningServicesWorkspaces": "mlw-",
      "managedIdentityUserAssignedIdentities": "id-",
      "managementManagementGroups": "mg-",
      "migrateAssessmentProjects": "migr-",
      "networkApplicationGateways": "agw-",
      "networkApplicationSecurityGroups": "asg-",
      "networkAzureFirewalls": "afw-",
      "networkBastionHosts": "bas-",
      "networkConnections": "con-",
      "networkDnsZones": "dnsz-",
      "networkExpressRouteCircuits": "erc-",
      "networkFirewallPolicies": "afwp-",
      "networkFirewallPoliciesWebApplication": "waf",
      "networkFirewallPoliciesRuleGroups": "wafrg",
      "networkFrontDoors": "fd-",
      "networkFrontdoorWebApplicationFirewallPolicies": "fdfp-",
      "networkLoadBalancersExternal": "lbe-",
      "networkLoadBalancersInternal": "lbi-",
      "networkLoadBalancersInboundNatRules": "rule-",
      "networkLocalNetworkGateways": "lgw-",
      "networkNatGateways": "ng-",
      "networkNetworkInterfaces": "nic-",
      "networkNetworkSecurityGroups": "nsg-",
      "networkNetworkSecurityGroupsSecurityRules": "nsgsr-",
      "networkNetworkWatchers": "nw-",
      "networkPrivateDnsZones": "pdnsz-",
      "networkPrivateLinkServices": "pl-",
      "networkPublicIPAddresses": "pip-",
      "networkPublicIPPrefixes": "ippre-",
      "networkRouteFilters": "rf-",
      "networkRouteTables": "rt-",
      "networkRouteTablesRoutes": "udr-",
      "networkTrafficManagerProfiles": "traf-",
      "networkVirtualNetworkGateways": "vgw-",
      "networkVirtualNetworks": "vnet-",
      "networkVirtualNetworksSubnets": "snet-",
      "networkVirtualNetworksVirtualNetworkPeerings": "peer-",
      "networkVirtualWans": "vwan-",
      "networkVpnGateways": "vpng-",
      "networkVpnGatewaysVpnConnections": "vcn-",
      "networkVpnGatewaysVpnSites": "vst-",
      "notificationHubsNamespaces": "ntfns-",
      "notificationHubsNamespacesNotificationHubs": "ntf-",
      "operationalInsightsWorkspaces": "log-",
      "portalDashboards": "dash-",
      "powerBIDedicatedCapacities": "pbi-",
      "purviewAccounts": "pview-",
      "recoveryServicesVaults": "rsv-",
      "resourcesResourceGroups": "rg-",
      "searchSearchServices": "srch-",
      "serviceBusNamespaces": "sb-",
      "serviceBusNamespacesQueues": "sbq-",
      "serviceBusNamespacesTopics": "sbt-",
      "serviceEndPointPolicies": "se-",
      "serviceFabricClusters": "sf-",
      "signalRServiceSignalR": "sigr",
      "sqlManagedInstances": "sqlmi-",
      "sqlServers": "sql-",
      "sqlServersDataWarehouse": "sqldw-",
      "sqlServersDatabases": "sqldb-",
      "sqlServersDatabasesStretch": "sqlstrdb-",
      "storageStorageAccounts": "st",
      "storageStorageAccountsVm": "stvm",
      "storSimpleManagers": "ssimp",
      "streamAnalyticsCluster": "asa-",
      "synapseWorkspaces": "syn",
      "synapseWorkspacesAnalyticsWorkspaces": "synw",
      "synapseWorkspacesSqlPoolsDedicated": "syndp",
      "synapseWorkspacesSqlPoolsSpark": "synsp",
      "timeSeriesInsightsEnvironments": "tsi-",
      "webServerFarms": "plan-",
      "webSitesAppService": "app-",
      "webSitesAppServiceEnvironment": "ase-",
      "webSitesFunctions": "func-",
      "webStaticSites": "stapp-"
    },
    "ontologyContainerName": "ontologies",
    "oauth_scopes": "openid https://graph.microsoft.com/.default",
    "abbrs": "[variables('$fxv#0')]",
    "resourceToken": "[toLower(uniqueString(subscription().id, parameters('environmentName'), parameters('location')))]",
    "tags": {
      "azd-env-name": "[parameters('environmentName')]"
    },
    "functionAppName": "[if(not(empty(parameters('apiServiceName'))), parameters('apiServiceName'), format('{0}api-{1}', variables('abbrs').webSitesFunctions, variables('resourceToken')))]",
    "deploymentStorageContainerName": "[format('app-package-{0}-{1}', take(variables('functionAppName'), 32), take(toLower(uniqueString(variables('functionAppName'), variables('resourceToken'))), 7))]",
    "serviceVirtualNetworkName": "[if(not(empty(parameters('vNetName'))), parameters('vNetName'), format('{0}{1}', variables('abbrs').networkVirtualNetworks, variables('resourceToken')))]",
    "serviceVirtualNetworkAppSubnetName": "app",
    "serviceVirtualNetworkPrivateEndpointSubnetName": "private-endpoints-subnet",
    "apimResourceToken": "[toLower(uniqueString(subscription().id, parameters('resourceGroupName'), parameters('environmentName'), parameters('location')))]",
    "apiManagementName": "[format('{0}{1}', variables('abbrs').apiManagementService, variables('apimResourceToken'))]",
    "agentBlueprintName": "[if(not(empty(parameters('agentBlueprintDisplayName'))), parameters('agentBlueprintDisplayName'), format('NextBestAction-Blueprint-{0}', variables('resourceToken')))]",
    "agentName": "[if(not(empty(parameters('agentIdentityDisplayName'))), parameters('agentIdentityDisplayName'), format('NextBestAction-Agent-{0}', variables('resourceToken')))]",
    "azureMonitorWorkspaceName": "[format('amw-{0}', variables('resourceToken'))]",
    "acrPullRoleDefinitionId": "7f951dda-4ed3-4680-a7ca-43fe172d538d",
    "StorageBlobDataOwner": "b7e6dc6d-f1e8-4753-8033-0f276bb0955b",
    "StorageQueueDataContributor": "974c5e8b-45b9-4653-ba55-5f855dd0fb88",
    "foundryResourceName": "[if(not(empty(parameters('foundryName'))), parameters('foundryName'), format('{0}{1}', variables('abbrs').cognitiveServicesAccounts, variables('resourceToken')))]",
    "bingResourceName": "[format('bing-{0}', variables('resourceToken'))]",
    "CognitiveServicesOpenAIUser": "5e0bd9bd-7b93-4f28-af87-19fc36ad61bd",
    "AzureAIDeveloper": "64702f94-c441-49e6-a78b-ef80e0188fee",
    "cosmosResourceName": "[if(not(empty(parameters('cosmosDbAccountName'))), parameters('cosmosDbAccountName'), format('{0}{1}', variables('abbrs').documentDBDatabaseAccounts, variables('resourceToken')))]",
    "CosmosDBDataContributor": "00000000-0000-0000-0000-000000000002",
    "searchResourceName": "[if(not(empty(parameters('searchServiceName'))), parameters('searchServiceName'), format('{0}{1}', variables('abbrs').searchSearchServices, variables('resourceToken')))]",
    "SearchIndexDataContributor": "8ebe5a00-799e-43f5-93ac-243d3dce84a7",
    "SearchServiceContributor": "7ca78c08-252a-4471-8644-bb5ff32d4ba0",
    "fabricResourceName": "[if(not(empty(parameters('fabricCapacityName'))), parameters('fabricCapacityName'), toLower(format('{0}{1}', variables('abbrs').fabricCapacities, replace(variables('resourceToken'), '-', ''))))]",
    "monitoringRoleDefinitionId": "3913510d-42f4-4e42-8a64-420c390055eb",
    "grafanaResourceName": "[if(not(empty(parameters('grafanaName'))), parameters('grafanaName'), format('amg-{0}', variables('resourceToken')))]",
    "MonitoringReader": "43d0d8ad-25c7-4714-9337-8ba259a9fe05",
    "ReaderRole": "acdd72a7-3385-48ef-bd42-f606fba81ae7",
    "MonitoringDataReader": "b0d8363b-8ddd-447d-831f-62ca05bff136",
    "purviewResourceName": "[if(not(empty(parameters('purviewAccountName'))), parameters('purviewAccountName'), format('purview-{0}', variables('resourceToken')))]",
    "PurviewDataReader": "4c48d476-69c1-41d0-88c2-9ac66e4b64f4"
  },
  "resources": {
    "rg": {
      "type": "Microsoft.Resources/resourceGroups",
      "apiVersion": "2021-04-01",
      "name": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "location": "[parameters('location')]",
      "tags": "[variables('tags')]"
    },
    "apimService": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "[variables('apiManagementName')]",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "apiManagementName": {
            "value": "[variables('apiManagementName')]"
          },
          "logAnalyticsWorkspaceId": {
            "value": "[reference('monitoring').outputs.logAnalyticsWorkspaceId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "15206660664935237178"
            }
          },
          "parameters": {
            "apiManagementName": {
              "type": "string",
              "metadata": {
                "description": "The name of the API Management instance. Defaults to \"apim-<resourceSuffix>\"."
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "The location of the API Management instance. Defaults to the resource group location."
              }
            },
            "publisherEmail": {
              "type": "string",
              "defaultValue": "noreply@microsoft.com",
              "metadata": {
                "description": "The email address of the publisher. Defaults to \"noreply@microsoft.com\"."
              }
            },
            "publisherName": {
              "type": "string",
              "defaultValue": "Microsoft",
              "metadata": {
                "description": "The name of the publisher. Defaults to \"Microsoft\"."
              }
            },
            "apimLoggerName": {
              "type": "string",
              "defaultValue": "apim-logger",
              "metadata": {
                "description": "Name of the APIM Logger"
              }
            },
            "apimLoggerDescription": {
              "type": "string",
              "defaultValue": "APIM Logger for OpenAI API",
              "metadata": {
                "description": "Description of the APIM Logger"
              }
            },
            "apimSku": {
              "type": "string",
              "defaultValue": "Basicv2",
              "allowedValues": [
                "Consumption",
                "Developer",
                "Basic",
                "Basicv2",
                "Standard",
                "Standardv2",
                "Premium"
              ],
              "metadata": {
                "description": "The pricing tier of this API Management service"
              }
            },
            "appInsightsInstrumentationKey": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "The instrumentation key for Application Insights"
              }
            },
            "appInsightsId": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "The resource ID for Application Insights"
              }
            },
            "entraAppUserAssignedIdentityName": {
              "type": "string",
              "defaultValue": "entra-app-user-assigned-identity",
              "metadata": {
                "description": "The name of the user-assigned managed identity used as entra app FIC"
              }
            },
            "logAnalyticsWorkspaceId": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "The resource ID of the Log Analytics workspace for diagnostic settings"
              }
            }
          },
          "resources": {
            "entraAppUserAssignedIdentity": {
              "type": "Microsoft.ManagedIdentity/userAssignedIdentities",
              "apiVersion": "2023-01-31",
              "name": "[parameters('entraAppUserAssignedIdentityName')]",
              "location": "[parameters('location')]"
            },
            "apimService": {
              "type": "Microsoft.ApiManagement/service",
              "apiVersion": "2024-06-01-preview",
              "name": "[parameters('apiManagementName')]",
              "location": "[parameters('location')]",
              "sku": {
                "name": "[parameters('apimSku')]",
                "capacity": 1
              },
              "properties": {
                "publisherEmail": "[parameters('publisherEmail')]",
                "publisherName": "[parameters('publisherName')]"
              },
              "identity": {
                "type": "SystemAssigned, UserAssigned",
                "userAssignedIdentities": {
                  "[format('{0}', resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', parameters('entraAppUserAssignedIdentityName')))]": {}
                }
              },
              "dependsOn": [
                "entraAppUserAssignedIdentity"
              ]
            },
            "apimLogger": {
              "condition": "[and(not(empty(parameters('appInsightsId'))), not(empty(parameters('appInsightsInstrumentationKey'))))]",
              "type": "Microsoft.ApiManagement/service/loggers",
              "apiVersion": "2021-12-01-preview",
              "name": "[format('{0}/{1}', parameters('apiManagementName'), parameters('apimLoggerName'))]",
              "properties": {
                "credentials": {
                  "instrumentationKey": "[parameters('appInsightsInstrumentationKey')]"
                },
                "description": "[parameters('apimLoggerDescription')]",
                "isBuffered": false,
                "loggerType": "applicationInsights",
                "resourceId": "[parameters('appInsightsId')]"
              },
              "dependsOn": [
                "apimService"
              ]
            },
            "apimDiagnosticSettings": {
              "condition": "[not(empty(parameters('logAnalyticsWorkspaceId')))]",
              "type": "Microsoft.Insights/diagnosticSettings",
              "apiVersion": "2021-05-01-preview",
              "scope": "[format('Microsoft.ApiManagement/service/{0}', parameters('apiManagementName'))]",
              "name": "apim-to-loganalytics",
              "properties": {
                "workspaceId": "[parameters('logAnalyticsWorkspaceId')]",
                "logs": [
                  {
                    "categoryGroup": "allLogs",
                    "enabled": true
                  }
                ],
                "metrics": [
                  {
                    "category": "AllMetrics",
                    "enabled": true
                  }
                ]
              },
              "dependsOn": [
                "apimService"
              ]
            }
          },
          "outputs": {
            "id": {
              "type": "string",
              "value": "[resourceId('Microsoft.ApiManagement/service', parameters('apiManagementName'))]"
            },
            "name": {
              "type": "string",
              "value": "[parameters('apiManagementName')]"
            },
            "principalId": {
              "type": "string",
              "value": "[reference('apimService', '2024-06-01-preview', 'full').identity.principalId]"
            },
            "gatewayUrl": {
              "type": "string",
              "value": "[reference('apimService').gatewayUrl]"
            },
            "entraAppUserAssignedIdentityPrincipleId": {
              "type": "string",
              "value": "[reference('entraAppUserAssignedIdentity').principalId]"
            },
            "entraAppUserAssignedIdentityClientId": {
              "type": "string",
              "value": "[reference('entraAppUserAssignedIdentity').clientId]"
            }
          }
        }
      },
      "dependsOn": [
        "monitoring",
        "rg"
      ]
    },
    "oauthAPIModule": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "oauthAPIModule",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "entraAppUniqueName": "[if(not(empty(parameters('mcpEntraApplicationUniqueName'))), createObject('value', parameters('mcpEntraApplicationUniqueName')), createObject('value', format('mcp-oauth-{0}{1}', variables('abbrs').applications, variables('apimResourceToken'))))]",
          "entraAppDisplayName": "[if(not(empty(parameters('mcpEntraApplicationDisplayName'))), createObject('value', parameters('mcpEntraApplicationDisplayName')), createObject('value', format('MCP-OAuth-{0}{1}', variables('abbrs').applications, variables('apimResourceToken'))))]",
          "apimServiceName": {
            "value": "[variables('apiManagementName')]"
          },
          "oauthScopes": {
            "value": "[variables('oauth_scopes')]"
          },
          "entraAppUserAssignedIdentityPrincipleId": {
            "value": "[reference('apimService').outputs.entraAppUserAssignedIdentityPrincipleId.value]"
          },
          "entraAppUserAssignedIdentityClientId": {
            "value": "[reference('apimService').outputs.entraAppUserAssignedIdentityClientId.value]"
          },
          "existingEntraAppId": {
            "value": "[parameters('existingEntraAppId')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "17436555717549830054"
            }
          },
          "parameters": {
            "apimServiceName": {
              "type": "string",
              "metadata": {
                "description": "The name of the API Management service"
              }
            },
            "location": {
              "type": "string",
              "metadata": {
                "description": "The Azure region for resources"
              }
            },
            "oauthScopes": {
              "type": "string",
              "metadata": {
                "description": "The required scopes for authorization"
              }
            },
            "entraAppUserAssignedIdentityPrincipleId": {
              "type": "string",
              "metadata": {
                "description": "The principle id of the user-assigned managed identity for Entra app"
              }
            },
            "entraAppUserAssignedIdentityClientId": {
              "type": "string",
              "metadata": {
                "description": "The client ID of the user-assigned managed identity for Entra app"
              }
            },
            "entraAppUniqueName": {
              "type": "string",
              "metadata": {
                "description": "The name of the Entra application"
              }
            },
            "entraAppDisplayName": {
              "type": "string",
              "metadata": {
                "description": "The display name of the Entra application"
              }
            },
            "mcpServerName": {
              "type": "string",
              "defaultValue": "MCP Server",
              "metadata": {
                "description": "The name of the MCP Server to display in the consent page"
              }
            },
            "existingEntraAppId": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Pre-created Entra application client ID (temporary parameter until Microsoft Graph extension is supported)"
              }
            }
          },
          "variables": {
            "$fxv#0": "<!--\r\n    AUTHORIZE POLICY\r\n    This policy implements the authorization endpoint for PKCE OAuth2 flow with Entra ID.\r\n    \r\n    SECURITY NOTE: User consent is validated ONLY through secure HttpOnly cookies set by \r\n    the consent endpoint. No query parameters can bypass consent validation.\r\n    \r\n    Flow:\r\n    1. MCP client calls this endpoint with code_challenge and code_challenge_method\r\n    2. Check for existing user consent via secure cookies (redirect to consent page if needed)\r\n    3. We generate a code verifier and challenge for Entra ID\r\n    4. We generate a confirmation code to return to the MCP client later\r\n    5. We redirect the user to Entra ID login page\r\n    6. After authentication, Entra ID will redirect back to the callback endpoint\r\n-->\r\n<policies>\r\n    <inbound>\r\n        <base />\r\n        <!-- STEP 1: Retrieve PKCE parameters from MCP Client request -->\r\n        <set-variable name=\"mcpClientCodeChallenge\" value=\"@((string)context.Request.Url.Query.GetValueOrDefault(\"code_challenge\", \"\"))\" />\r\n        <set-variable name=\"mcpClientCodeChallengeMethod\" value=\"@((string)context.Request.Url.Query.GetValueOrDefault(\"code_challenge_method\", \"\"))\" />\r\n        \r\n        <!-- STEP 2: Extract client ID and parameters -->\r\n        <set-variable name=\"clientId\" value=\"@((string)context.Request.Url.Query.GetValueOrDefault(\"client_id\", \"\"))\" />\r\n        <set-variable name=\"redirect_uri\" value=\"@((string)context.Request.Url.Query.GetValueOrDefault(\"redirect_uri\", \"\"))\" />\r\n        <set-variable name=\"currentState\" value=\"@((string)context.Request.Url.Query.GetValueOrDefault(\"state\", \"\"))\" />\r\n        \r\n        <!-- Normalize the redirect URI for consistent cookie matching -->\r\n        <set-variable name=\"normalized_redirect_uri\" value=\"@{\r\n            string redirectUri = context.Variables.GetValueOrDefault<string>(\"redirect_uri\", \"\");\r\n            if (string.IsNullOrEmpty(redirectUri)) {\r\n                return \"\";\r\n            }\r\n            \r\n            try {\r\n                // URL decode the redirect URI to get the normalized form\r\n                string decodedUri = System.Net.WebUtility.UrlDecode(redirectUri);\r\n                return decodedUri;\r\n            } catch (Exception) {\r\n                // If decoding fails, use the original URI\r\n                return redirectUri;\r\n            }\r\n        }\" />\r\n        \r\n        <!-- Check for existing approval cookie for this client_id and redirect_uri combination -->\r\n        <set-variable name=\"has_approval_cookie\" value=\"@{\r\n            try {\r\n                if (string.IsNullOrEmpty(context.Variables.GetValueOrDefault<string>(\"clientId\", \"\")) || \r\n                    string.IsNullOrEmpty(context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\"))) {\r\n                    return false;\r\n                }\r\n                  \r\n                string clientId = context.Variables.GetValueOrDefault<string>(\"clientId\", \"\");\r\n                string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                \r\n                // Define the cookie name for approvals (must match consent policy)\r\n                string APPROVAL_COOKIE_NAME = \"MCP_APPROVED_CLIENTS\";\r\n                \r\n                // Check for cookie in request\r\n                var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\r\n                if (string.IsNullOrEmpty(cookieHeader)) {\r\n                    return false;\r\n                }\r\n                \r\n                // Parse cookies\r\n                string[] cookies = cookieHeader.Split(';');\r\n                foreach (string cookie in cookies) {\r\n                    string trimmedCookie = cookie.Trim();\r\n                    if (trimmedCookie.StartsWith(APPROVAL_COOKIE_NAME + \"=\")) {\r\n                        try {\r\n                            // Extract and parse the cookie value\r\n                            string cookieValue = trimmedCookie.Substring(APPROVAL_COOKIE_NAME.Length + 1);\r\n                            string decodedValue = System.Text.Encoding.UTF8.GetString(\r\n                                System.Convert.FromBase64String(cookieValue));\r\n                            JArray approvedClients = JArray.Parse(decodedValue);\r\n                            \r\n                            // Check if this client/redirect combination is approved\r\n                            string clientKey = $\"{clientId}:{redirectUri}\";\r\n                            foreach (var item in approvedClients) {\r\n                                if (item.ToString() == clientKey) {\r\n                                    return true;\r\n                                }\r\n                            }\r\n                        } catch (Exception ex) {\r\n                            context.Trace($\"Error parsing approval cookie: {ex.Message}\");\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                \r\n                return false;\r\n            } catch (Exception ex) {\r\n                context.Trace($\"Error checking approval cookie: {ex.Message}\");\r\n                return false;\r\n            }\r\n        }\" />\r\n        \r\n        <!-- Check if the client has been approved via secure cookie -->\r\n        <choose>\r\n            <when condition=\"@(context.Variables.GetValueOrDefault<bool>(\"has_approval_cookie\"))\">\r\n                <!-- Continue with normal flow - client is authorized via secure cookie -->\r\n            </when>\r\n            <otherwise>\r\n                <!-- Redirect to consent page for user approval -->\r\n                <return-response>\r\n                    <set-status code=\"302\" reason=\"Found\" />\r\n                    <set-header name=\"Location\" exists-action=\"override\">\r\n                        <value>@{\r\n                            string basePath = context.Request.OriginalUrl.Scheme + \"://\" + context.Request.OriginalUrl.Host + (context.Request.OriginalUrl.Port == 80 || context.Request.OriginalUrl.Port == 443 ? \"\" : \":\" + context.Request.OriginalUrl.Port);\r\n                            string clientId = context.Variables.GetValueOrDefault<string>(\"clientId\");\r\n                            // Use the normalized (already decoded) redirect_uri to avoid double-encoding\r\n                            string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\");\r\n                            string state = context.Variables.GetValueOrDefault<string>(\"currentState\");\r\n                            string codeChallenge = context.Variables.GetValueOrDefault<string>(\"mcpClientCodeChallenge\");\r\n                            string codeChallengeMethod = context.Variables.GetValueOrDefault<string>(\"mcpClientCodeChallengeMethod\");\r\n                            \r\n                            // URL encode parameters for the consent redirect URL\r\n                            string encodedClientId = System.Net.WebUtility.UrlEncode(clientId);\r\n                            string encodedRedirectUri = System.Net.WebUtility.UrlEncode(redirectUri);\r\n                            \r\n                            // State parameter: use as-is without additional encoding\r\n                            // context.Request.Url.Query.GetValueOrDefault() preserves the original encoding\r\n                            string encodedState = state;\r\n                            \r\n                            // Code challenge parameters: use as-is since they typically don't need encoding\r\n                            string encodedCodeChallenge = codeChallenge;\r\n                            string encodedCodeChallengeMethod = codeChallengeMethod;\r\n                            \r\n                            return $\"{basePath}/consent?client_id={encodedClientId}&redirect_uri={encodedRedirectUri}&state={encodedState}&code_challenge={encodedCodeChallenge}&code_challenge_method={encodedCodeChallengeMethod}\";\r\n                        }</value>\r\n                    </set-header>\r\n                </return-response>\r\n            </otherwise>\r\n        </choose>\r\n        \r\n        <!-- STEP 3: Generate PKCE parameters for Entra ID authentication -->\r\n        <!-- Generate a random code verifier for Entra ID -->\r\n        <set-variable name=\"codeVerifier\" value=\"@((string)Guid.NewGuid().ToString().Replace(\"-\", \"\"))\" />\r\n        <!-- Set the code challenge method for Entra ID -->\r\n        <set-variable name=\"codeChallengeMethod\" value=\"S256\" />\r\n        <!-- Generate a code challenge using SHA-256 for Entra ID -->\r\n        <set-variable name=\"codeChallenge\" value=\"@{\r\n            using (var sha256 = System.Security.Cryptography.SHA256.Create())\r\n            {\r\n                var bytes = System.Text.Encoding.UTF8.GetBytes((string)context.Variables.GetValueOrDefault(\"codeVerifier\", \"\"));\r\n                var hash = sha256.ComputeHash(bytes);\r\n                return System.Convert.ToBase64String(hash).TrimEnd('=').Replace('+', '-').Replace('/', '_');\r\n            }\r\n            }\" />\r\n\r\n        <!-- STEP 4: Construct the Entra ID authorization URL -->\r\n        <!-- Base URL for Entra ID authorization endpoint -->\r\n        <set-variable name=\"baseAuthUrl\" value=\"https://login.microsoftonline.com/{{EntraIDTenantId}}/oauth2/v2.0/authorize?response_type=code\" />\r\n        <!-- Add client ID parameter - using EntraIDClientId instead of the request client ID -->\r\n        <set-variable name=\"clientIdParam\" value=\"@(\"&client_id={{EntraIDClientId}}\")\" />        \r\n        <!-- Add PKCE parameters -->\r\n        <set-variable name=\"codeChallengeParam\" value=\"@(string.Concat(\"&code_challenge=\", context.Variables.GetValueOrDefault(\"codeChallenge\", \"\")))\" />\r\n        <set-variable name=\"codeChallengeMethodParam\" value=\"@(string.Concat(\"&code_challenge_method=\", context.Variables.GetValueOrDefault(\"codeChallengeMethod\", \"\")))\" />\r\n        <!-- Add OAuth callback parameter -->\r\n        <set-variable name=\"redirectUriParam\" value=\"@(string.Concat(\"&redirect_uri=\", \"{{OAuthCallbackUri}}\" ))\" />        \r\n        <!-- Add required scope parameter -->\r\n        <set-variable name=\"scopeParam\" value=\"@(string.Concat(\"&scope={{OAuthScopes}}\"))\" />\r\n        <!-- Generate Entra State -->\r\n        <set-variable name=\"entraState\" value=\"@((string)Guid.NewGuid().ToString())\" />\r\n        <!-- Add state parameter for security -->\r\n        <set-variable name=\"stateParam\" value=\"@(string.Concat(\"&state=\", context.Variables.GetValueOrDefault(\"entraState\", \"\")))\" />\r\n        <!-- Combine all parts to form the complete authorization URL with PKCE params -->\r\n        <set-variable name=\"authUrl\" value=\"@(string.Concat(\r\n            context.Variables.GetValueOrDefault(\"baseAuthUrl\", \"\"), \r\n            context.Variables.GetValueOrDefault(\"clientIdParam\", \"\"), \r\n            context.Variables.GetValueOrDefault(\"codeChallengeParam\", \"\"), \r\n            context.Variables.GetValueOrDefault(\"codeChallengeMethodParam\", \"\"), \r\n            context.Variables.GetValueOrDefault(\"redirectUriParam\", \"\"), \r\n            context.Variables.GetValueOrDefault(\"scopeParam\", \"\"), \r\n            context.Variables.GetValueOrDefault(\"stateParam\", \"\")))\" />        \r\n        \r\n        <!-- STEP 5: Store authentication data in cache for use in callback -->\r\n        <!-- Generate a confirmation code to return to the MCP client -->\r\n        <set-variable name=\"mcpConfirmConsentCode\" value=\"@((string)Guid.NewGuid().ToString())\" />\r\n        \r\n        <!-- Store code verifier for token exchange -->\r\n        <cache-store-value duration=\"3600\" \r\n            key=\"@(\"CodeVerifier-\"+context.Variables.GetValueOrDefault(\"entraState\", \"\"))\" \r\n            value=\"@(context.Variables.GetValueOrDefault(\"codeVerifier\", \"\"))\" />\r\n        \r\n        <!-- Map state to MCP confirmation code for callback -->\r\n        <cache-store-value duration=\"3600\" \r\n            key=\"@((string)context.Variables.GetValueOrDefault(\"entraState\"))\" \r\n            value=\"@(context.Variables.GetValueOrDefault(\"mcpConfirmConsentCode\", \"\"))\" />\r\n\r\n         <!-- Retrieve MCP Client State and Scope from request (Claude sends the state and scope param for binding the auth flow per request) -->\r\n         <set-variable name=\"mcpState\" value=\"@((string)context.Request.Url.Query.GetValueOrDefault(\"state\", \"\"))\" />\r\n         <set-variable name=\"mcpScope\" value=\"@((string)context.Request.Url.Query.GetValueOrDefault(\"scope\", \"\"))\" />\r\n        \r\n        <!-- Store MCP client PKCE data, client state and client callback redirect uri for verification during token exchange -->\r\n        <cache-store-value duration=\"3600\" \r\n            key=\"@($\"McpClientAuthData-{context.Variables.GetValueOrDefault(\"mcpConfirmConsentCode\")}\")\" \r\n            value=\"@{\r\n                // Create a JObject and populate it with values\r\n                return new JObject{\r\n                    [\"mcpClientCodeChallenge\"] = (string)context.Variables.GetValueOrDefault(\"mcpClientCodeChallenge\", \"\"),\r\n                    [\"mcpClientCodeChallengeMethod\"] = (string)context.Variables.GetValueOrDefault(\"mcpClientCodeChallengeMethod\", \"\"),\r\n                    [\"mcpClientState\"] = (string)context.Variables.GetValueOrDefault(\"mcpState\", \"\"),\r\n                    [\"mcpClientScope\"] = (string)context.Variables.GetValueOrDefault(\"mcpScope\", \"\"),\r\n                    [\"mcpCallbackRedirectUri\"] = Uri.UnescapeDataString(context.Variables.GetValueOrDefault(\"redirect_uri\", \"\"))\r\n                }.ToString();\r\n            }\" />\r\n    </inbound>\r\n    <backend>\r\n        <base />\r\n    </backend>\r\n    <outbound>\r\n        <base />        \r\n        <!-- Return the response with a 302 status code for redirect -->\r\n        <return-response>\r\n            <set-status code=\"302\" reason=\"Found\" />\r\n            <set-header name=\"Location\" exists-action=\"override\">\r\n                <value>@(context.Variables.GetValueOrDefault(\"authUrl\", \"\"))</value>\r\n            </set-header>\r\n            <!-- Add cache control headers to ensure browser follows redirect -->\r\n            <set-header name=\"Cache-Control\" exists-action=\"override\">\r\n                <value>no-store, no-cache, must-revalidate</value>\r\n            </set-header>\r\n            <set-header name=\"Pragma\" exists-action=\"override\">\r\n                <value>no-cache</value>\r\n            </set-header>\r\n            <!-- Remove any content-type that might interfere -->\r\n            <set-header name=\"Content-Type\" exists-action=\"delete\" />\r\n        </return-response>\r\n    </outbound>\r\n    <on-error>\r\n        <base />\r\n    </on-error>\r\n</policies>",
            "$fxv#1": "<!--\r\n    SIMPLIFIED TOKEN POLICY - FOR DEBUGGING\r\n    This is a simplified version to test if the basic policy infrastructure works\r\n-->\r\n<policies>\r\n    <inbound>\r\n        <base />\r\n        <!-- Generate a more realistic token response -->\r\n        <set-variable name=\"clientId\" value=\"@{\r\n            // Extract client_id from request body\r\n            var body = context.Request.Body?.As<string>(preserveContent: true) ?? \"\";\r\n            var pairs = body.Split('&');\r\n            foreach (var pair in pairs)\r\n            {\r\n                var keyValue = pair.Split('=');\r\n                if (keyValue.Length == 2 && keyValue[0] == \"client_id\")\r\n                {\r\n                    return System.Net.WebUtility.UrlDecode(keyValue[1]);\r\n                }\r\n            }\r\n            return \"unknown\";\r\n        }\" />\r\n        \r\n        <set-variable name=\"authCode\" value=\"@{\r\n            // Extract code from request body\r\n            var body = context.Request.Body?.As<string>(preserveContent: true) ?? \"\";\r\n            var pairs = body.Split('&');\r\n            foreach (var pair in pairs)\r\n            {\r\n                var keyValue = pair.Split('=');\r\n                if (keyValue.Length == 2 && keyValue[0] == \"code\")\r\n                {\r\n                    return System.Net.WebUtility.UrlDecode(keyValue[1]);\r\n                }\r\n            }\r\n            return \"unknown\";\r\n        }\" />\r\n        \r\n        <return-response>\r\n            <set-status code=\"200\" reason=\"OK\" />\r\n            <set-header name=\"Content-Type\" exists-action=\"override\">\r\n                <value>application/json</value>\r\n            </set-header>\r\n            <set-body>@{\r\n                string clientId = (string)context.Variables.GetValueOrDefault(\"clientId\", \"unknown\");\r\n                string authCode = (string)context.Variables.GetValueOrDefault(\"authCode\", \"unknown\");\r\n                string accessToken = $\"mcp_access_token_{clientId}_{authCode}_{DateTimeOffset.UtcNow.ToUnixTimeSeconds()}\";\r\n                \r\n                return $@\"{{\r\n                    \"\"access_token\"\": \"\"{accessToken}\"\",\r\n                    \"\"token_type\"\": \"\"Bearer\"\",\r\n                    \"\"expires_in\"\": 3600,\r\n                    \"\"scope\"\": \"\"openid https://graph.microsoft.com/.default\"\",\r\n                    \"\"client_id\"\": \"\"{clientId}\"\",\r\n                    \"\"issued_at\"\": {DateTimeOffset.UtcNow.ToUnixTimeSeconds()}\r\n                }}\";\r\n            }</set-body>\r\n        </return-response>\r\n    </inbound>\r\n    <backend>\r\n        <base />\r\n    </backend>\r\n    <outbound>\r\n        <base />\r\n    </outbound>\r\n    <on-error>\r\n        <base />\r\n    </on-error>\r\n</policies>",
            "$fxv#2": "<!--\r\n    SIMPLIFIED OAUTH CALLBACK POLICY - FOR DEBUGGING\r\n    This is a simplified version to test if the basic callback infrastructure works\r\n-->\r\n<policies>\r\n    <inbound>\r\n        <base />\r\n        <!-- Extract the authorization code from the callback -->\r\n        <set-variable name=\"authCode\" value=\"@((string)context.Request.Url.Query.GetValueOrDefault(\"code\", \"\"))\" />\r\n        <set-variable name=\"state\" value=\"@((string)context.Request.Url.Query.GetValueOrDefault(\"state\", \"\"))\" />\r\n        \r\n        <!-- For now, just return a simple success response -->\r\n        <return-response>\r\n            <set-status code=\"200\" reason=\"OK\" />\r\n            <set-header name=\"Content-Type\" exists-action=\"override\">\r\n                <value>text/html</value>\r\n            </set-header>\r\n            <set-body>@{\r\n                string authCode = (string)context.Variables.GetValueOrDefault(\"authCode\", \"none\");\r\n                string state = (string)context.Variables.GetValueOrDefault(\"state\", \"none\");\r\n                return $@\"\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <title>OAuth Callback - Debug</title>\r\n    <style>\r\n        body {{ font-family: Arial, sans-serif; margin: 50px; }}\r\n        .info {{ background: #f0f8ff; padding: 20px; border-radius: 5px; }}\r\n    </style>\r\n</head>\r\n<body>\r\n    <h1>OAuth Callback Received</h1>\r\n    <div class='info'>\r\n        <p><strong>Authorization Code:</strong> {authCode}</p>\r\n        <p><strong>State:</strong> {state}</p>\r\n        <p><strong>Status:</strong> Callback received successfully (simplified policy)</p>\r\n    </div>\r\n    <p>This is a debug version. In production, this would exchange the code for tokens.</p>\r\n</body>\r\n</html>\";\r\n            }</set-body>\r\n        </return-response>\r\n    </inbound>\r\n    <backend>\r\n        <base />\r\n    </backend>\r\n    <outbound>\r\n        <base />\r\n    </outbound>\r\n    <on-error>\r\n        <base />\r\n    </on-error>\r\n</policies>",
            "$fxv#3": "<!--\r\n    REGISTER POLICY\r\n    This policy implements the dynamic client registration endpoint for OAuth2 flow.\r\n    \r\n    Flow:\r\n    1. MCP client sends a registration request with redirect URIs\r\n    2. We store the registration information in cache for later verification\r\n    3. We generate and return client credentials with the provided redirect URIs\r\n-->\r\n<policies>\r\n    <inbound>\r\n        <base />\r\n        <!-- STEP 1: Extract client registration data from request -->\r\n        <set-variable name=\"requestBody\" value=\"@(context.Request.Body.As<JObject>(preserveContent: true))\" />\r\n          <!-- STEP 2: Store registration information in cache -->\r\n        <cache-store-value duration=\"3600\" \r\n            key=\"DynamicClientRegistration\" \r\n            value=\"@(context.Variables.GetValueOrDefault<JObject>(\"requestBody\").ToString())\" />\r\n        \r\n        <!-- Store the redirect URI -->\r\n        <cache-store-value duration=\"3600\" \r\n            key=\"ClientRedirectUri\" \r\n            value=\"@(context.Variables.GetValueOrDefault<JObject>(\"requestBody\")[\"redirect_uris\"][0].ToString())\" />\r\n\r\n        <!-- Generate a unique client ID (GUID) -->\r\n        <set-variable name=\"uniqueClientId\" value=\"@(Guid.NewGuid().ToString())\" />\r\n        \r\n        <!-- Store client info by client ID for easy lookup during consent -->\r\n        <cache-store-value duration=\"3600\" \r\n            key=\"@($\"ClientInfo-{context.Variables.GetValueOrDefault<string>(\"uniqueClientId\")}\")\" \r\n            value=\"@{\r\n                var requestBody = context.Variables.GetValueOrDefault<JObject>(\"requestBody\");\r\n                var clientInfo = new JObject();\r\n                clientInfo[\"client_name\"] = requestBody[\"client_name\"]?.ToString() ?? \"Unknown Application\";\r\n                clientInfo[\"client_uri\"] = requestBody[\"client_uri\"]?.ToString() ?? \"\";\r\n                clientInfo[\"redirect_uris\"] = requestBody[\"redirect_uris\"];\r\n                return clientInfo.ToString();\r\n            }\" />\r\n        \r\n        <!-- STEP 3: Set response content type -->\r\n        <set-header name=\"Content-Type\" exists-action=\"override\">\r\n            <value>application/json</value>\r\n        </set-header>\r\n        \r\n        <!-- STEP 4: Return client credentials response -->\r\n        <return-response>\r\n            <set-status code=\"200\" reason=\"OK\" />\r\n            <set-header name=\"access-control-allow-origin\" exists-action=\"override\">\r\n                <value>*</value>\r\n            </set-header>\r\n            <set-body template=\"none\">@{\r\n                var requestBody = context.Variables.GetValueOrDefault<JObject>(\"requestBody\");\r\n                \r\n                // Generate timestamps dynamically\r\n                // Current time in seconds since epoch (Unix timestamp)\r\n                long currentTimeSeconds = DateTimeOffset.UtcNow.ToUnixTimeSeconds();\r\n                \r\n                // Client ID issued at current time\r\n                long clientIdIssuedAt = currentTimeSeconds;\r\n                \r\n                // Client secret expires in 1 year (31536000 seconds = 365 days)\r\n                long clientSecretExpiresAt = currentTimeSeconds + 31536000;\r\n\r\n                // Use the generated client ID from earlier\r\n                string uniqueClientId = context.Variables.GetValueOrDefault<string>(\"uniqueClientId\", Guid.NewGuid().ToString());\r\n                \r\n                return new JObject\r\n                {\r\n                    [\"client_id\"] = uniqueClientId,\r\n                    [\"client_id_issued_at\"] = clientIdIssuedAt,\r\n                    [\"client_secret_expires_at\"] = clientSecretExpiresAt,\r\n                    [\"redirect_uris\"] = requestBody[\"redirect_uris\"]?.ToObject<JArray>(),\r\n                    [\"client_name\"] = requestBody[\"client_name\"]?.ToString() ?? \"Unknown Application\",\r\n                    [\"client_uri\"] = requestBody[\"client_uri\"]?.ToString() ?? \"\"\r\n                }.ToString();\r\n            }</set-body>\r\n        </return-response>\r\n    </inbound>\r\n    <backend />\r\n    <outbound>\r\n        <base />\r\n    </outbound>\r\n    <on-error>\r\n        <base />\r\n    </on-error>\r\n</policies>",
            "$fxv#4": "<!--\r\n    REGISTER OPTIONS POLICY\r\n    This policy handles the OPTIONS pre-flight requests for the OAuth client registration endpoint.\r\n    It returns the appropriate CORS headers to allow cross-origin requests.\r\n-->\r\n<policies>\r\n    <inbound>\r\n        <!-- Return a 200 OK response with appropriate CORS headers -->\r\n        <return-response>\r\n            <set-status code=\"200\" reason=\"OK\" />\r\n            <set-header name=\"Access-Control-Allow-Origin\" exists-action=\"override\">\r\n                <value>*</value>\r\n            </set-header>\r\n            <set-header name=\"Access-Control-Allow-Methods\" exists-action=\"override\">\r\n                <value>GET, OPTIONS</value>\r\n            </set-header>\r\n            <set-header name=\"Access-Control-Allow-Headers\" exists-action=\"override\">\r\n                <value>Content-Type, Authorization</value>\r\n            </set-header>\r\n            <set-header name=\"Access-Control-Max-Age\" exists-action=\"override\">\r\n                <value>86400</value>\r\n            </set-header>\r\n            <set-body />\r\n        </return-response>\r\n        <base />\r\n    </inbound>\r\n    <backend>\r\n        <base />\r\n    </backend>\r\n    <outbound>\r\n        <base />\r\n    </outbound>\r\n    <on-error>\r\n        <base />\r\n    </on-error>\r\n</policies>\r\n",
            "$fxv#5": "<!--\r\n    OAUTH METADATA OPTIONS POLICY\r\n    This policy handles OPTIONS requests to the OAuth metadata endpoint, implementing CORS support\r\n    for cross-origin requests to the OAuth authorization server.\r\n-->\r\n<policies>\r\n    <inbound>\r\n        <!-- Return CORS headers for OPTIONS requests -->\r\n        <return-response>\r\n            <set-status code=\"200\" reason=\"OK\" />\r\n            <set-header name=\"Access-Control-Allow-Origin\" exists-action=\"override\">\r\n                <value>*</value>\r\n            </set-header>\r\n            <set-header name=\"Access-Control-Allow-Methods\" exists-action=\"override\">\r\n                <value>GET, OPTIONS</value>\r\n            </set-header>\r\n            <set-header name=\"Access-Control-Allow-Headers\" exists-action=\"override\">\r\n                <value>Content-Type, Authorization</value>\r\n            </set-header>\r\n            <set-header name=\"Access-Control-Max-Age\" exists-action=\"override\">\r\n                <value>86400</value>\r\n            </set-header>\r\n            <set-body />\r\n        </return-response>\r\n        <base />\r\n    </inbound>\r\n    <backend>\r\n        <base />\r\n    </backend>\r\n    <outbound>\r\n        <base />\r\n    </outbound>\r\n    <on-error>\r\n        <base />\r\n    </on-error>\r\n</policies>",
            "$fxv#6": "<!--\r\n    OAUTH METADATA POLICY\r\n    This policy implements the OpenID Connect and OAuth 2.0 discovery endpoint (.well-known/oauth-authorization-server).\r\n-->\r\n<policies>\r\n    <inbound>\r\n        <!-- Return the OAuth metadata in JSON format -->\r\n        <return-response>\r\n            <set-status code=\"200\" reason=\"OK\" />\r\n            <set-header name=\"Content-Type\" exists-action=\"override\">\r\n                <value>application/json; charset=utf-8</value>\r\n            </set-header>\r\n            <set-header name=\"access-control-allow-origin\" exists-action=\"override\">\r\n                <value>*</value>\r\n            </set-header>                \r\n            <set-body>\r\n                {\r\n                    \"issuer\": \"{{APIMGatewayURL}}\",\r\n                    \"service_documentation\": \"https://microsoft.com/\",\r\n                    \"authorization_endpoint\": \"{{APIMGatewayURL}}/authorize\",\r\n                    \"token_endpoint\": \"{{APIMGatewayURL}}/token\",\r\n                    \"revocation_endpoint\": \"{{APIMGatewayURL}}/revoke\",\r\n                    \"registration_endpoint\": \"{{APIMGatewayURL}}/register\",\r\n                    \"response_types_supported\": [\r\n                        \"code\"\r\n                    ],\r\n                    \"code_challenge_methods_supported\": [\r\n                        \"S256\"\r\n                    ],\r\n                    \"token_endpoint_auth_methods_supported\": [\r\n                        \"none\"\r\n                    ],\r\n                    \"grant_types_supported\": [\r\n                        \"authorization_code\",\r\n                        \"refresh_token\"\r\n                    ],\r\n                    \"revocation_endpoint_auth_methods_supported\": [\r\n                        \"client_secret_post\"\r\n                    ]\r\n                }\r\n            </set-body>\r\n        </return-response>\r\n        <base />\r\n    </inbound>\r\n    <backend>\r\n        <base />\r\n    </backend>\r\n    <outbound>\r\n        <base />\r\n    </outbound>\r\n    <on-error>\r\n        <base />\r\n    </on-error>\r\n</policies>",
            "$fxv#7": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\r\n<!--\r\n    Consent Policy - Handles user consent for OAuth client applications\r\n    \r\n    Flow:\r\n    1. Check existing consent status (cookies)\r\n    2. Display consent form for new clients\r\n    3. Process user response (allow/deny)\r\n    4. Store decision and redirect appropriately\r\n-->\r\n<policies>\r\n    <inbound>        \r\n        <base />        \r\n        <!-- Helper function to extract parameters from form/query -->\r\n        <set-variable name=\"form_body\" value=\"@{\r\n            if (context.Request.Method == \"POST\") {\r\n                string contentType = context.Request.Headers.GetValueOrDefault(\"Content-Type\", \"\");\r\n                if (contentType.Contains(\"application/x-www-form-urlencoded\")) {\r\n                    return context.Request.Body.As<string>(preserveContent: true);\r\n                }\r\n            }\r\n            return \"\";\r\n        }\" />\r\n        \r\n        <!-- Extract request parameters using consolidated logic -->\r\n        <set-variable name=\"client_id\" value=\"@{\r\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\r\n            \r\n            // Check form data first (POST)\r\n            if (!string.IsNullOrEmpty(formBody)) {\r\n                string[] pairs = formBody.Split('&');\r\n                foreach (string pair in pairs) {\r\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\r\n                    if (keyValue.Length == 2 && keyValue[0] == \"client_id\") {\r\n                        return System.Net.WebUtility.UrlDecode(keyValue[1]);\r\n                    }\r\n                }\r\n            }\r\n            // Fallback to query string (GET)\r\n            return (string)context.Request.Url.Query.GetValueOrDefault(\"client_id\", \"\");\r\n        }\" />\r\n        \r\n        <set-variable name=\"redirect_uri\" value=\"@{\r\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\r\n            \r\n            // Check form data first (POST)\r\n            if (!string.IsNullOrEmpty(formBody)) {\r\n                string[] pairs = formBody.Split('&');\r\n                foreach (string pair in pairs) {\r\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\r\n                    if (keyValue.Length == 2 && keyValue[0] == \"redirect_uri\") {\r\n                        return keyValue[1]; // Keep encoded for normalization\r\n                    }\r\n                }\r\n            }\r\n            // Fallback to query string (GET)\r\n            return (string)context.Request.Url.Query.GetValueOrDefault(\"redirect_uri\", \"\");\r\n        }\" />\r\n        \r\n        <set-variable name=\"state\" value=\"@{\r\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\r\n            \r\n            // Check form data first (POST)\r\n            if (!string.IsNullOrEmpty(formBody)) {\r\n                string[] pairs = formBody.Split('&');\r\n                foreach (string pair in pairs) {\r\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\r\n                    if (keyValue.Length == 2 && keyValue[0] == \"state\") {\r\n                        return keyValue[1]; // Keep encoded\r\n                    }\r\n                }\r\n            }\r\n            // Fallback to query string (GET)\r\n            return (string)context.Request.Url.Query.GetValueOrDefault(\"state\", \"\") ?? \"\";\r\n        }\" />\r\n        \r\n        <set-variable name=\"code_challenge\" value=\"@{\r\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\r\n            \r\n            // Check form data first (POST)\r\n            if (!string.IsNullOrEmpty(formBody)) {\r\n                string[] pairs = formBody.Split('&');\r\n                foreach (string pair in pairs) {\r\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\r\n                    if (keyValue.Length == 2 && keyValue[0] == \"code_challenge\") {\r\n                        return keyValue[1]; // Keep encoded\r\n                    }\r\n                }\r\n            }\r\n            // Fallback to query string (GET)\r\n            return (string)context.Request.Url.Query.GetValueOrDefault(\"code_challenge\", \"\");\r\n        }\" />\r\n        \r\n        <set-variable name=\"code_challenge_method\" value=\"@{\r\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\r\n            \r\n            // Check form data first (POST)\r\n            if (!string.IsNullOrEmpty(formBody)) {\r\n                string[] pairs = formBody.Split('&');\r\n                foreach (string pair in pairs) {\r\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\r\n                    if (keyValue.Length == 2 && keyValue[0] == \"code_challenge_method\") {\r\n                        return keyValue[1]; // Keep encoded\r\n                    }\r\n                }\r\n            }\r\n            // Fallback to query string (GET)\r\n            return (string)context.Request.Url.Query.GetValueOrDefault(\"code_challenge_method\", \"\");\r\n        }\" />\r\n      \r\n         <set-variable name=\"access_denied_template\" value=\"@{\r\n            return @\"<!DOCTYPE html>\r\n<html lang='en'>\r\n<head>    <meta charset='UTF-8'>\r\n    <meta name='viewport' content='width=device-width, initial-scale=1.0'>\r\n    <title>Access Denied</title>\r\n    <style>\r\n__COMMON_STYLES__\r\n        .error-details {\r\n            background-color: #f8f9fa;\r\n            border: 1px solid #dee2e6;\r\n            border-radius: 8px;\r\n            padding: 20px;\r\n            margin: 20px 0;\r\n            font-family: 'Courier New', Consolas, monospace;\r\n            font-size: 14px;\r\n            line-height: 1.6;\r\n            white-space: pre-wrap;\r\n            overflow-x: auto;\r\n        }\r\n        \r\n        .error-title {\r\n            color: #dc3545;\r\n            font-weight: bold;\r\n            margin-bottom: 10px;\r\n        }\r\n        \r\n        .debug-section {\r\n            margin-top: 15px;\r\n            padding-top: 15px;\r\n            border-top: 1px solid #dee2e6;\r\n        }\r\n        \r\n        .debug-label {\r\n            font-weight: bold;\r\n            color: #495057;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class='consent-container'>\r\n        <h1 class='denial-heading'>Access Denied</h1>\r\n        <div class='error-details'>\r\n            <div class='error-title'>Error Details:</div>\r\n            __DENIAL_MESSAGE__\r\n        </div>\r\n        <p>The application will not be able to access your data.</p>\r\n        <p>You can close this window safely.</p>\r\n    </div>\r\n</body>\r\n</html>\";\r\n        }\" />\r\n        \r\n        <!-- Reusable function to generate 403 error response -->\r\n        <set-variable name=\"generate_403_response\" value=\"@{\r\n            string errorTemplate = context.Variables.GetValueOrDefault<string>(\"access_denied_template\");\r\n            string commonStyles = context.Variables.GetValueOrDefault<string>(\"common_styles\");\r\n            string message = \"Access denied.\";\r\n            \r\n            // Replace placeholders with actual content\r\n            errorTemplate = errorTemplate.Replace(\"__COMMON_STYLES__\", commonStyles);\r\n            errorTemplate = errorTemplate.Replace(\"__DENIAL_MESSAGE__\", message);\r\n            \r\n            return errorTemplate;\r\n        }\" />\r\n            <!-- Error page template -->\r\n        <set-variable name=\"client_not_found_template\" value=\"@{\r\n            return @\"<!DOCTYPE html>\r\n<html lang='en'>\r\n<head>    \r\n    <meta charset='UTF-8'>\r\n    <meta name='viewport' content='width=device-width, initial-scale=1.0'>\r\n    <title>Client Not Found</title>\r\n    <style>\r\n__COMMON_STYLES__\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class='consent-container'>        \r\n        <h1 class='denial-heading'>Client Not Found</h1>\r\n        <p>The client registration for the specified client was not found.</p>\r\n        <div class='client-info'>\r\n            <p><strong>Client ID:</strong> <code>__CLIENT_ID_DISPLAY__</code></p>\r\n            <p><strong>Redirect URI:</strong> <code>__REDIRECT_URI__</code></p>\r\n        </div>\r\n        <p>Please ensure that you are using a properly registered client application.</p>\r\n        <p>You can close this window safely.</p>\r\n    </div>\r\n</body>\r\n</html>\";\r\n        }\" />\r\n        <!-- Normalize redirect URI by handling potential double-encoding -->\r\n        <set-variable name=\"normalized_redirect_uri\" value=\"@{\r\n            string redirectUri = context.Variables.GetValueOrDefault<string>(\"redirect_uri\", \"\");\r\n            \r\n            if (string.IsNullOrEmpty(redirectUri)) {\r\n                return \"\";\r\n            }\r\n            \r\n            try {\r\n                string firstDecode = System.Net.WebUtility.UrlDecode(redirectUri);\r\n                \r\n                // Check if still encoded (contains % followed by hex digits)\r\n                if (firstDecode.Contains(\"%\") && System.Text.RegularExpressions.Regex.IsMatch(firstDecode, @\"%[0-9A-Fa-f]{2}\")) {\r\n                    // Double-encoded, decode again\r\n                    string secondDecode = System.Net.WebUtility.UrlDecode(firstDecode);\r\n                    return secondDecode;\r\n                } else {\r\n                    // Single encoding, first decode is sufficient\r\n                    return firstDecode;\r\n                }\r\n            } catch (Exception) {\r\n                // If decoding fails, return original value\r\n                return redirectUri;\r\n            }\r\n        }\" />\r\n        \r\n        <!-- Cache client information lookup -->\r\n        <cache-lookup-value key=\"@($\"ClientInfo-{context.Variables.GetValueOrDefault<string>(\"client_id\")}\")\" variable-name=\"clientInfoJson\" />\r\n        \r\n        <!-- Get OAuth scopes from configuration -->\r\n        <set-variable name=\"oauth_scopes\" value=\"{{OAuthScopes}}\" />\r\n        \r\n        <!-- Generate CSRF token for form protection (GET requests only) -->\r\n        <set-variable name=\"csrf_token\" value=\"@{\r\n            // Only generate tokens for GET requests (showing consent form)\r\n            // POST requests validate existing tokens, not generate new ones\r\n            if (context.Request.Method != \"GET\") {\r\n                return \"\";\r\n            }\r\n            \r\n            // Generate random CSRF token using Guid and timestamp\r\n            string guidPart = Guid.NewGuid().ToString(\"N\");\r\n            string timestampPart = DateTime.UtcNow.Ticks.ToString();\r\n            string combinedString = guidPart + timestampPart;\r\n            \r\n            // Create URL-safe token by encoding combined string\r\n            string token = System.Convert.ToBase64String(\r\n                System.Text.Encoding.UTF8.GetBytes(combinedString)\r\n            ).Replace(\"+\", \"-\").Replace(\"/\", \"_\").Replace(\"=\", \"\").Substring(0, 32);\r\n            \r\n            return token;\r\n        }\" />\r\n        \r\n        <!-- Cache CSRF token for validation (GET requests only) -->\r\n        <choose>\r\n            <when condition=\"@(context.Request.Method == \"GET\" && !string.IsNullOrEmpty(context.Variables.GetValueOrDefault<string>(\"csrf_token\")))\">\r\n                <cache-store-value key=\"@($\"CSRF-{context.Variables.GetValueOrDefault<string>(\"csrf_token\")}\")\" \r\n                                  value=\"@{\r\n                                      string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                                      string normalizedRedirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                                      string timestamp = DateTime.UtcNow.ToString(\"yyyy-MM-ddTHH:mm:ssZ\");\r\n                                      string tokenData = $\"{clientId}:{normalizedRedirectUri}:{timestamp}\";\r\n                                      \r\n                                      // Add debugging metadata\r\n                                      string debugInfo = $\"CACHED_AT:{DateTime.UtcNow:yyyy-MM-ddTHH:mm:ss.fffZ}\";\r\n                                      return $\"{tokenData}|{debugInfo}\";\r\n                                  }\" \r\n                                  duration=\"900\" />\r\n                <!-- Track token caching for debugging -->\r\n                <set-variable name=\"csrf_token_cached\" value=\"true\" />\r\n            </when>\r\n            <otherwise>\r\n                <set-variable name=\"csrf_token_cached\" value=\"false\" />\r\n            </otherwise>\r\n        </choose>\r\n          <!-- Validate client registration -->\r\n        <set-variable name=\"is_client_registered\" value=\"@{\r\n            try {\r\n                string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                \r\n                if (string.IsNullOrEmpty(clientId)) {\r\n                    return false;\r\n                }\r\n                \r\n                // Get client info from cache lookup\r\n                string clientInfoJson = context.Variables.GetValueOrDefault<string>(\"clientInfoJson\");\r\n                  if (string.IsNullOrEmpty(clientInfoJson)) {\r\n                    return false;\r\n                }\r\n                \r\n                // Parse client configuration\r\n                JObject clientInfo = JObject.Parse(clientInfoJson);\r\n                JArray redirectUris = clientInfo[\"redirect_uris\"]?.ToObject<JArray>();\r\n                \r\n                // Validate redirect URI is registered\r\n                if (redirectUris != null) {\r\n                    foreach (var uri in redirectUris) {\r\n                        // Normalize registered URI for comparison\r\n                        string registeredUri = System.Net.WebUtility.UrlDecode(uri.ToString());\r\n                        if (registeredUri == redirectUri) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                return false;\r\n            }\r\n            catch (Exception ex) {\r\n                return false;\r\n            }\r\n        }\" />\r\n        \r\n        <!-- Extract client name from cache -->\r\n        <set-variable name=\"client_name\" value=\"@{\r\n            try {\r\n                string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                \r\n                if (string.IsNullOrEmpty(clientId)) {\r\n                    return \"Unknown Application\";\r\n                }\r\n                \r\n                // Get client info from cache lookup\r\n                string clientInfoJson = context.Variables.GetValueOrDefault<string>(\"clientInfoJson\");\r\n                \r\n                if (string.IsNullOrEmpty(clientInfoJson)) {\r\n                    return clientId;\r\n                }\r\n                \r\n                // Parse client configuration\r\n                JObject clientInfo = JObject.Parse(clientInfoJson);\r\n                string clientName = clientInfo[\"client_name\"]?.ToString();\r\n                \r\n                return string.IsNullOrEmpty(clientName) ? clientId : clientName;\r\n            }\r\n            catch (Exception ex) {\r\n                return context.Variables.GetValueOrDefault<string>(\"client_id\", \"Unknown Application\");\r\n            }\r\n        }\" />\r\n        \r\n        <!-- Extract client URI from cache -->\r\n        <set-variable name=\"client_uri\" value=\"@{\r\n            try {\r\n                // Get client info from cache lookup\r\n                string clientInfoJson = context.Variables.GetValueOrDefault<string>(\"clientInfoJson\");\r\n                \r\n                if (string.IsNullOrEmpty(clientInfoJson)) {\r\n                    return \"N/A\";\r\n                }\r\n                \r\n                // Parse client configuration\r\n                JObject clientInfo = JObject.Parse(clientInfoJson);\r\n                string clientUri = clientInfo[\"client_uri\"]?.ToString();\r\n                \r\n                return string.IsNullOrEmpty(clientUri) ? \"N/A\" : clientUri;\r\n            }\r\n            catch (Exception ex) {\r\n                return \"N/A\";\r\n            }\r\n        }\" />\r\n        \r\n        <!-- Define common styles for consent and error pages -->\r\n        <set-variable name=\"common_styles\" value=\"@{\r\n            return @\"        body {\r\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\r\n            max-width: 100%;\r\n            margin: 0;            padding: 0;\r\n            line-height: 1.6;\r\n            min-height: 100vh;\r\n            background: linear-gradient(135deg, #1f1f1f, #333344, #3f4066); /* Modern dark gradient */\r\n            color: #333333;\r\n            display: flex;\r\n            justify-content: center;\r\n            align-items: center;\r\n        }.container, .consent-container {\r\n            background-color: #ffffff;\r\n            border-radius: 4px; /* Adding some subtle rounding */\r\n            padding: 30px;\r\n            max-width: 600px;            width: 90%;\r\n            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);\r\n            border: none;\r\n        }\r\n        \r\n        h1 {\r\n            margin-bottom: 20px;\r\n            border-bottom: 1px solid #EDEBE9;\r\n            padding-bottom: 10px;\r\n            font-weight: 500;\r\n        }\r\n        .consent-heading {\r\n            color: #0078D4; /* Microsoft Blue */\r\n        }\r\n        .denial-heading {\r\n            color: #D83B01; /* Microsoft Attention color */\r\n        }\r\n        \r\n        p {\r\n            margin: 15px 0;\r\n            line-height: 1.7;\r\n            color: #323130; /* Microsoft text color */\r\n        }          .client-info {\r\n            background-color: #F5F5F5; /* Light gray background for info boxes */\r\n            padding: 15px;\r\n            border-radius: 4px; /* Adding some subtle rounding */\r\n            margin: 15px 0;\r\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);\r\n            border: 1px solid #EDEBE9;\r\n        }\r\n          .client-info p {\r\n            display: flex;\r\n            align-items: flex-start;\r\n            margin: 8px 0;\r\n        }\r\n        \r\n        .client-info strong {\r\n            min-width: 160px;\r\n            flex-shrink: 0;\r\n            text-align: left;\r\n            padding-right: 15px;\r\n            color: #0078D4; /* Microsoft Blue */\r\n        }\r\n          .client-info code {\r\n            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;\r\n            background-color: rgba(240, 240, 250, 0.5);\r\n            padding: 2px 6px;\r\n            border-radius: 4px; /* Adding some subtle rounding */\r\n            color: #0078D4; /* Microsoft Blue */\r\n            word-break: break-all;\r\n        }\r\n          .btn {\r\n            display: inline-block;\r\n            padding: 8px 16px;\r\n            margin: 10px 0;\r\n            border-radius: 4px; /* Adding some subtle rounding */\r\n            text-decoration: none;\r\n            font-weight: 600;\r\n            cursor: pointer;\r\n            transition: all 0.2s ease;\r\n        }\r\n        \r\n        .btn-primary {\r\n            background-color: #0078D4; /* Microsoft Blue */\r\n            color: white;\r\n            border: none;\r\n        }\r\n        .btn-primary:hover {\r\n            background-color: #106EBE; /* Microsoft Blue hover */\r\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);\r\n        }\r\n        \r\n        .btn-secondary {\r\n            background-color: #D83B01; /* Microsoft Red */\r\n            color: white; /* White text */\r\n            border: none;\r\n        }\r\n        .btn-secondary:hover {\r\n            background-color: #A80000; /* Darker red on hover */\r\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);\r\n        }\r\n          .buttons {\r\n            margin-top: 20px;\r\n            display: flex;\r\n            gap: 10px;\r\n            justify-content: flex-start;\r\n        }\r\n        \r\n        a {\r\n            color: #0078D4; /* Microsoft Blue */\r\n            text-decoration: none;\r\n            font-weight: 600;\r\n        }\r\n        a:hover {\r\n            text-decoration: underline;\r\n        }\r\n        strong {\r\n            color: #0078D4; /* Microsoft Blue */\r\n            font-weight: 600;\r\n        }          .error-message {\r\n            background-color: #FDE7E9; /* Light red background */\r\n            padding: 15px;\r\n            margin: 15px 0;\r\n            border-radius: 4px; /* Adding some subtle rounding */\r\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);\r\n            border-left: 3px solid #D83B01; /* Microsoft Attention color */\r\n        }\r\n        \r\n        .error-message p {\r\n            margin: 8px 0;\r\n        }\r\n        \r\n        .error-message p:first-child {\r\n            font-weight: 500;\r\n            color: #D83B01; /* Microsoft Attention color */\r\n        }\";\r\n        }\" />\r\n        \r\n        <!-- Consent page HTML template -->\r\n        <set-variable name=\"consent_page_template\" value=\"@{\r\n            return @\"<!DOCTYPE html>\r\n<html lang='en'>\r\n<head>    <meta charset='UTF-8'>\r\n    <meta name='viewport' content='width=device-width, initial-scale=1.0'>\r\n    <title>Application Consent</title>\r\n    <style>\r\n__COMMON_STYLES__    /* Additional styles for scopes list */\r\n    .scopes-list {\r\n        margin: 0;\r\n        padding-left: 0;\r\n    }\r\n    .scopes-list li {\r\n        list-style-type: none;\r\n        padding: 4px 0;\r\n        display: flex;\r\n    }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class='consent-container'>\r\n        <h1 class='consent-heading'>Application Access Request</h1>\r\n\r\n        <p>The following application is requesting access to <strong>{{MCPServerName}}</strong>, which might include access to everything <strong>{{MCPServerName}}</strong> has been and will be granted access to.</p>\r\n        \r\n        <div class='client-info'>\r\n            <p><strong>Application Name:</strong> <code>__CLIENT_NAME__</code></p>\r\n            <p><strong>Application Website:</strong> <code>__CLIENT_URI__</code></p>\r\n            <p><strong>Application ID:</strong> <code>__CLIENT_ID_DISPLAY__</code></p>\r\n            <p><strong>Redirect URI:</strong> <code>__REDIRECT_URI__</code></p>\r\n        </div>        \r\n        <p>The application will have access to the following scopes, used by <strong>{{MCPServerName}}</strong>:</p>\r\n        <div class='client-info'>\r\n            <ul class='scopes-list'>\r\n                <li>__OAUTH_SCOPES__</li>\r\n            </ul>\r\n        </div>        <div class='buttons'>\r\n            <form method='post' action='__CONSENT_ACTION_URL__' style='display: inline-block;'>\r\n                <input type='hidden' name='client_id' value='__CLIENT_ID_FORM__'>\r\n                <input type='hidden' name='redirect_uri' value='__REDIRECT_URI__'>\r\n                <input type='hidden' name='state' value='__STATE__'>\r\n                <input type='hidden' name='code_challenge' value='__CODE_CHALLENGE__'>\r\n                <input type='hidden' name='code_challenge_method' value='__CODE_CHALLENGE_METHOD__'>\r\n                <input type='hidden' name='csrf_token' value='__CSRF_TOKEN__'>\r\n                <input type='hidden' name='consent_action' value='allow'>\r\n                <button type='submit' class='btn btn-primary'>Allow</button>\r\n            </form>\r\n            \r\n            <form method='post' action='__CONSENT_ACTION_URL__' style='display: inline-block;'>                <input type='hidden' name='client_id' value='__CLIENT_ID_FORM__'>\r\n                <input type='hidden' name='redirect_uri' value='__REDIRECT_URI__'>\r\n                <input type='hidden' name='state' value='__STATE__'>\r\n                <input type='hidden' name='code_challenge' value='__CODE_CHALLENGE__'>\r\n                <input type='hidden' name='code_challenge_method' value='__CODE_CHALLENGE_METHOD__'>\r\n                <input type='hidden' name='csrf_token' value='__CSRF_TOKEN__'>\r\n                <input type='hidden' name='consent_action' value='deny'>\r\n                <button type='submit' class='btn btn-secondary'>Deny</button>\r\n            </form>\r\n        </div>\r\n    </div>\r\n</body>\r\n</html>\";\r\n        }\" />\r\n\r\n        <!-- Check for existing client denial cookie -->\r\n        <set-variable name=\"has_denial_cookie\" value=\"@{\r\n            try {\r\n                if (string.IsNullOrEmpty(context.Variables.GetValueOrDefault<string>(\"client_id\", \"\")) || \r\n                    string.IsNullOrEmpty(context.Variables.GetValueOrDefault<string>(\"redirect_uri\", \"\"))) {\r\n                    return false;\r\n                }\r\n                  \r\n                string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                // Use normalized redirect URI for consistency\r\n                string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                \r\n                // Cookie name for client denials\r\n                string DENIAL_COOKIE_NAME = \"MCP_DENIED_CLIENTS\";\r\n                \r\n                // Check for denial cookie in request\r\n                var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\r\n                if (string.IsNullOrEmpty(cookieHeader)) {\r\n                    return false;\r\n                }\r\n                \r\n                // Parse cookie header for denial cookie\r\n                string[] cookies = cookieHeader.Split(';');\r\n                foreach (string cookie in cookies) {\r\n                    string trimmedCookie = cookie.Trim();\r\n                    if (trimmedCookie.StartsWith(DENIAL_COOKIE_NAME + \"=\")) {\r\n                        // Extract cookie value\r\n                        string cookieValue = trimmedCookie.Substring(DENIAL_COOKIE_NAME.Length + 1);\r\n                        try {\r\n                            // Parse base64-encoded JSON array of denied clients\r\n                            string decodedValue = System.Text.Encoding.UTF8.GetString(\r\n                                System.Convert.FromBase64String(cookieValue.Split('.')[0]));\r\n                            JArray deniedClients = JArray.Parse(decodedValue);                            \r\n                            \r\n                            // Create client/redirect identifier\r\n                            // Use normalized redirect URI for consistency\r\n                            string clientKey = $\"{clientId}:{redirectUri}\";\r\n                            \r\n                            foreach (var item in deniedClients) {\r\n                                string itemString = item.ToString();\r\n                                \r\n                                // Direct comparison using normalized URI\r\n                                if (itemString == clientKey) {\r\n                                    return true;\r\n                                }\r\n                                \r\n                                // Handle URL-encoded redirect URI in stored cookie\r\n                                try {\r\n                                    string storedValue = itemString;\r\n                                    if (storedValue.Contains(':')) {\r\n                                        string[] parts = storedValue.Split(new char[] {':'}, 2);\r\n                                        if (parts.Length == 2) {\r\n                                            string storedClientId = parts[0];\r\n                                            // Decode stored redirect URI for comparison\r\n                                            string storedRedirectUri = System.Net.WebUtility.UrlDecode(parts[1]);\r\n                                            \r\n                                            // Compare both decoded forms\r\n                                            if (storedClientId == clientId && storedRedirectUri == redirectUri) {\r\n                                                return true;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                } catch (Exception ex) {\r\n                                    // Ignore comparison errors and continue\r\n                                }\r\n                            }\r\n                        } catch (Exception ex) {\r\n                            // Ignore cookie parsing errors and continue\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                return false;\r\n            } catch (Exception ex) {\r\n                return false;\r\n            }\r\n        }\" />\r\n        \r\n        <!-- Check for existing client approval cookie -->\r\n        <set-variable name=\"has_approval_cookie\" value=\"@{\r\n            try {\r\n                if (string.IsNullOrEmpty(context.Variables.GetValueOrDefault<string>(\"client_id\", \"\")) || \r\n                    string.IsNullOrEmpty(context.Variables.GetValueOrDefault<string>(\"redirect_uri\", \"\"))) {\r\n                    return false;\r\n                }\r\n                  \r\n                string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                // Use normalized redirect URI for consistency\r\n                string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                \r\n                // Cookie name for client approvals\r\n                string APPROVAL_COOKIE_NAME = \"MCP_APPROVED_CLIENTS\";\r\n                \r\n                // Check for approval cookie in request\r\n                var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\r\n                if (string.IsNullOrEmpty(cookieHeader)) {\r\n                    return false;\r\n                }\r\n                \r\n                // Parse cookie header for approval cookie\r\n                string[] cookies = cookieHeader.Split(';');\r\n                foreach (string cookie in cookies) {\r\n                    string trimmedCookie = cookie.Trim();\r\n                    if (trimmedCookie.StartsWith(APPROVAL_COOKIE_NAME + \"=\")) {\r\n                        // Extract cookie value\r\n                        string cookieValue = trimmedCookie.Substring(APPROVAL_COOKIE_NAME.Length + 1);\r\n                        try {                            \r\n                            // Parse base64-encoded JSON array of approved clients\r\n                            string decodedValue = System.Text.Encoding.UTF8.GetString(\r\n                                System.Convert.FromBase64String(cookieValue.Split('.')[0]));\r\n                            JArray approvedClients = JArray.Parse(decodedValue);\r\n                            \r\n                            // Create client/redirect identifier\r\n                            // Use normalized redirect URI for consistency\r\n                            string clientKey = $\"{clientId}:{redirectUri}\";\r\n                            \r\n                            foreach (var item in approvedClients) {\r\n                                string itemString = item.ToString();\r\n                                \r\n                                // Direct comparison using normalized URI\r\n                                if (itemString == clientKey) {\r\n                                    return true;\r\n                                }\r\n                                \r\n                                // Handle URL-encoded redirect URI in stored cookie\r\n                                try {\r\n                                    string storedValue = itemString;\r\n                                    if (storedValue.Contains(':')) {\r\n                                        string[] parts = storedValue.Split(new char[] {':'}, 2);\r\n                                        if (parts.Length == 2) {\r\n                                            string storedClientId = parts[0];\r\n                                            // Decode stored redirect URI for comparison\r\n                                            string storedRedirectUri = System.Net.WebUtility.UrlDecode(parts[1]);\r\n                                            \r\n                                            // Compare both decoded forms\r\n                                            if (storedClientId == clientId && storedRedirectUri == redirectUri) {\r\n                                                return true;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                } catch (Exception ex) {\r\n                                    // Ignore comparison errors and continue\r\n                                }\r\n                            }\r\n                        } catch (Exception ex) {\r\n                            // Ignore cookie parsing errors and continue\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                return false;\r\n            } catch (Exception ex) {\r\n                return false;\r\n            }\r\n        }\" />\r\n        \r\n        <set-variable name=\"consent_action\" value=\"@{\r\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\r\n            \r\n            if (!string.IsNullOrEmpty(formBody)) {\r\n                string[] pairs = formBody.Split('&');\r\n                foreach (string pair in pairs) {\r\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\r\n                    if (keyValue.Length == 2 && keyValue[0] == \"consent_action\") {\r\n                        return System.Net.WebUtility.UrlDecode(keyValue[1]);\r\n                    }\r\n                }\r\n                // Fallback to JSON parsing if form parsing failed\r\n                return context.Request.Body.As<JObject>(preserveContent: true)[\"consent_action\"]?.ToString() ?? \"\";\r\n            }\r\n            return \"\";\r\n        }\" />\r\n        \r\n        <!-- Extract CSRF token from form data -->\r\n        <set-variable name=\"csrf_token_from_form\" value=\"@{\r\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\r\n            \r\n            if (!string.IsNullOrEmpty(formBody)) {\r\n                string[] pairs = formBody.Split('&');\r\n                foreach (string pair in pairs) {\r\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\r\n                    if (keyValue.Length == 2 && keyValue[0] == \"csrf_token\") {\r\n                        return System.Net.WebUtility.UrlDecode(keyValue[1]);\r\n                    }\r\n                }\r\n            }\r\n            return \"\";\r\n        }\" />\r\n        \r\n        <!-- Validate CSRF token for POST requests -->\r\n        <set-variable name=\"csrf_valid\" value=\"@{\r\n            if (context.Request.Method != \"POST\") {\r\n                return true; // Only validate POST requests\r\n            }\r\n            \r\n            string submittedToken = context.Variables.GetValueOrDefault<string>(\"csrf_token_from_form\", \"\");\r\n            if (string.IsNullOrEmpty(submittedToken)) {\r\n                return false;\r\n            }\r\n            \r\n            // Token cache lookup validation happens next\r\n            string cacheKey = $\"CSRF-{submittedToken}\";\r\n            \r\n            return true; // Initial validation passes, detailed validation follows\r\n        }\" />\r\n        \r\n        <!-- Validate Origin/Referer headers for CSRF protection -->\r\n        <set-variable name=\"origin_referer_valid\" value=\"@{\r\n            if (context.Request.Method != \"POST\") {\r\n                return true; // Only validate state-changing operations\r\n            }\r\n            \r\n            // Get the target origin (expected origin)\r\n            string targetOrigin = \"{{APIMGatewayURL}}\";\r\n            \r\n            // Remove protocol and trailing slash for comparison\r\n            if (targetOrigin.StartsWith(\"https://\")) {\r\n                targetOrigin = targetOrigin.Substring(8);\r\n            } else if (targetOrigin.StartsWith(\"http://\")) {\r\n                targetOrigin = targetOrigin.Substring(7);\r\n            }\r\n            if (targetOrigin.EndsWith(\"/\")) {\r\n                targetOrigin = targetOrigin.TrimEnd('/');\r\n            }\r\n            \r\n            // First check Origin header (preferred)\r\n            string originHeader = context.Request.Headers.GetValueOrDefault(\"Origin\", \"\");\r\n            if (!string.IsNullOrEmpty(originHeader)) {\r\n                try {\r\n                    Uri originUri = new Uri(originHeader);\r\n                    string sourceOrigin = originUri.Host;\r\n                    if (originUri.Port != 80 && originUri.Port != 443) {\r\n                        sourceOrigin += \":\" + originUri.Port;\r\n                    }\r\n                    \r\n                    if (sourceOrigin.Equals(targetOrigin, StringComparison.OrdinalIgnoreCase)) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                } catch (Exception ex) {\r\n                    return false;\r\n                }\r\n            }\r\n            \r\n            // Fallback to Referer header if Origin is not present\r\n            string refererHeader = context.Request.Headers.GetValueOrDefault(\"Referer\", \"\");\r\n            if (!string.IsNullOrEmpty(refererHeader)) {\r\n                try {\r\n                    Uri refererUri = new Uri(refererHeader);\r\n                    string sourceOrigin = refererUri.Host;\r\n                    if (refererUri.Port != 80 && refererUri.Port != 443) {\r\n                        sourceOrigin += \":\" + refererUri.Port;\r\n                    }\r\n                    \r\n                    if (sourceOrigin.Equals(targetOrigin, StringComparison.OrdinalIgnoreCase)) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                } catch (Exception ex) {\r\n                    return false;\r\n                }\r\n            }\r\n            \r\n            // Neither Origin nor Referer header present - this is suspicious for POST requests\r\n            // OWASP recommends blocking such requests for better security\r\n            return false; // Block requests without proper origin validation\r\n        }\" />\r\n        \r\n        <!-- Validate Fetch Metadata headers for CSRF protection -->\r\n        <set-variable name=\"fetch_metadata_valid\" value=\"@{\r\n            // Check Sec-Fetch-Site header for cross-site request detection\r\n            string secFetchSite = context.Request.Headers.GetValueOrDefault(\"Sec-Fetch-Site\", \"\");\r\n            \r\n            // Allow same-origin, same-site, and direct navigation\r\n            if (string.IsNullOrEmpty(secFetchSite) || \r\n                secFetchSite == \"same-origin\" || \r\n                secFetchSite == \"same-site\" || \r\n                secFetchSite == \"none\") {\r\n                return true;\r\n            }\r\n            \r\n            // Block cross-site POST requests\r\n            if (context.Request.Method == \"POST\" && secFetchSite == \"cross-site\") {\r\n                return false;\r\n            }\r\n            \r\n            // Allow other values for compatibility\r\n            return true;\r\n        }\" />\r\n        \r\n        <!-- Lookup CSRF token from cache -->\r\n        <cache-lookup-value key=\"@($\"CSRF-{context.Variables.GetValueOrDefault<string>(\"csrf_token_from_form\")}\")\" variable-name=\"csrf_token_data\" />\r\n        \r\n        <!-- Validate CSRF token details -->\r\n        <set-variable name=\"csrf_validation_result\" value=\"@{\r\n            if (context.Request.Method != \"POST\") {\r\n                return \"valid\"; // No validation needed for GET requests\r\n            }\r\n            \r\n            string submittedToken = context.Variables.GetValueOrDefault<string>(\"csrf_token_from_form\", \"\");\r\n            if (string.IsNullOrEmpty(submittedToken)) {\r\n                return \"missing_token\";\r\n            }\r\n            \r\n            string tokenData = context.Variables.GetValueOrDefault<string>(\"csrf_token_data\");\r\n            if (string.IsNullOrEmpty(tokenData)) {\r\n                return \"invalid_token\";\r\n            }\r\n            \r\n            try {\r\n                // Extract token data (before debug info separator)\r\n                string actualTokenData = tokenData;\r\n                if (tokenData.Contains(\"|\")) {\r\n                    actualTokenData = tokenData.Split('|')[0];\r\n                }\r\n                \r\n                // Parse token data: client_id:redirect_uri:timestamp\r\n                // Since both redirect_uri and timestamp can contain colons, we need to be very careful\r\n                // The timestamp format is: YYYY-MM-DDTHH:mm:ssZ\r\n                // So we look for the last occurrence of a timestamp pattern\r\n                \r\n                // Find the last occurrence of a timestamp pattern (YYYY-MM-DDTHH:mm:ssZ)\r\n                var timestampPattern = @\":\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$\";\r\n                var timestampMatch = System.Text.RegularExpressions.Regex.Match(actualTokenData, timestampPattern);\r\n                \r\n                if (!timestampMatch.Success) {\r\n                    return \"malformed_token\";\r\n                }\r\n                \r\n                // Extract the timestamp (without the leading colon)\r\n                string timestampStr = timestampMatch.Value.Substring(1);\r\n                \r\n                // Extract everything before the timestamp match as the client_id:redirect_uri part\r\n                string clientAndRedirect = actualTokenData.Substring(0, timestampMatch.Index);\r\n                \r\n                // Split client_id:redirect_uri on the first colon only\r\n                int firstColonIndex = clientAndRedirect.IndexOf(':');\r\n                if (firstColonIndex == -1) {\r\n                    return \"malformed_token\";\r\n                }\r\n                \r\n                string tokenClientId = clientAndRedirect.Substring(0, firstColonIndex);\r\n                string tokenRedirectUri = clientAndRedirect.Substring(firstColonIndex + 1);\r\n                \r\n                // Validate client_id and redirect_uri match using constant-time comparison\r\n                string currentClientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                string currentRedirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                \r\n                // Constant-time string comparison for client_id to prevent timing attacks\r\n                bool clientIdMatches = true;\r\n                if (tokenClientId == null || currentClientId == null) {\r\n                    clientIdMatches = (tokenClientId == currentClientId);\r\n                } else if (tokenClientId.Length != currentClientId.Length) {\r\n                    clientIdMatches = false;\r\n                } else {\r\n                    int result = 0;\r\n                    for (int i = 0; i < tokenClientId.Length; i++) {\r\n                        result |= tokenClientId[i] ^ currentClientId[i];\r\n                    }\r\n                    clientIdMatches = (result == 0);\r\n                }\r\n                \r\n                if (!clientIdMatches) {\r\n                    return \"client_mismatch\";\r\n                }\r\n                \r\n                // Constant-time string comparison for redirect_uri to prevent timing attacks\r\n                bool redirectUriMatches = true;\r\n                if (tokenRedirectUri == null || currentRedirectUri == null) {\r\n                    redirectUriMatches = (tokenRedirectUri == currentRedirectUri);\r\n                } else if (tokenRedirectUri.Length != currentRedirectUri.Length) {\r\n                    redirectUriMatches = false;\r\n                } else {\r\n                    int result = 0;\r\n                    for (int i = 0; i < tokenRedirectUri.Length; i++) {\r\n                        result |= tokenRedirectUri[i] ^ currentRedirectUri[i];\r\n                    }\r\n                    redirectUriMatches = (result == 0);\r\n                }\r\n                \r\n                if (!redirectUriMatches) {\r\n                    return \"redirect_mismatch\";\r\n                }\r\n                \r\n                // Validate timestamp (token should not be older than 15 minutes)\r\n                DateTime tokenTime;\r\n                try {\r\n                    tokenTime = DateTime.Parse(timestampStr);\r\n                } catch (Exception) {\r\n                    return \"invalid_timestamp\";\r\n                }\r\n                \r\n                TimeSpan age = DateTime.UtcNow - tokenTime;\r\n                if (age.TotalMinutes > 15) {\r\n                    return \"expired_token\";\r\n                }\r\n                \r\n                return \"valid\";\r\n                \r\n            } catch (Exception ex) {\r\n                return \"validation_error\";\r\n            }\r\n        }\" />\r\n        \r\n        <!-- If this is a form submission, process the consent choice -->\r\n        <choose>\r\n            <when condition=\"@(context.Request.Method == \"POST\")\">\r\n                <!-- Validate Origin/Referer headers -->\r\n                <choose>\r\n                    <when condition=\"@(!context.Variables.GetValueOrDefault<bool>(\"origin_referer_valid\"))\">\r\n                        <!-- Origin/Referer validation failed -->\r\n                        <return-response>\r\n                            <set-status code=\"403\" reason=\"Forbidden\" />\r\n                            <set-header name=\"Content-Type\" exists-action=\"override\">\r\n                                <value>text/html</value>\r\n                            </set-header>\r\n                            <set-header name=\"Cache-Control\" exists-action=\"override\">\r\n                                <value>no-store, no-cache</value>\r\n                            </set-header>\r\n                            <set-header name=\"Pragma\" exists-action=\"override\">\r\n                                <value>no-cache</value>\r\n                            </set-header>\r\n                            <set-body>@(context.Variables.GetValueOrDefault<string>(\"generate_403_response\"))</set-body>\r\n                        </return-response>\r\n                    </when>\r\n                    <otherwise>\r\n                        <!-- Origin/Referer validation passed -->\r\n                        <!-- Validate Fetch Metadata headers -->\r\n                        <choose>\r\n                            <when condition=\"@(!context.Variables.GetValueOrDefault<bool>(\"fetch_metadata_valid\"))\">\r\n                                <!-- Fetch metadata validation failed -->\r\n                                <return-response>\r\n                                    <set-status code=\"403\" reason=\"Forbidden\" />\r\n                                    <set-header name=\"Content-Type\" exists-action=\"override\">\r\n                                        <value>text/html</value>\r\n                                    </set-header>\r\n                                    <set-header name=\"Cache-Control\" exists-action=\"override\">\r\n                                        <value>no-store, no-cache</value>\r\n                                    </set-header>\r\n                                    <set-header name=\"Pragma\" exists-action=\"override\">\r\n                                        <value>no-cache</value>\r\n                                    </set-header>\r\n                                    <set-body>@(context.Variables.GetValueOrDefault<string>(\"generate_403_response\"))</set-body>\r\n                                </return-response>\r\n                            </when>\r\n                            <otherwise>\r\n                                <!-- Fetch metadata validation passed -->\r\n                                <!-- Validate CSRF token -->\r\n                                <choose>\r\n                                    <when condition=\"@(context.Variables.GetValueOrDefault<string>(\"csrf_validation_result\") != \"valid\")\">\r\n                                        <!-- CSRF validation failed -->\r\n                                        <return-response>\r\n                                            <set-status code=\"403\" reason=\"Forbidden\" />\r\n                                            <set-header name=\"Content-Type\" exists-action=\"override\">\r\n                                                <value>text/html</value>\r\n                                            </set-header>\r\n                                            <set-header name=\"Cache-Control\" exists-action=\"override\">\r\n                                                <value>no-store, no-cache</value>\r\n                                            </set-header>\r\n                                            <set-header name=\"Pragma\" exists-action=\"override\">\r\n                                                <value>no-cache</value>\r\n                                            </set-header>\r\n                                            <set-body>@(context.Variables.GetValueOrDefault<string>(\"generate_403_response\"))</set-body>\r\n                                        </return-response>\r\n                                    </when>\r\n                                    <otherwise>\r\n                                        <!-- CSRF validation passed -->\r\n                                        <!-- Delete CSRF token from cache to prevent reuse -->\r\n                                        <cache-remove-value key=\"@($\"CSRF-{context.Variables.GetValueOrDefault<string>(\"csrf_token_from_form\")}\")\" />\r\n                                        \r\n                                        <choose>\r\n                                            <when condition=\"@(context.Variables.GetValueOrDefault<string>(\"consent_action\") == \"allow\")\">\r\n                        <!-- Process consent approval -->\r\n                        <set-variable name=\"response_status_code\" value=\"302\" />\r\n                        <set-variable name=\"response_redirect_location\" value=\"@{\r\n                            string baseUrl = \"{{APIMGatewayURL}}\";\r\n                            \r\n                            // Use already extracted parameters instead of re-parsing form data\r\n                            string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                            string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                            string state = context.Variables.GetValueOrDefault<string>(\"state\", \"\");\r\n                            \r\n                            // URL encode parameters to prevent injection attacks\r\n                            string encodedClientId = System.Net.WebUtility.UrlEncode(clientId);\r\n                            string encodedRedirectUri = System.Net.WebUtility.UrlEncode(redirectUri);\r\n                            // State is already properly encoded from form submission, don't double-encode\r\n                            string encodedState = state;\r\n                            \r\n                            // Add PKCE parameters if they exist\r\n                            string codeChallenge = context.Variables.GetValueOrDefault<string>(\"code_challenge\", \"\");\r\n                            string codeChallengeMethod = context.Variables.GetValueOrDefault<string>(\"code_challenge_method\", \"\");\r\n                            \r\n                            string url = $\"{baseUrl}/authorize?client_id={encodedClientId}&redirect_uri={encodedRedirectUri}&state={encodedState}\";\r\n                            \r\n                            if (!string.IsNullOrEmpty(codeChallenge)) {\r\n                                url += $\"&code_challenge={System.Net.WebUtility.UrlEncode(codeChallenge)}\";\r\n                            }\r\n                            \r\n                            if (!string.IsNullOrEmpty(codeChallengeMethod)) {\r\n                                url += $\"&code_challenge_method={System.Net.WebUtility.UrlEncode(codeChallengeMethod)}\";\r\n                            }\r\n                            \r\n                            return url;\r\n                        }\" />\r\n                          <!-- Calculate approval cookie value -->\r\n                        <set-variable name=\"approval_cookie\" value=\"@{\r\n                            string cookieName = \"MCP_APPROVED_CLIENTS\";\r\n                            \r\n                            // Use already extracted parameters instead of re-parsing form data\r\n                            string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                            string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                            \r\n                            // Create a unique identifier for this client/redirect combination\r\n                            string clientKey = $\"{clientId}:{redirectUri}\";\r\n                            \r\n                            // Check for existing cookie\r\n                            var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\r\n                            JArray approvedClients = new JArray();\r\n                            \r\n                            if (!string.IsNullOrEmpty(cookieHeader)) {\r\n                                // Parse cookies to find our approval cookie\r\n                                string[] cookies = cookieHeader.Split(';');\r\n                                foreach (string cookie in cookies) {\r\n                                    string trimmedCookie = cookie.Trim();\r\n                                    if (trimmedCookie.StartsWith(cookieName + \"=\")) {\r\n                                        try {\r\n                                            // Extract and parse the cookie value\r\n                                            string cookieValue = trimmedCookie.Substring(cookieName.Length + 1);\r\n                                            // Get the payload part (before the first dot if cookie is signed)\r\n                                            string payload = cookieValue.Contains('.') ? \r\n                                                cookieValue.Split('.')[0] : cookieValue;\r\n                                            string decodedValue = System.Text.Encoding.UTF8.GetString(\r\n                                                System.Convert.FromBase64String(payload));\r\n                                            approvedClients = JArray.Parse(decodedValue);\r\n                                        } catch (Exception) {\r\n                                            // If parsing fails, we'll just create a new cookie\r\n                                            approvedClients = new JArray();\r\n                                        }\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                            \r\n                            // Add the current client if not already in the list\r\n                            bool clientExists = false;\r\n                            foreach (var item in approvedClients) {\r\n                                if (item.ToString() == clientKey) {\r\n                                    clientExists = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            \r\n                            if (!clientExists) {\r\n                                approvedClients.Add(clientKey);\r\n                            }\r\n                            \r\n                            // Base64 encode the client list\r\n                            string jsonClients = approvedClients.ToString(Newtonsoft.Json.Formatting.None);\r\n                            string encodedClients = System.Convert.ToBase64String(\r\n                                System.Text.Encoding.UTF8.GetBytes(jsonClients));\r\n                            \r\n                            // Return the full cookie string with appropriate settings\r\n                            return $\"{cookieName}={encodedClients}; Max-Age=31536000; Path=/; Secure; HttpOnly; SameSite=Lax\";\r\n                        }\" />\r\n                        \r\n                        <!-- Set variables for outbound policy awareness -->\r\n                        <set-variable name=\"consent_approved\" value=\"true\" />\r\n                        <set-variable name=\"cookie_name\" value=\"MCP_APPROVED_CLIENTS\" />\r\n                        \r\n                        <!-- Return the response with the cookie already set -->\r\n                        <return-response>\r\n                            <set-status code=\"302\" reason=\"Found\" />\r\n                            <set-header name=\"Location\" exists-action=\"override\">\r\n                                <value>@(context.Variables.GetValueOrDefault<string>(\"response_redirect_location\", \"\"))</value>\r\n                            </set-header>\r\n                            <set-header name=\"Set-Cookie\" exists-action=\"append\">\r\n                                <value>@(context.Variables.GetValueOrDefault<string>(\"approval_cookie\"))</value>\r\n                            </set-header>\r\n                        </return-response>\r\n                    </when>\r\n                    <when condition=\"@(context.Variables.GetValueOrDefault<string>(\"consent_action\") == \"deny\")\">\r\n                        <!-- Process consent denial -->\r\n                        <set-variable name=\"response_status_code\" value=\"403\" />\r\n                        <set-variable name=\"response_content_type\" value=\"text/html\" />\r\n                        <set-variable name=\"response_cache_control\" value=\"no-store, no-cache\" />\r\n                        <set-variable name=\"response_pragma\" value=\"no-cache\" />\r\n                        \r\n                        <!-- Calculate the cookie value right here in inbound before returning response -->\r\n                        <set-variable name=\"denial_cookie\" value=\"@{\r\n                            string cookieName = \"MCP_DENIED_CLIENTS\";\r\n                            \r\n                            // Use already extracted parameters instead of re-parsing form data\r\n                            string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                            string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                            \r\n                            // Create a unique identifier for this client/redirect combination\r\n                            string clientKey = $\"{clientId}:{redirectUri}\";\r\n                            \r\n                            // Check for existing cookie\r\n                            var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\r\n                            JArray deniedClients = new JArray();\r\n                            \r\n                            if (!string.IsNullOrEmpty(cookieHeader)) {\r\n                                // Parse cookies to find our denial cookie\r\n                                string[] cookies = cookieHeader.Split(';');\r\n                                foreach (string cookie in cookies) {\r\n                                    string trimmedCookie = cookie.Trim();\r\n                                    if (trimmedCookie.StartsWith(cookieName + \"=\")) {\r\n                                        try {\r\n                                            // Extract and parse the cookie value\r\n                                            string cookieValue = trimmedCookie.Substring(cookieName.Length + 1);\r\n                                            // Get the payload part (before the first dot if cookie is signed)\r\n                                            string payload = cookieValue.Contains('.') ? \r\n                                                cookieValue.Split('.')[0] : cookieValue;\r\n                                            string decodedValue = System.Text.Encoding.UTF8.GetString(\r\n                                                System.Convert.FromBase64String(payload));\r\n                                            deniedClients = JArray.Parse(decodedValue);\r\n                                        } catch (Exception) {\r\n                                            // If parsing fails, we'll just create a new cookie\r\n                                            deniedClients = new JArray();\r\n                                        }\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                            \r\n                            // Add the current client if not already in the list\r\n                            bool clientExists = false;\r\n                            foreach (var item in deniedClients) {\r\n                                if (item.ToString() == clientKey) {\r\n                                    clientExists = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            \r\n                            if (!clientExists) {\r\n                                deniedClients.Add(clientKey);\r\n                            }\r\n                            \r\n                            // Base64 encode the client list\r\n                            string jsonClients = deniedClients.ToString(Newtonsoft.Json.Formatting.None);\r\n                            string encodedClients = System.Convert.ToBase64String(\r\n                                System.Text.Encoding.UTF8.GetBytes(jsonClients));\r\n                            \r\n                            // Return the full cookie string with appropriate settings\r\n                            return $\"{cookieName}={encodedClients}; Max-Age=31536000; Path=/; Secure; HttpOnly; SameSite=Lax\";\r\n                        }\" />                        <!-- Store the HTML content for the access denied page -->\r\n                        <set-variable name=\"response_body\" value=\"@{\r\n                            string denialTemplate = context.Variables.GetValueOrDefault<string>(\"access_denied_template\");\r\n                            string commonStyles = context.Variables.GetValueOrDefault<string>(\"common_styles\");\r\n                            \r\n                            // Replace placeholders with actual content\r\n                            denialTemplate = denialTemplate.Replace(\"__COMMON_STYLES__\", commonStyles);\r\n                            denialTemplate = denialTemplate.Replace(\"__DENIAL_MESSAGE__\", \r\n                                \"You have denied authorization for this application against the MCP server.\");\r\n                            \r\n                            return denialTemplate;\r\n                        }\" />\r\n                        \r\n                        <!-- Set variables for outbound policy awareness -->\r\n                        <set-variable name=\"consent_denied\" value=\"true\" />\r\n                        <set-variable name=\"cookie_name\" value=\"MCP_DENIED_CLIENTS\" />\r\n                        \r\n                        <!-- Return the response with the cookie already set -->\r\n                        <return-response>\r\n                            <set-status code=\"403\" reason=\"Forbidden\" />\r\n                            <set-header name=\"Content-Type\" exists-action=\"override\">\r\n                                <value>text/html</value>\r\n                            </set-header>\r\n                            <set-header name=\"Cache-Control\" exists-action=\"override\">\r\n                                <value>no-store, no-cache</value>\r\n                            </set-header>\r\n                            <set-header name=\"Pragma\" exists-action=\"override\">\r\n                                <value>no-cache</value>\r\n                            </set-header>\r\n                            <set-header name=\"Set-Cookie\" exists-action=\"append\">\r\n                                <value>@(context.Variables.GetValueOrDefault<string>(\"denial_cookie\"))</value>\r\n                            </set-header>\r\n                            <set-body>@(context.Variables.GetValueOrDefault<string>(\"response_body\", \"\"))</set-body>\r\n                        </return-response>\r\n                    </when>\r\n                    <otherwise>\r\n                        <!-- Invalid consent action - return error -->\r\n                        <return-response>\r\n                            <set-status code=\"403\" reason=\"Forbidden\" />\r\n                            <set-header name=\"Content-Type\" exists-action=\"override\">\r\n                                <value>text/html</value>\r\n                            </set-header>\r\n                            <!-- Explicitly disable any redirects -->\r\n                            <set-header name=\"Cache-Control\" exists-action=\"override\">\r\n                                <value>no-store, no-cache</value>\r\n                            </set-header>\r\n                            <set-header name=\"Pragma\" exists-action=\"override\">\r\n                                <value>no-cache</value>\r\n                            </set-header>\r\n                            <set-body>@{\r\n                                string denialTemplate = context.Variables.GetValueOrDefault<string>(\"access_denied_template\");\r\n                                string commonStyles = context.Variables.GetValueOrDefault<string>(\"common_styles\");\r\n                                string consentAction = context.Variables.GetValueOrDefault<string>(\"consent_action\", \"\");\r\n                                \r\n                                string detailedMessage = $\"Invalid consent action '{consentAction}' received. Expected 'allow' or 'deny'. This may indicate a form tampering attempt or a browser compatibility issue.\";\r\n                                \r\n                                // Replace placeholders with actual content\r\n                                denialTemplate = denialTemplate.Replace(\"__COMMON_STYLES__\", commonStyles);\r\n                                denialTemplate = denialTemplate.Replace(\"__DENIAL_MESSAGE__\", detailedMessage);\r\n                                \r\n                                return denialTemplate;\r\n                            }</set-body>\r\n                        </return-response>\r\n                                            </otherwise>\r\n                                        </choose>\r\n                                    </otherwise>\r\n                                </choose>\r\n                            </otherwise>\r\n                        </choose>\r\n                    </otherwise>\r\n                </choose>\r\n            </when>\r\n            <!-- For GET requests, check for cookies first, then display consent page if no cookie found -->\r\n            <otherwise>\r\n                <choose>\r\n                    <!-- If there's an approval cookie, skip consent and redirect to authorization endpoint -->\r\n                    <when condition=\"@(context.Variables.GetValueOrDefault<bool>(\"has_approval_cookie\"))\">\r\n                        <!-- Set redirect location to authorization endpoint -->\r\n                        <set-variable name=\"response_redirect_location\" value=\"@{\r\n                            string baseUrl = \"{{APIMGatewayURL}}\";\r\n                            string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                            string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                            string state = context.Variables.GetValueOrDefault<string>(\"state\", \"\");\r\n                            \r\n                            // URL encode parameters to prevent injection attacks\r\n                            string encodedClientId = System.Net.WebUtility.UrlEncode(clientId);\r\n                            string encodedRedirectUri = System.Net.WebUtility.UrlEncode(redirectUri);\r\n                            // State is already properly encoded, don't double-encode\r\n                            string encodedState = state;\r\n                            \r\n                            // Add PKCE parameters if they exist\r\n                            string codeChallenge = context.Variables.GetValueOrDefault<string>(\"code_challenge\", \"\");\r\n                            string codeChallengeMethod = context.Variables.GetValueOrDefault<string>(\"code_challenge_method\", \"\");\r\n                            \r\n                            string url = $\"{baseUrl}/authorize?client_id={encodedClientId}&redirect_uri={encodedRedirectUri}&state={encodedState}\";\r\n                            \r\n                            if (!string.IsNullOrEmpty(codeChallenge)) {\r\n                                url += $\"&code_challenge={System.Net.WebUtility.UrlEncode(codeChallenge)}\";\r\n                            }\r\n                            \r\n                            if (!string.IsNullOrEmpty(codeChallengeMethod)) {\r\n                                url += $\"&code_challenge_method={System.Net.WebUtility.UrlEncode(codeChallengeMethod)}\";\r\n                            }\r\n                            \r\n                            return url;\r\n                        }\" />\r\n                        \r\n                        <!-- Redirect to authorization endpoint -->\r\n                        <return-response>\r\n                            <set-status code=\"302\" reason=\"Found\" />\r\n                            <set-header name=\"Location\" exists-action=\"override\">\r\n                                <value>@(context.Variables.GetValueOrDefault<string>(\"response_redirect_location\", \"\"))</value>\r\n                            </set-header>\r\n                        </return-response>\r\n                    </when>\r\n                    \r\n                    <!-- If there's a denial cookie, return access denied page immediately -->\r\n                    <when condition=\"@(context.Variables.GetValueOrDefault<bool>(\"has_denial_cookie\"))\">\r\n                        <return-response>\r\n                            <set-status code=\"403\" reason=\"Forbidden\" />\r\n                            <set-header name=\"Content-Type\" exists-action=\"override\">\r\n                                <value>text/html</value>\r\n                            </set-header>\r\n                            <!-- Explicitly disable any redirects -->\r\n                            <set-header name=\"Cache-Control\" exists-action=\"override\">\r\n                                <value>no-store, no-cache</value>\r\n                            </set-header>\r\n                            <set-header name=\"Pragma\" exists-action=\"override\">\r\n                                <value>no-cache</value>\r\n                            </set-header>\r\n                            <set-body>@{\r\n                                string denialTemplate = context.Variables.GetValueOrDefault<string>(\"access_denied_template\");\r\n                                string commonStyles = context.Variables.GetValueOrDefault<string>(\"common_styles\");\r\n                                \r\n                                // Replace placeholders with actual content\r\n                                denialTemplate = denialTemplate.Replace(\"__COMMON_STYLES__\", commonStyles);\r\n                                denialTemplate = denialTemplate.Replace(\"__DENIAL_MESSAGE__\", \r\n                                    \"You have previously denied access to this application.\");\r\n                                \r\n                                return denialTemplate;\r\n                            }</set-body>\r\n                        </return-response>\r\n                    </when>\r\n                      <!-- If no cookies found, show the consent screen -->\r\n                    <otherwise>\r\n                        <!-- Check if client is registered first -->\r\n                        <choose>\r\n                            <when condition=\"@(!context.Variables.GetValueOrDefault<bool>(\"is_client_registered\"))\">\r\n                                <!-- Client is not registered, show error page -->\r\n                                <return-response>\r\n                                    <set-status code=\"403\" reason=\"Forbidden\" />\r\n                                    <set-header name=\"Content-Type\" exists-action=\"override\">\r\n                                        <value>text/html</value>\r\n                                    </set-header>\r\n                                    <set-header name=\"Cache-Control\" exists-action=\"override\">\r\n                                        <value>no-store, no-cache</value>\r\n                                    </set-header>\r\n                                    <set-header name=\"Pragma\" exists-action=\"override\">\r\n                                        <value>no-cache</value>\r\n                                    </set-header>\r\n                                    <set-body>@{\r\n                                        string template = context.Variables.GetValueOrDefault<string>(\"client_not_found_template\");\r\n                                        string commonStyles = context.Variables.GetValueOrDefault<string>(\"common_styles\");\r\n                                        string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                                        string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                                        \r\n                                        // Replace placeholders with HTML-encoded content to prevent XSS\r\n                                        template = template.Replace(\"__COMMON_STYLES__\", commonStyles);\r\n                                        template = template.Replace(\"__CLIENT_ID_DISPLAY__\", System.Net.WebUtility.HtmlEncode(clientId));\r\n                                        template = template.Replace(\"__REDIRECT_URI__\", System.Net.WebUtility.HtmlEncode(redirectUri));\r\n                                        \r\n                                        return template;\r\n                                    }</set-body>\r\n                                </return-response>\r\n                            </when>\r\n                            <otherwise>                                <!-- Client is registered, get client name from the cache -->\r\n                                <!-- Build consent page using the standardized template -->\r\n                                <set-variable name=\"consent_page\" value=\"@{\r\n                                    string template = context.Variables.GetValueOrDefault<string>(\"consent_page_template\");\r\n                                    string commonStyles = context.Variables.GetValueOrDefault<string>(\"common_styles\");\r\n                                    \r\n                                    // Use the service URL from APIM configuration\r\n                                    string basePath = \"{{APIMGatewayURL}}\";\r\n                                    \r\n                                    string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                                    string clientName = context.Variables.GetValueOrDefault<string>(\"client_name\", \"Unknown Application\");\r\n                                    string clientUri = context.Variables.GetValueOrDefault<string>(\"client_uri\", \"N/A\");\r\n                                    string oauthScopes = context.Variables.GetValueOrDefault<string>(\"oauth_scopes\", \"\");\r\n                                    \r\n                                    // Get the normalized (human-readable) redirect URI for display\r\n                                    string normalizedRedirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                                    \r\n                                    // Use the normalized redirect URI for form submission to ensure consistency\r\n                                    string formRedirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                                    string htmlEncodedFormUri = System.Net.WebUtility.HtmlEncode(formRedirectUri);\r\n                                    \r\n                                    string state = context.Variables.GetValueOrDefault<string>(\"state\", \"\");\r\n                                    string csrfToken = context.Variables.GetValueOrDefault<string>(\"csrf_token\", \"\");\r\n                                    \r\n                                    // Create a temporary placeholder for the form fields\r\n                                    string FORM_FIELD_PLACEHOLDER = \"___ENCODED_REDIRECT_URI___\";\r\n                                    \r\n                                    // Replace the styles first\r\n                                    template = template.Replace(\"__COMMON_STYLES__\", commonStyles);\r\n                                    \r\n                                    // First, create a temporary placeholder for the form fields\r\n                                    template = template.Replace(\"value='__REDIRECT_URI__'\", \"value='\" + FORM_FIELD_PLACEHOLDER + \"'\");\r\n                                      \r\n                                    // Replace template placeholders with properly encoded values\r\n                                    template = template.Replace(\"__CLIENT_NAME__\", System.Net.WebUtility.HtmlEncode(clientName));\r\n                                    template = template.Replace(\"__CLIENT_URI__\", System.Net.WebUtility.HtmlEncode(clientUri));\r\n                                    // For display purposes, use HtmlEncode for safety\r\n                                    template = template.Replace(\"__CLIENT_ID_DISPLAY__\", System.Net.WebUtility.HtmlEncode(clientId));\r\n                                    template = template.Replace(\"__REDIRECT_URI__\", System.Net.WebUtility.HtmlEncode(normalizedRedirectUri));\r\n                                    // For form field values, use HtmlEncode for XSS protection\r\n                                    template = template.Replace(\"__CLIENT_ID_FORM__\", System.Net.WebUtility.HtmlEncode(clientId));\r\n                                    // State needs to be URL-decoded first since it comes URL-encoded from query, then HTML-encoded for form safety\r\n                                    string decodedState = System.Net.WebUtility.UrlDecode(state);\r\n                                    template = template.Replace(\"__STATE__\", System.Net.WebUtility.HtmlEncode(decodedState));\r\n                                    template = template.Replace(\"__CODE_CHALLENGE__\", System.Net.WebUtility.HtmlEncode(context.Variables.GetValueOrDefault<string>(\"code_challenge\", \"\")));\r\n                                    template = template.Replace(\"__CODE_CHALLENGE_METHOD__\", System.Net.WebUtility.HtmlEncode(context.Variables.GetValueOrDefault<string>(\"code_challenge_method\", \"\")));\r\n                                    template = template.Replace(\"__CSRF_TOKEN__\", System.Net.WebUtility.HtmlEncode(csrfToken));\r\n                                    template = template.Replace(\"__CONSENT_ACTION_URL__\", basePath + \"/consent\");                                    \r\n                                    // Handle space-separated OAuth scopes and create individual list items with HTML encoding\r\n                                    string[] scopeArray = oauthScopes.Split(new char[] {' '}, StringSplitOptions.RemoveEmptyEntries);\r\n                                    StringBuilder scopeList = new StringBuilder();\r\n                                    \r\n                                    foreach (string scope in scopeArray) {\r\n                                        scopeList.AppendLine($\"<li><code>{System.Net.WebUtility.HtmlEncode(scope)}</code></li>\");\r\n                                    }\r\n                                    \r\n                                    template = template.Replace(\"__OAUTH_SCOPES__\", scopeList.ToString());\r\n                                    \r\n                                // Replace form field placeholder with encoded URI\r\n                                template = template.Replace(FORM_FIELD_PLACEHOLDER, htmlEncodedFormUri);                                    return template;\r\n                                }\" />\r\n                                \r\n                                <!-- Return consent page -->\r\n                                <return-response>\r\n                                    <set-status code=\"200\" reason=\"OK\" />\r\n                                    <set-header name=\"Content-Type\" exists-action=\"override\">\r\n                                        <value>text/html</value>\r\n                                    </set-header>\r\n                                    <!-- Security headers -->\r\n                                    <set-header name=\"X-Frame-Options\" exists-action=\"override\">\r\n                                        <value>DENY</value>\r\n                                    </set-header>\r\n                                    <set-header name=\"X-Content-Type-Options\" exists-action=\"override\">\r\n                                        <value>nosniff</value>\r\n                                    </set-header>\r\n                                    <set-header name=\"X-XSS-Protection\" exists-action=\"override\">\r\n                                        <value>1; mode=block</value>\r\n                                    </set-header>\r\n                                    <set-header name=\"Referrer-Policy\" exists-action=\"override\">\r\n                                        <value>strict-origin-when-cross-origin</value>\r\n                                    </set-header>\r\n                                    <set-header name=\"Content-Security-Policy\" exists-action=\"override\">\r\n                                        <value>default-src 'self'; style-src 'unsafe-inline'; script-src 'none'; object-src 'none'; base-uri 'self'; form-action 'self' https:</value>\r\n                                    </set-header>\r\n                                    <set-header name=\"Cache-Control\" exists-action=\"override\">\r\n                                        <value>no-store, no-cache, must-revalidate</value>\r\n                                    </set-header>\r\n                                    <set-header name=\"Pragma\" exists-action=\"override\">\r\n                                        <value>no-cache</value>\r\n                                    </set-header>\r\n                                    <set-body>@{\r\n                                        return context.Variables.GetValueOrDefault<string>(\"consent_page\", \"\");\r\n                                    }</set-body>\r\n                                </return-response>\r\n                            </otherwise>\r\n                        </choose>\r\n                    </otherwise>\r\n                </choose>\r\n            </otherwise>\r\n        </choose>\r\n    </inbound>\r\n    <backend>\r\n        <base />\r\n    </backend>\r\n    <outbound>\r\n        <base />\r\n        <!-- Debug trace for variable verification -->\r\n        <trace source=\"outbound-debug\" severity=\"information\">\r\n            <message>@{\r\n                return $\"Outbound policy: consent_approved={context.Variables.GetValueOrDefault<bool>(\"consent_approved\")}, consent_denied={context.Variables.GetValueOrDefault<bool>(\"consent_denied\")}, cookie_name={context.Variables.GetValueOrDefault<string>(\"cookie_name\")}\";\r\n            }</message>\r\n        </trace>\r\n        \r\n        <!-- Set cookies based on consent decision -->\r\n        <choose>\r\n            <!-- Handle approval cookie -->\r\n            <when condition=\"@(context.Variables.GetValueOrDefault<bool>(\"consent_approved\"))\">\r\n                <set-header name=\"Set-Cookie\" exists-action=\"append\">\r\n                    <value>@{\r\n                        string cookieName = context.Variables.GetValueOrDefault<string>(\"cookie_name\", \"MCP_APPROVED_CLIENTS\");\r\n                        string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                        // Use normalized redirect URI for cookies\r\n                        string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                        \r\n                        // Create unique client/redirect identifier\r\n                        string clientKey = $\"{clientId}:{redirectUri}\";\r\n                        \r\n                        // Check for existing cookie\r\n                        var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\r\n                        JArray approvedClients = new JArray();\r\n                        \r\n                        if (!string.IsNullOrEmpty(cookieHeader)) {\r\n                            // Parse cookies to find approval cookie\r\n                            string[] cookies = cookieHeader.Split(';');\r\n                            foreach (string cookie in cookies) {\r\n                                string trimmedCookie = cookie.Trim();\r\n                                if (trimmedCookie.StartsWith(cookieName + \"=\")) {\r\n                                    try {\r\n                                        // Extract and parse cookie value\r\n                                        string cookieValue = trimmedCookie.Substring(cookieName.Length + 1);\r\n                                        // Get payload part (before first dot if signed)\r\n                                        string payload = cookieValue.Contains('.') ? \r\n                                            cookieValue.Split('.')[0] : cookieValue;\r\n                                        string decodedValue = System.Text.Encoding.UTF8.GetString(\r\n                                            System.Convert.FromBase64String(payload));\r\n                                        approvedClients = JArray.Parse(decodedValue);\r\n                                    } catch (Exception) {\r\n                                        // If parsing fails, create new cookie\r\n                                        approvedClients = new JArray();\r\n                                    }\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                        \r\n                        // Add the current client if not already in the list\r\n                        bool clientExists = false;\r\n                        foreach (var item in approvedClients) {\r\n                            if (item.ToString() == clientKey) {\r\n                                clientExists = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        \r\n                        if (!clientExists) {\r\n                            approvedClients.Add(clientKey);\r\n                        }\r\n                        \r\n                        // Base64 encode the client list\r\n                        string jsonClients = approvedClients.ToString(Newtonsoft.Json.Formatting.None);\r\n                        string encodedClients = System.Convert.ToBase64String(\r\n                            System.Text.Encoding.UTF8.GetBytes(jsonClients));\r\n                        \r\n                        // Return the cookie with appropriate settings\r\n                        return $\"{cookieName}={encodedClients}; Max-Age=31536000; Path=/; Secure; HttpOnly; SameSite=Lax\";\r\n                    }</value>\r\n                </set-header>\r\n                \r\n                <!-- Set response status and redirect for approval -->\r\n                <set-status code=\"@(context.Variables.GetValueOrDefault<int>(\"response_status_code\", 302))\" reason=\"Found\" />\r\n                <set-header name=\"Location\" exists-action=\"override\">\r\n                    <value>@(context.Variables.GetValueOrDefault<string>(\"response_redirect_location\", \"\"))</value>\r\n                </set-header>\r\n            </when>\r\n            \r\n            <!-- Handle denial cookie -->\r\n            <when condition=\"@(context.Variables.GetValueOrDefault<bool>(\"consent_denied\"))\">\r\n                <set-header name=\"Set-Cookie\" exists-action=\"append\">\r\n                    <value>@{\r\n                        string cookieName = context.Variables.GetValueOrDefault<string>(\"cookie_name\", \"MCP_DENIED_CLIENTS\");\r\n                        string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                        // Use normalized redirect URI for cookies\r\n                        string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                        \r\n                        // Create unique client/redirect identifier\r\n                        string clientKey = $\"{clientId}:{redirectUri}\";\r\n                        \r\n                        // Check for existing cookie\r\n                        var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\r\n                        JArray deniedClients = new JArray();\r\n                        \r\n                        if (!string.IsNullOrEmpty(cookieHeader)) {\r\n                            // Parse cookies to find denial cookie\r\n                            string[] cookies = cookieHeader.Split(';');\r\n                            foreach (string cookie in cookies) {\r\n                                string trimmedCookie = cookie.Trim();\r\n                                if (trimmedCookie.StartsWith(cookieName + \"=\")) {\r\n                                    try {\r\n                                        // Extract and parse cookie value\r\n                                        string cookieValue = trimmedCookie.Substring(cookieName.Length + 1);\r\n                                        // Get payload part (before first dot if signed)\r\n                                        string payload = cookieValue.Contains('.') ? \r\n                                            cookieValue.Split('.')[0] : cookieValue;\r\n                                        string decodedValue = System.Text.Encoding.UTF8.GetString(\r\n                                            System.Convert.FromBase64String(payload));\r\n                                        deniedClients = JArray.Parse(decodedValue);\r\n                                    } catch (Exception) {\r\n                                        // If parsing fails, create new cookie\r\n                                        deniedClients = new JArray();\r\n                                    }\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                        \r\n                        // Add client if not already in list\r\n                        bool clientExists = false;\r\n                        foreach (var item in deniedClients) {\r\n                            if (item.ToString() == clientKey) {\r\n                                clientExists = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        \r\n                        if (!clientExists) {\r\n                            deniedClients.Add(clientKey);\r\n                        }\r\n                        \r\n                        // Base64 encode client list\r\n                        string jsonClients = deniedClients.ToString(Newtonsoft.Json.Formatting.None);\r\n                        string encodedClients = System.Convert.ToBase64String(\r\n                            System.Text.Encoding.UTF8.GetBytes(jsonClients));\r\n                        \r\n                        // Return cookie with security settings\r\n                        return $\"{cookieName}={encodedClients}; Max-Age=31536000; Path=/; Secure; HttpOnly; SameSite=Lax\";\r\n                    }</value>\r\n                </set-header>\r\n            </when>\r\n        </choose>\r\n    </outbound>\r\n    <on-error>\r\n        <base />\r\n    </on-error>\r\n</policies>\r\n",
            "$fxv#8": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\r\n<!--\r\n    Consent Policy - Handles user consent for OAuth client applications\r\n    \r\n    Flow:\r\n    1. Check existing consent status (cookies)\r\n    2. Display consent form for new clients\r\n    3. Process user response (allow/deny)\r\n    4. Store decision and redirect appropriately\r\n-->\r\n<policies>\r\n    <inbound>        \r\n        <base />        \r\n        <!-- Helper function to extract parameters from form/query -->\r\n        <set-variable name=\"form_body\" value=\"@{\r\n            if (context.Request.Method == \"POST\") {\r\n                string contentType = context.Request.Headers.GetValueOrDefault(\"Content-Type\", \"\");\r\n                if (contentType.Contains(\"application/x-www-form-urlencoded\")) {\r\n                    return context.Request.Body.As<string>(preserveContent: true);\r\n                }\r\n            }\r\n            return \"\";\r\n        }\" />\r\n        \r\n        <!-- Extract request parameters using consolidated logic -->\r\n        <set-variable name=\"client_id\" value=\"@{\r\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\r\n            \r\n            // Check form data first (POST)\r\n            if (!string.IsNullOrEmpty(formBody)) {\r\n                string[] pairs = formBody.Split('&');\r\n                foreach (string pair in pairs) {\r\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\r\n                    if (keyValue.Length == 2 && keyValue[0] == \"client_id\") {\r\n                        return System.Net.WebUtility.UrlDecode(keyValue[1]);\r\n                    }\r\n                }\r\n            }\r\n            // Fallback to query string (GET)\r\n            return (string)context.Request.Url.Query.GetValueOrDefault(\"client_id\", \"\");\r\n        }\" />\r\n        \r\n        <set-variable name=\"redirect_uri\" value=\"@{\r\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\r\n            \r\n            // Check form data first (POST)\r\n            if (!string.IsNullOrEmpty(formBody)) {\r\n                string[] pairs = formBody.Split('&');\r\n                foreach (string pair in pairs) {\r\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\r\n                    if (keyValue.Length == 2 && keyValue[0] == \"redirect_uri\") {\r\n                        return keyValue[1]; // Keep encoded for normalization\r\n                    }\r\n                }\r\n            }\r\n            // Fallback to query string (GET)\r\n            return (string)context.Request.Url.Query.GetValueOrDefault(\"redirect_uri\", \"\");\r\n        }\" />\r\n        \r\n        <set-variable name=\"state\" value=\"@{\r\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\r\n            \r\n            // Check form data first (POST)\r\n            if (!string.IsNullOrEmpty(formBody)) {\r\n                string[] pairs = formBody.Split('&');\r\n                foreach (string pair in pairs) {\r\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\r\n                    if (keyValue.Length == 2 && keyValue[0] == \"state\") {\r\n                        return keyValue[1]; // Keep encoded\r\n                    }\r\n                }\r\n            }\r\n            // Fallback to query string (GET)\r\n            return (string)context.Request.Url.Query.GetValueOrDefault(\"state\", \"\") ?? \"\";\r\n        }\" />\r\n        \r\n        <set-variable name=\"code_challenge\" value=\"@{\r\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\r\n            \r\n            // Check form data first (POST)\r\n            if (!string.IsNullOrEmpty(formBody)) {\r\n                string[] pairs = formBody.Split('&');\r\n                foreach (string pair in pairs) {\r\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\r\n                    if (keyValue.Length == 2 && keyValue[0] == \"code_challenge\") {\r\n                        return keyValue[1]; // Keep encoded\r\n                    }\r\n                }\r\n            }\r\n            // Fallback to query string (GET)\r\n            return (string)context.Request.Url.Query.GetValueOrDefault(\"code_challenge\", \"\");\r\n        }\" />\r\n        \r\n        <set-variable name=\"code_challenge_method\" value=\"@{\r\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\r\n            \r\n            // Check form data first (POST)\r\n            if (!string.IsNullOrEmpty(formBody)) {\r\n                string[] pairs = formBody.Split('&');\r\n                foreach (string pair in pairs) {\r\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\r\n                    if (keyValue.Length == 2 && keyValue[0] == \"code_challenge_method\") {\r\n                        return keyValue[1]; // Keep encoded\r\n                    }\r\n                }\r\n            }\r\n            // Fallback to query string (GET)\r\n            return (string)context.Request.Url.Query.GetValueOrDefault(\"code_challenge_method\", \"\");\r\n        }\" />\r\n      \r\n         <set-variable name=\"access_denied_template\" value=\"@{\r\n            return @\"<!DOCTYPE html>\r\n<html lang='en'>\r\n<head>    <meta charset='UTF-8'>\r\n    <meta name='viewport' content='width=device-width, initial-scale=1.0'>\r\n    <title>Access Denied</title>\r\n    <style>\r\n__COMMON_STYLES__\r\n        .error-details {\r\n            background-color: #f8f9fa;\r\n            border: 1px solid #dee2e6;\r\n            border-radius: 8px;\r\n            padding: 20px;\r\n            margin: 20px 0;\r\n            font-family: 'Courier New', Consolas, monospace;\r\n            font-size: 14px;\r\n            line-height: 1.6;\r\n            white-space: pre-wrap;\r\n            overflow-x: auto;\r\n        }\r\n        \r\n        .error-title {\r\n            color: #dc3545;\r\n            font-weight: bold;\r\n            margin-bottom: 10px;\r\n        }\r\n        \r\n        .debug-section {\r\n            margin-top: 15px;\r\n            padding-top: 15px;\r\n            border-top: 1px solid #dee2e6;\r\n        }\r\n        \r\n        .debug-label {\r\n            font-weight: bold;\r\n            color: #495057;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class='consent-container'>\r\n        <h1 class='denial-heading'>Access Denied</h1>\r\n        <div class='error-details'>\r\n            <div class='error-title'>Error Details:</div>\r\n            __DENIAL_MESSAGE__\r\n        </div>\r\n        <p>The application will not be able to access your data.</p>\r\n        <p>You can close this window safely.</p>\r\n    </div>\r\n</body>\r\n</html>\";\r\n        }\" />\r\n        \r\n        <!-- Reusable function to generate 403 error response -->\r\n        <set-variable name=\"generate_403_response\" value=\"@{\r\n            string errorTemplate = context.Variables.GetValueOrDefault<string>(\"access_denied_template\");\r\n            string commonStyles = context.Variables.GetValueOrDefault<string>(\"common_styles\");\r\n            string message = \"Access denied.\";\r\n            \r\n            // Replace placeholders with actual content\r\n            errorTemplate = errorTemplate.Replace(\"__COMMON_STYLES__\", commonStyles);\r\n            errorTemplate = errorTemplate.Replace(\"__DENIAL_MESSAGE__\", message);\r\n            \r\n            return errorTemplate;\r\n        }\" />\r\n            <!-- Error page template -->\r\n        <set-variable name=\"client_not_found_template\" value=\"@{\r\n            return @\"<!DOCTYPE html>\r\n<html lang='en'>\r\n<head>    \r\n    <meta charset='UTF-8'>\r\n    <meta name='viewport' content='width=device-width, initial-scale=1.0'>\r\n    <title>Client Not Found</title>\r\n    <style>\r\n__COMMON_STYLES__\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class='consent-container'>        \r\n        <h1 class='denial-heading'>Client Not Found</h1>\r\n        <p>The client registration for the specified client was not found.</p>\r\n        <div class='client-info'>\r\n            <p><strong>Client ID:</strong> <code>__CLIENT_ID_DISPLAY__</code></p>\r\n            <p><strong>Redirect URI:</strong> <code>__REDIRECT_URI__</code></p>\r\n        </div>\r\n        <p>Please ensure that you are using a properly registered client application.</p>\r\n        <p>You can close this window safely.</p>\r\n    </div>\r\n</body>\r\n</html>\";\r\n        }\" />\r\n        <!-- Normalize redirect URI by handling potential double-encoding -->\r\n        <set-variable name=\"normalized_redirect_uri\" value=\"@{\r\n            string redirectUri = context.Variables.GetValueOrDefault<string>(\"redirect_uri\", \"\");\r\n            \r\n            if (string.IsNullOrEmpty(redirectUri)) {\r\n                return \"\";\r\n            }\r\n            \r\n            try {\r\n                string firstDecode = System.Net.WebUtility.UrlDecode(redirectUri);\r\n                \r\n                // Check if still encoded (contains % followed by hex digits)\r\n                if (firstDecode.Contains(\"%\") && System.Text.RegularExpressions.Regex.IsMatch(firstDecode, @\"%[0-9A-Fa-f]{2}\")) {\r\n                    // Double-encoded, decode again\r\n                    string secondDecode = System.Net.WebUtility.UrlDecode(firstDecode);\r\n                    return secondDecode;\r\n                } else {\r\n                    // Single encoding, first decode is sufficient\r\n                    return firstDecode;\r\n                }\r\n            } catch (Exception) {\r\n                // If decoding fails, return original value\r\n                return redirectUri;\r\n            }\r\n        }\" />\r\n        \r\n        <!-- Cache client information lookup -->\r\n        <cache-lookup-value key=\"@($\"ClientInfo-{context.Variables.GetValueOrDefault<string>(\"client_id\")}\")\" variable-name=\"clientInfoJson\" />\r\n        \r\n        <!-- Get OAuth scopes from configuration -->\r\n        <set-variable name=\"oauth_scopes\" value=\"{{OAuthScopes}}\" />\r\n        \r\n        <!-- Generate CSRF token for form protection (GET requests only) -->\r\n        <set-variable name=\"csrf_token\" value=\"@{\r\n            // Only generate tokens for GET requests (showing consent form)\r\n            // POST requests validate existing tokens, not generate new ones\r\n            if (context.Request.Method != \"GET\") {\r\n                return \"\";\r\n            }\r\n            \r\n            // Generate random CSRF token using Guid and timestamp\r\n            string guidPart = Guid.NewGuid().ToString(\"N\");\r\n            string timestampPart = DateTime.UtcNow.Ticks.ToString();\r\n            string combinedString = guidPart + timestampPart;\r\n            \r\n            // Create URL-safe token by encoding combined string\r\n            string token = System.Convert.ToBase64String(\r\n                System.Text.Encoding.UTF8.GetBytes(combinedString)\r\n            ).Replace(\"+\", \"-\").Replace(\"/\", \"_\").Replace(\"=\", \"\").Substring(0, 32);\r\n            \r\n            return token;\r\n        }\" />\r\n        \r\n        <!-- Cache CSRF token for validation (GET requests only) -->\r\n        <choose>\r\n            <when condition=\"@(context.Request.Method == \"GET\" && !string.IsNullOrEmpty(context.Variables.GetValueOrDefault<string>(\"csrf_token\")))\">\r\n                <cache-store-value key=\"@($\"CSRF-{context.Variables.GetValueOrDefault<string>(\"csrf_token\")}\")\" \r\n                                  value=\"@{\r\n                                      string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                                      string normalizedRedirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                                      string timestamp = DateTime.UtcNow.ToString(\"yyyy-MM-ddTHH:mm:ssZ\");\r\n                                      string tokenData = $\"{clientId}:{normalizedRedirectUri}:{timestamp}\";\r\n                                      \r\n                                      // Add debugging metadata\r\n                                      string debugInfo = $\"CACHED_AT:{DateTime.UtcNow:yyyy-MM-ddTHH:mm:ss.fffZ}\";\r\n                                      return $\"{tokenData}|{debugInfo}\";\r\n                                  }\" \r\n                                  duration=\"900\" />\r\n                <!-- Track token caching for debugging -->\r\n                <set-variable name=\"csrf_token_cached\" value=\"true\" />\r\n            </when>\r\n            <otherwise>\r\n                <set-variable name=\"csrf_token_cached\" value=\"false\" />\r\n            </otherwise>\r\n        </choose>\r\n          <!-- Validate client registration -->\r\n        <set-variable name=\"is_client_registered\" value=\"@{\r\n            try {\r\n                string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                \r\n                if (string.IsNullOrEmpty(clientId)) {\r\n                    return false;\r\n                }\r\n                \r\n                // Get client info from cache lookup\r\n                string clientInfoJson = context.Variables.GetValueOrDefault<string>(\"clientInfoJson\");\r\n                  if (string.IsNullOrEmpty(clientInfoJson)) {\r\n                    return false;\r\n                }\r\n                \r\n                // Parse client configuration\r\n                JObject clientInfo = JObject.Parse(clientInfoJson);\r\n                JArray redirectUris = clientInfo[\"redirect_uris\"]?.ToObject<JArray>();\r\n                \r\n                // Validate redirect URI is registered\r\n                if (redirectUris != null) {\r\n                    foreach (var uri in redirectUris) {\r\n                        // Normalize registered URI for comparison\r\n                        string registeredUri = System.Net.WebUtility.UrlDecode(uri.ToString());\r\n                        if (registeredUri == redirectUri) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                return false;\r\n            }\r\n            catch (Exception ex) {\r\n                return false;\r\n            }\r\n        }\" />\r\n        \r\n        <!-- Extract client name from cache -->\r\n        <set-variable name=\"client_name\" value=\"@{\r\n            try {\r\n                string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                \r\n                if (string.IsNullOrEmpty(clientId)) {\r\n                    return \"Unknown Application\";\r\n                }\r\n                \r\n                // Get client info from cache lookup\r\n                string clientInfoJson = context.Variables.GetValueOrDefault<string>(\"clientInfoJson\");\r\n                \r\n                if (string.IsNullOrEmpty(clientInfoJson)) {\r\n                    return clientId;\r\n                }\r\n                \r\n                // Parse client configuration\r\n                JObject clientInfo = JObject.Parse(clientInfoJson);\r\n                string clientName = clientInfo[\"client_name\"]?.ToString();\r\n                \r\n                return string.IsNullOrEmpty(clientName) ? clientId : clientName;\r\n            }\r\n            catch (Exception ex) {\r\n                return context.Variables.GetValueOrDefault<string>(\"client_id\", \"Unknown Application\");\r\n            }\r\n        }\" />\r\n        \r\n        <!-- Extract client URI from cache -->\r\n        <set-variable name=\"client_uri\" value=\"@{\r\n            try {\r\n                // Get client info from cache lookup\r\n                string clientInfoJson = context.Variables.GetValueOrDefault<string>(\"clientInfoJson\");\r\n                \r\n                if (string.IsNullOrEmpty(clientInfoJson)) {\r\n                    return \"N/A\";\r\n                }\r\n                \r\n                // Parse client configuration\r\n                JObject clientInfo = JObject.Parse(clientInfoJson);\r\n                string clientUri = clientInfo[\"client_uri\"]?.ToString();\r\n                \r\n                return string.IsNullOrEmpty(clientUri) ? \"N/A\" : clientUri;\r\n            }\r\n            catch (Exception ex) {\r\n                return \"N/A\";\r\n            }\r\n        }\" />\r\n        \r\n        <!-- Define common styles for consent and error pages -->\r\n        <set-variable name=\"common_styles\" value=\"@{\r\n            return @\"        body {\r\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\r\n            max-width: 100%;\r\n            margin: 0;            padding: 0;\r\n            line-height: 1.6;\r\n            min-height: 100vh;\r\n            background: linear-gradient(135deg, #1f1f1f, #333344, #3f4066); /* Modern dark gradient */\r\n            color: #333333;\r\n            display: flex;\r\n            justify-content: center;\r\n            align-items: center;\r\n        }.container, .consent-container {\r\n            background-color: #ffffff;\r\n            border-radius: 4px; /* Adding some subtle rounding */\r\n            padding: 30px;\r\n            max-width: 600px;            width: 90%;\r\n            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);\r\n            border: none;\r\n        }\r\n        \r\n        h1 {\r\n            margin-bottom: 20px;\r\n            border-bottom: 1px solid #EDEBE9;\r\n            padding-bottom: 10px;\r\n            font-weight: 500;\r\n        }\r\n        .consent-heading {\r\n            color: #0078D4; /* Microsoft Blue */\r\n        }\r\n        .denial-heading {\r\n            color: #D83B01; /* Microsoft Attention color */\r\n        }\r\n        \r\n        p {\r\n            margin: 15px 0;\r\n            line-height: 1.7;\r\n            color: #323130; /* Microsoft text color */\r\n        }          .client-info {\r\n            background-color: #F5F5F5; /* Light gray background for info boxes */\r\n            padding: 15px;\r\n            border-radius: 4px; /* Adding some subtle rounding */\r\n            margin: 15px 0;\r\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);\r\n            border: 1px solid #EDEBE9;\r\n        }\r\n          .client-info p {\r\n            display: flex;\r\n            align-items: flex-start;\r\n            margin: 8px 0;\r\n        }\r\n        \r\n        .client-info strong {\r\n            min-width: 160px;\r\n            flex-shrink: 0;\r\n            text-align: left;\r\n            padding-right: 15px;\r\n            color: #0078D4; /* Microsoft Blue */\r\n        }\r\n          .client-info code {\r\n            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;\r\n            background-color: rgba(240, 240, 250, 0.5);\r\n            padding: 2px 6px;\r\n            border-radius: 4px; /* Adding some subtle rounding */\r\n            color: #0078D4; /* Microsoft Blue */\r\n            word-break: break-all;\r\n        }\r\n          .btn {\r\n            display: inline-block;\r\n            padding: 8px 16px;\r\n            margin: 10px 0;\r\n            border-radius: 4px; /* Adding some subtle rounding */\r\n            text-decoration: none;\r\n            font-weight: 600;\r\n            cursor: pointer;\r\n            transition: all 0.2s ease;\r\n        }\r\n        \r\n        .btn-primary {\r\n            background-color: #0078D4; /* Microsoft Blue */\r\n            color: white;\r\n            border: none;\r\n        }\r\n        .btn-primary:hover {\r\n            background-color: #106EBE; /* Microsoft Blue hover */\r\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);\r\n        }\r\n        \r\n        .btn-secondary {\r\n            background-color: #D83B01; /* Microsoft Red */\r\n            color: white; /* White text */\r\n            border: none;\r\n        }\r\n        .btn-secondary:hover {\r\n            background-color: #A80000; /* Darker red on hover */\r\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);\r\n        }\r\n          .buttons {\r\n            margin-top: 20px;\r\n            display: flex;\r\n            gap: 10px;\r\n            justify-content: flex-start;\r\n        }\r\n        \r\n        a {\r\n            color: #0078D4; /* Microsoft Blue */\r\n            text-decoration: none;\r\n            font-weight: 600;\r\n        }\r\n        a:hover {\r\n            text-decoration: underline;\r\n        }\r\n        strong {\r\n            color: #0078D4; /* Microsoft Blue */\r\n            font-weight: 600;\r\n        }          .error-message {\r\n            background-color: #FDE7E9; /* Light red background */\r\n            padding: 15px;\r\n            margin: 15px 0;\r\n            border-radius: 4px; /* Adding some subtle rounding */\r\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);\r\n            border-left: 3px solid #D83B01; /* Microsoft Attention color */\r\n        }\r\n        \r\n        .error-message p {\r\n            margin: 8px 0;\r\n        }\r\n        \r\n        .error-message p:first-child {\r\n            font-weight: 500;\r\n            color: #D83B01; /* Microsoft Attention color */\r\n        }\";\r\n        }\" />\r\n        \r\n        <!-- Consent page HTML template -->\r\n        <set-variable name=\"consent_page_template\" value=\"@{\r\n            return @\"<!DOCTYPE html>\r\n<html lang='en'>\r\n<head>    <meta charset='UTF-8'>\r\n    <meta name='viewport' content='width=device-width, initial-scale=1.0'>\r\n    <title>Application Consent</title>\r\n    <style>\r\n__COMMON_STYLES__    /* Additional styles for scopes list */\r\n    .scopes-list {\r\n        margin: 0;\r\n        padding-left: 0;\r\n    }\r\n    .scopes-list li {\r\n        list-style-type: none;\r\n        padding: 4px 0;\r\n        display: flex;\r\n    }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class='consent-container'>\r\n        <h1 class='consent-heading'>Application Access Request</h1>\r\n\r\n        <p>The following application is requesting access to <strong>{{MCPServerName}}</strong>, which might include access to everything <strong>{{MCPServerName}}</strong> has been and will be granted access to.</p>\r\n        \r\n        <div class='client-info'>\r\n            <p><strong>Application Name:</strong> <code>__CLIENT_NAME__</code></p>\r\n            <p><strong>Application Website:</strong> <code>__CLIENT_URI__</code></p>\r\n            <p><strong>Application ID:</strong> <code>__CLIENT_ID_DISPLAY__</code></p>\r\n            <p><strong>Redirect URI:</strong> <code>__REDIRECT_URI__</code></p>\r\n        </div>        \r\n        <p>The application will have access to the following scopes, used by <strong>{{MCPServerName}}</strong>:</p>\r\n        <div class='client-info'>\r\n            <ul class='scopes-list'>\r\n                <li>__OAUTH_SCOPES__</li>\r\n            </ul>\r\n        </div>        <div class='buttons'>\r\n            <form method='post' action='__CONSENT_ACTION_URL__' style='display: inline-block;'>\r\n                <input type='hidden' name='client_id' value='__CLIENT_ID_FORM__'>\r\n                <input type='hidden' name='redirect_uri' value='__REDIRECT_URI__'>\r\n                <input type='hidden' name='state' value='__STATE__'>\r\n                <input type='hidden' name='code_challenge' value='__CODE_CHALLENGE__'>\r\n                <input type='hidden' name='code_challenge_method' value='__CODE_CHALLENGE_METHOD__'>\r\n                <input type='hidden' name='csrf_token' value='__CSRF_TOKEN__'>\r\n                <input type='hidden' name='consent_action' value='allow'>\r\n                <button type='submit' class='btn btn-primary'>Allow</button>\r\n            </form>\r\n            \r\n            <form method='post' action='__CONSENT_ACTION_URL__' style='display: inline-block;'>                <input type='hidden' name='client_id' value='__CLIENT_ID_FORM__'>\r\n                <input type='hidden' name='redirect_uri' value='__REDIRECT_URI__'>\r\n                <input type='hidden' name='state' value='__STATE__'>\r\n                <input type='hidden' name='code_challenge' value='__CODE_CHALLENGE__'>\r\n                <input type='hidden' name='code_challenge_method' value='__CODE_CHALLENGE_METHOD__'>\r\n                <input type='hidden' name='csrf_token' value='__CSRF_TOKEN__'>\r\n                <input type='hidden' name='consent_action' value='deny'>\r\n                <button type='submit' class='btn btn-secondary'>Deny</button>\r\n            </form>\r\n        </div>\r\n    </div>\r\n</body>\r\n</html>\";\r\n        }\" />\r\n\r\n        <!-- Check for existing client denial cookie -->\r\n        <set-variable name=\"has_denial_cookie\" value=\"@{\r\n            try {\r\n                if (string.IsNullOrEmpty(context.Variables.GetValueOrDefault<string>(\"client_id\", \"\")) || \r\n                    string.IsNullOrEmpty(context.Variables.GetValueOrDefault<string>(\"redirect_uri\", \"\"))) {\r\n                    return false;\r\n                }\r\n                  \r\n                string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                // Use normalized redirect URI for consistency\r\n                string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                \r\n                // Cookie name for client denials\r\n                string DENIAL_COOKIE_NAME = \"MCP_DENIED_CLIENTS\";\r\n                \r\n                // Check for denial cookie in request\r\n                var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\r\n                if (string.IsNullOrEmpty(cookieHeader)) {\r\n                    return false;\r\n                }\r\n                \r\n                // Parse cookie header for denial cookie\r\n                string[] cookies = cookieHeader.Split(';');\r\n                foreach (string cookie in cookies) {\r\n                    string trimmedCookie = cookie.Trim();\r\n                    if (trimmedCookie.StartsWith(DENIAL_COOKIE_NAME + \"=\")) {\r\n                        // Extract cookie value\r\n                        string cookieValue = trimmedCookie.Substring(DENIAL_COOKIE_NAME.Length + 1);\r\n                        try {\r\n                            // Parse base64-encoded JSON array of denied clients\r\n                            string decodedValue = System.Text.Encoding.UTF8.GetString(\r\n                                System.Convert.FromBase64String(cookieValue.Split('.')[0]));\r\n                            JArray deniedClients = JArray.Parse(decodedValue);                            \r\n                            \r\n                            // Create client/redirect identifier\r\n                            // Use normalized redirect URI for consistency\r\n                            string clientKey = $\"{clientId}:{redirectUri}\";\r\n                            \r\n                            foreach (var item in deniedClients) {\r\n                                string itemString = item.ToString();\r\n                                \r\n                                // Direct comparison using normalized URI\r\n                                if (itemString == clientKey) {\r\n                                    return true;\r\n                                }\r\n                                \r\n                                // Handle URL-encoded redirect URI in stored cookie\r\n                                try {\r\n                                    string storedValue = itemString;\r\n                                    if (storedValue.Contains(':')) {\r\n                                        string[] parts = storedValue.Split(new char[] {':'}, 2);\r\n                                        if (parts.Length == 2) {\r\n                                            string storedClientId = parts[0];\r\n                                            // Decode stored redirect URI for comparison\r\n                                            string storedRedirectUri = System.Net.WebUtility.UrlDecode(parts[1]);\r\n                                            \r\n                                            // Compare both decoded forms\r\n                                            if (storedClientId == clientId && storedRedirectUri == redirectUri) {\r\n                                                return true;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                } catch (Exception ex) {\r\n                                    // Ignore comparison errors and continue\r\n                                }\r\n                            }\r\n                        } catch (Exception ex) {\r\n                            // Ignore cookie parsing errors and continue\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                return false;\r\n            } catch (Exception ex) {\r\n                return false;\r\n            }\r\n        }\" />\r\n        \r\n        <!-- Check for existing client approval cookie -->\r\n        <set-variable name=\"has_approval_cookie\" value=\"@{\r\n            try {\r\n                if (string.IsNullOrEmpty(context.Variables.GetValueOrDefault<string>(\"client_id\", \"\")) || \r\n                    string.IsNullOrEmpty(context.Variables.GetValueOrDefault<string>(\"redirect_uri\", \"\"))) {\r\n                    return false;\r\n                }\r\n                  \r\n                string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                // Use normalized redirect URI for consistency\r\n                string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                \r\n                // Cookie name for client approvals\r\n                string APPROVAL_COOKIE_NAME = \"MCP_APPROVED_CLIENTS\";\r\n                \r\n                // Check for approval cookie in request\r\n                var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\r\n                if (string.IsNullOrEmpty(cookieHeader)) {\r\n                    return false;\r\n                }\r\n                \r\n                // Parse cookie header for approval cookie\r\n                string[] cookies = cookieHeader.Split(';');\r\n                foreach (string cookie in cookies) {\r\n                    string trimmedCookie = cookie.Trim();\r\n                    if (trimmedCookie.StartsWith(APPROVAL_COOKIE_NAME + \"=\")) {\r\n                        // Extract cookie value\r\n                        string cookieValue = trimmedCookie.Substring(APPROVAL_COOKIE_NAME.Length + 1);\r\n                        try {                            \r\n                            // Parse base64-encoded JSON array of approved clients\r\n                            string decodedValue = System.Text.Encoding.UTF8.GetString(\r\n                                System.Convert.FromBase64String(cookieValue.Split('.')[0]));\r\n                            JArray approvedClients = JArray.Parse(decodedValue);\r\n                            \r\n                            // Create client/redirect identifier\r\n                            // Use normalized redirect URI for consistency\r\n                            string clientKey = $\"{clientId}:{redirectUri}\";\r\n                            \r\n                            foreach (var item in approvedClients) {\r\n                                string itemString = item.ToString();\r\n                                \r\n                                // Direct comparison using normalized URI\r\n                                if (itemString == clientKey) {\r\n                                    return true;\r\n                                }\r\n                                \r\n                                // Handle URL-encoded redirect URI in stored cookie\r\n                                try {\r\n                                    string storedValue = itemString;\r\n                                    if (storedValue.Contains(':')) {\r\n                                        string[] parts = storedValue.Split(new char[] {':'}, 2);\r\n                                        if (parts.Length == 2) {\r\n                                            string storedClientId = parts[0];\r\n                                            // Decode stored redirect URI for comparison\r\n                                            string storedRedirectUri = System.Net.WebUtility.UrlDecode(parts[1]);\r\n                                            \r\n                                            // Compare both decoded forms\r\n                                            if (storedClientId == clientId && storedRedirectUri == redirectUri) {\r\n                                                return true;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                } catch (Exception ex) {\r\n                                    // Ignore comparison errors and continue\r\n                                }\r\n                            }\r\n                        } catch (Exception ex) {\r\n                            // Ignore cookie parsing errors and continue\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                return false;\r\n            } catch (Exception ex) {\r\n                return false;\r\n            }\r\n        }\" />\r\n        \r\n        <set-variable name=\"consent_action\" value=\"@{\r\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\r\n            \r\n            if (!string.IsNullOrEmpty(formBody)) {\r\n                string[] pairs = formBody.Split('&');\r\n                foreach (string pair in pairs) {\r\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\r\n                    if (keyValue.Length == 2 && keyValue[0] == \"consent_action\") {\r\n                        return System.Net.WebUtility.UrlDecode(keyValue[1]);\r\n                    }\r\n                }\r\n                // Fallback to JSON parsing if form parsing failed\r\n                return context.Request.Body.As<JObject>(preserveContent: true)[\"consent_action\"]?.ToString() ?? \"\";\r\n            }\r\n            return \"\";\r\n        }\" />\r\n        \r\n        <!-- Extract CSRF token from form data -->\r\n        <set-variable name=\"csrf_token_from_form\" value=\"@{\r\n            string formBody = context.Variables.GetValueOrDefault<string>(\"form_body\", \"\");\r\n            \r\n            if (!string.IsNullOrEmpty(formBody)) {\r\n                string[] pairs = formBody.Split('&');\r\n                foreach (string pair in pairs) {\r\n                    string[] keyValue = pair.Split(new char[] {'='}, 2);\r\n                    if (keyValue.Length == 2 && keyValue[0] == \"csrf_token\") {\r\n                        return System.Net.WebUtility.UrlDecode(keyValue[1]);\r\n                    }\r\n                }\r\n            }\r\n            return \"\";\r\n        }\" />\r\n        \r\n        <!-- Validate CSRF token for POST requests -->\r\n        <set-variable name=\"csrf_valid\" value=\"@{\r\n            if (context.Request.Method != \"POST\") {\r\n                return true; // Only validate POST requests\r\n            }\r\n            \r\n            string submittedToken = context.Variables.GetValueOrDefault<string>(\"csrf_token_from_form\", \"\");\r\n            if (string.IsNullOrEmpty(submittedToken)) {\r\n                return false;\r\n            }\r\n            \r\n            // Token cache lookup validation happens next\r\n            string cacheKey = $\"CSRF-{submittedToken}\";\r\n            \r\n            return true; // Initial validation passes, detailed validation follows\r\n        }\" />\r\n        \r\n        <!-- Validate Origin/Referer headers for CSRF protection -->\r\n        <set-variable name=\"origin_referer_valid\" value=\"@{\r\n            if (context.Request.Method != \"POST\") {\r\n                return true; // Only validate state-changing operations\r\n            }\r\n            \r\n            // Get the target origin (expected origin)\r\n            string targetOrigin = \"{{APIMGatewayURL}}\";\r\n            \r\n            // Remove protocol and trailing slash for comparison\r\n            if (targetOrigin.StartsWith(\"https://\")) {\r\n                targetOrigin = targetOrigin.Substring(8);\r\n            } else if (targetOrigin.StartsWith(\"http://\")) {\r\n                targetOrigin = targetOrigin.Substring(7);\r\n            }\r\n            if (targetOrigin.EndsWith(\"/\")) {\r\n                targetOrigin = targetOrigin.TrimEnd('/');\r\n            }\r\n            \r\n            // First check Origin header (preferred)\r\n            string originHeader = context.Request.Headers.GetValueOrDefault(\"Origin\", \"\");\r\n            if (!string.IsNullOrEmpty(originHeader)) {\r\n                try {\r\n                    Uri originUri = new Uri(originHeader);\r\n                    string sourceOrigin = originUri.Host;\r\n                    if (originUri.Port != 80 && originUri.Port != 443) {\r\n                        sourceOrigin += \":\" + originUri.Port;\r\n                    }\r\n                    \r\n                    if (sourceOrigin.Equals(targetOrigin, StringComparison.OrdinalIgnoreCase)) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                } catch (Exception ex) {\r\n                    return false;\r\n                }\r\n            }\r\n            \r\n            // Fallback to Referer header if Origin is not present\r\n            string refererHeader = context.Request.Headers.GetValueOrDefault(\"Referer\", \"\");\r\n            if (!string.IsNullOrEmpty(refererHeader)) {\r\n                try {\r\n                    Uri refererUri = new Uri(refererHeader);\r\n                    string sourceOrigin = refererUri.Host;\r\n                    if (refererUri.Port != 80 && refererUri.Port != 443) {\r\n                        sourceOrigin += \":\" + refererUri.Port;\r\n                    }\r\n                    \r\n                    if (sourceOrigin.Equals(targetOrigin, StringComparison.OrdinalIgnoreCase)) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                } catch (Exception ex) {\r\n                    return false;\r\n                }\r\n            }\r\n            \r\n            // Neither Origin nor Referer header present - this is suspicious for POST requests\r\n            // OWASP recommends blocking such requests for better security\r\n            return false; // Block requests without proper origin validation\r\n        }\" />\r\n        \r\n        <!-- Validate Fetch Metadata headers for CSRF protection -->\r\n        <set-variable name=\"fetch_metadata_valid\" value=\"@{\r\n            // Check Sec-Fetch-Site header for cross-site request detection\r\n            string secFetchSite = context.Request.Headers.GetValueOrDefault(\"Sec-Fetch-Site\", \"\");\r\n            \r\n            // Allow same-origin, same-site, and direct navigation\r\n            if (string.IsNullOrEmpty(secFetchSite) || \r\n                secFetchSite == \"same-origin\" || \r\n                secFetchSite == \"same-site\" || \r\n                secFetchSite == \"none\") {\r\n                return true;\r\n            }\r\n            \r\n            // Block cross-site POST requests\r\n            if (context.Request.Method == \"POST\" && secFetchSite == \"cross-site\") {\r\n                return false;\r\n            }\r\n            \r\n            // Allow other values for compatibility\r\n            return true;\r\n        }\" />\r\n        \r\n        <!-- Lookup CSRF token from cache -->\r\n        <cache-lookup-value key=\"@($\"CSRF-{context.Variables.GetValueOrDefault<string>(\"csrf_token_from_form\")}\")\" variable-name=\"csrf_token_data\" />\r\n        \r\n        <!-- Validate CSRF token details -->\r\n        <set-variable name=\"csrf_validation_result\" value=\"@{\r\n            if (context.Request.Method != \"POST\") {\r\n                return \"valid\"; // No validation needed for GET requests\r\n            }\r\n            \r\n            string submittedToken = context.Variables.GetValueOrDefault<string>(\"csrf_token_from_form\", \"\");\r\n            if (string.IsNullOrEmpty(submittedToken)) {\r\n                return \"missing_token\";\r\n            }\r\n            \r\n            string tokenData = context.Variables.GetValueOrDefault<string>(\"csrf_token_data\");\r\n            if (string.IsNullOrEmpty(tokenData)) {\r\n                return \"invalid_token\";\r\n            }\r\n            \r\n            try {\r\n                // Extract token data (before debug info separator)\r\n                string actualTokenData = tokenData;\r\n                if (tokenData.Contains(\"|\")) {\r\n                    actualTokenData = tokenData.Split('|')[0];\r\n                }\r\n                \r\n                // Parse token data: client_id:redirect_uri:timestamp\r\n                // Since both redirect_uri and timestamp can contain colons, we need to be very careful\r\n                // The timestamp format is: YYYY-MM-DDTHH:mm:ssZ\r\n                // So we look for the last occurrence of a timestamp pattern\r\n                \r\n                // Find the last occurrence of a timestamp pattern (YYYY-MM-DDTHH:mm:ssZ)\r\n                var timestampPattern = @\":\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$\";\r\n                var timestampMatch = System.Text.RegularExpressions.Regex.Match(actualTokenData, timestampPattern);\r\n                \r\n                if (!timestampMatch.Success) {\r\n                    return \"malformed_token\";\r\n                }\r\n                \r\n                // Extract the timestamp (without the leading colon)\r\n                string timestampStr = timestampMatch.Value.Substring(1);\r\n                \r\n                // Extract everything before the timestamp match as the client_id:redirect_uri part\r\n                string clientAndRedirect = actualTokenData.Substring(0, timestampMatch.Index);\r\n                \r\n                // Split client_id:redirect_uri on the first colon only\r\n                int firstColonIndex = clientAndRedirect.IndexOf(':');\r\n                if (firstColonIndex == -1) {\r\n                    return \"malformed_token\";\r\n                }\r\n                \r\n                string tokenClientId = clientAndRedirect.Substring(0, firstColonIndex);\r\n                string tokenRedirectUri = clientAndRedirect.Substring(firstColonIndex + 1);\r\n                \r\n                // Validate client_id and redirect_uri match using constant-time comparison\r\n                string currentClientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                string currentRedirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                \r\n                // Constant-time string comparison for client_id to prevent timing attacks\r\n                bool clientIdMatches = true;\r\n                if (tokenClientId == null || currentClientId == null) {\r\n                    clientIdMatches = (tokenClientId == currentClientId);\r\n                } else if (tokenClientId.Length != currentClientId.Length) {\r\n                    clientIdMatches = false;\r\n                } else {\r\n                    int result = 0;\r\n                    for (int i = 0; i < tokenClientId.Length; i++) {\r\n                        result |= tokenClientId[i] ^ currentClientId[i];\r\n                    }\r\n                    clientIdMatches = (result == 0);\r\n                }\r\n                \r\n                if (!clientIdMatches) {\r\n                    return \"client_mismatch\";\r\n                }\r\n                \r\n                // Constant-time string comparison for redirect_uri to prevent timing attacks\r\n                bool redirectUriMatches = true;\r\n                if (tokenRedirectUri == null || currentRedirectUri == null) {\r\n                    redirectUriMatches = (tokenRedirectUri == currentRedirectUri);\r\n                } else if (tokenRedirectUri.Length != currentRedirectUri.Length) {\r\n                    redirectUriMatches = false;\r\n                } else {\r\n                    int result = 0;\r\n                    for (int i = 0; i < tokenRedirectUri.Length; i++) {\r\n                        result |= tokenRedirectUri[i] ^ currentRedirectUri[i];\r\n                    }\r\n                    redirectUriMatches = (result == 0);\r\n                }\r\n                \r\n                if (!redirectUriMatches) {\r\n                    return \"redirect_mismatch\";\r\n                }\r\n                \r\n                // Validate timestamp (token should not be older than 15 minutes)\r\n                DateTime tokenTime;\r\n                try {\r\n                    tokenTime = DateTime.Parse(timestampStr);\r\n                } catch (Exception) {\r\n                    return \"invalid_timestamp\";\r\n                }\r\n                \r\n                TimeSpan age = DateTime.UtcNow - tokenTime;\r\n                if (age.TotalMinutes > 15) {\r\n                    return \"expired_token\";\r\n                }\r\n                \r\n                return \"valid\";\r\n                \r\n            } catch (Exception ex) {\r\n                return \"validation_error\";\r\n            }\r\n        }\" />\r\n        \r\n        <!-- If this is a form submission, process the consent choice -->\r\n        <choose>\r\n            <when condition=\"@(context.Request.Method == \"POST\")\">\r\n                <!-- Validate Origin/Referer headers -->\r\n                <choose>\r\n                    <when condition=\"@(!context.Variables.GetValueOrDefault<bool>(\"origin_referer_valid\"))\">\r\n                        <!-- Origin/Referer validation failed -->\r\n                        <return-response>\r\n                            <set-status code=\"403\" reason=\"Forbidden\" />\r\n                            <set-header name=\"Content-Type\" exists-action=\"override\">\r\n                                <value>text/html</value>\r\n                            </set-header>\r\n                            <set-header name=\"Cache-Control\" exists-action=\"override\">\r\n                                <value>no-store, no-cache</value>\r\n                            </set-header>\r\n                            <set-header name=\"Pragma\" exists-action=\"override\">\r\n                                <value>no-cache</value>\r\n                            </set-header>\r\n                            <set-body>@(context.Variables.GetValueOrDefault<string>(\"generate_403_response\"))</set-body>\r\n                        </return-response>\r\n                    </when>\r\n                    <otherwise>\r\n                        <!-- Origin/Referer validation passed -->\r\n                        <!-- Validate Fetch Metadata headers -->\r\n                        <choose>\r\n                            <when condition=\"@(!context.Variables.GetValueOrDefault<bool>(\"fetch_metadata_valid\"))\">\r\n                                <!-- Fetch metadata validation failed -->\r\n                                <return-response>\r\n                                    <set-status code=\"403\" reason=\"Forbidden\" />\r\n                                    <set-header name=\"Content-Type\" exists-action=\"override\">\r\n                                        <value>text/html</value>\r\n                                    </set-header>\r\n                                    <set-header name=\"Cache-Control\" exists-action=\"override\">\r\n                                        <value>no-store, no-cache</value>\r\n                                    </set-header>\r\n                                    <set-header name=\"Pragma\" exists-action=\"override\">\r\n                                        <value>no-cache</value>\r\n                                    </set-header>\r\n                                    <set-body>@(context.Variables.GetValueOrDefault<string>(\"generate_403_response\"))</set-body>\r\n                                </return-response>\r\n                            </when>\r\n                            <otherwise>\r\n                                <!-- Fetch metadata validation passed -->\r\n                                <!-- Validate CSRF token -->\r\n                                <choose>\r\n                                    <when condition=\"@(context.Variables.GetValueOrDefault<string>(\"csrf_validation_result\") != \"valid\")\">\r\n                                        <!-- CSRF validation failed -->\r\n                                        <return-response>\r\n                                            <set-status code=\"403\" reason=\"Forbidden\" />\r\n                                            <set-header name=\"Content-Type\" exists-action=\"override\">\r\n                                                <value>text/html</value>\r\n                                            </set-header>\r\n                                            <set-header name=\"Cache-Control\" exists-action=\"override\">\r\n                                                <value>no-store, no-cache</value>\r\n                                            </set-header>\r\n                                            <set-header name=\"Pragma\" exists-action=\"override\">\r\n                                                <value>no-cache</value>\r\n                                            </set-header>\r\n                                            <set-body>@(context.Variables.GetValueOrDefault<string>(\"generate_403_response\"))</set-body>\r\n                                        </return-response>\r\n                                    </when>\r\n                                    <otherwise>\r\n                                        <!-- CSRF validation passed -->\r\n                                        <!-- Delete CSRF token from cache to prevent reuse -->\r\n                                        <cache-remove-value key=\"@($\"CSRF-{context.Variables.GetValueOrDefault<string>(\"csrf_token_from_form\")}\")\" />\r\n                                        \r\n                                        <choose>\r\n                                            <when condition=\"@(context.Variables.GetValueOrDefault<string>(\"consent_action\") == \"allow\")\">\r\n                        <!-- Process consent approval -->\r\n                        <set-variable name=\"response_status_code\" value=\"302\" />\r\n                        <set-variable name=\"response_redirect_location\" value=\"@{\r\n                            string baseUrl = \"{{APIMGatewayURL}}\";\r\n                            \r\n                            // Use already extracted parameters instead of re-parsing form data\r\n                            string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                            string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                            string state = context.Variables.GetValueOrDefault<string>(\"state\", \"\");\r\n                            \r\n                            // URL encode parameters to prevent injection attacks\r\n                            string encodedClientId = System.Net.WebUtility.UrlEncode(clientId);\r\n                            string encodedRedirectUri = System.Net.WebUtility.UrlEncode(redirectUri);\r\n                            // State is already properly encoded from form submission, don't double-encode\r\n                            string encodedState = state;\r\n                            \r\n                            // Add PKCE parameters if they exist\r\n                            string codeChallenge = context.Variables.GetValueOrDefault<string>(\"code_challenge\", \"\");\r\n                            string codeChallengeMethod = context.Variables.GetValueOrDefault<string>(\"code_challenge_method\", \"\");\r\n                            \r\n                            string url = $\"{baseUrl}/authorize?client_id={encodedClientId}&redirect_uri={encodedRedirectUri}&state={encodedState}\";\r\n                            \r\n                            if (!string.IsNullOrEmpty(codeChallenge)) {\r\n                                url += $\"&code_challenge={System.Net.WebUtility.UrlEncode(codeChallenge)}\";\r\n                            }\r\n                            \r\n                            if (!string.IsNullOrEmpty(codeChallengeMethod)) {\r\n                                url += $\"&code_challenge_method={System.Net.WebUtility.UrlEncode(codeChallengeMethod)}\";\r\n                            }\r\n                            \r\n                            return url;\r\n                        }\" />\r\n                          <!-- Calculate approval cookie value -->\r\n                        <set-variable name=\"approval_cookie\" value=\"@{\r\n                            string cookieName = \"MCP_APPROVED_CLIENTS\";\r\n                            \r\n                            // Use already extracted parameters instead of re-parsing form data\r\n                            string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                            string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                            \r\n                            // Create a unique identifier for this client/redirect combination\r\n                            string clientKey = $\"{clientId}:{redirectUri}\";\r\n                            \r\n                            // Check for existing cookie\r\n                            var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\r\n                            JArray approvedClients = new JArray();\r\n                            \r\n                            if (!string.IsNullOrEmpty(cookieHeader)) {\r\n                                // Parse cookies to find our approval cookie\r\n                                string[] cookies = cookieHeader.Split(';');\r\n                                foreach (string cookie in cookies) {\r\n                                    string trimmedCookie = cookie.Trim();\r\n                                    if (trimmedCookie.StartsWith(cookieName + \"=\")) {\r\n                                        try {\r\n                                            // Extract and parse the cookie value\r\n                                            string cookieValue = trimmedCookie.Substring(cookieName.Length + 1);\r\n                                            // Get the payload part (before the first dot if cookie is signed)\r\n                                            string payload = cookieValue.Contains('.') ? \r\n                                                cookieValue.Split('.')[0] : cookieValue;\r\n                                            string decodedValue = System.Text.Encoding.UTF8.GetString(\r\n                                                System.Convert.FromBase64String(payload));\r\n                                            approvedClients = JArray.Parse(decodedValue);\r\n                                        } catch (Exception) {\r\n                                            // If parsing fails, we'll just create a new cookie\r\n                                            approvedClients = new JArray();\r\n                                        }\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                            \r\n                            // Add the current client if not already in the list\r\n                            bool clientExists = false;\r\n                            foreach (var item in approvedClients) {\r\n                                if (item.ToString() == clientKey) {\r\n                                    clientExists = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            \r\n                            if (!clientExists) {\r\n                                approvedClients.Add(clientKey);\r\n                            }\r\n                            \r\n                            // Base64 encode the client list\r\n                            string jsonClients = approvedClients.ToString(Newtonsoft.Json.Formatting.None);\r\n                            string encodedClients = System.Convert.ToBase64String(\r\n                                System.Text.Encoding.UTF8.GetBytes(jsonClients));\r\n                            \r\n                            // Return the full cookie string with appropriate settings\r\n                            return $\"{cookieName}={encodedClients}; Max-Age=31536000; Path=/; Secure; HttpOnly; SameSite=Lax\";\r\n                        }\" />\r\n                        \r\n                        <!-- Set variables for outbound policy awareness -->\r\n                        <set-variable name=\"consent_approved\" value=\"true\" />\r\n                        <set-variable name=\"cookie_name\" value=\"MCP_APPROVED_CLIENTS\" />\r\n                        \r\n                        <!-- Return the response with the cookie already set -->\r\n                        <return-response>\r\n                            <set-status code=\"302\" reason=\"Found\" />\r\n                            <set-header name=\"Location\" exists-action=\"override\">\r\n                                <value>@(context.Variables.GetValueOrDefault<string>(\"response_redirect_location\", \"\"))</value>\r\n                            </set-header>\r\n                            <set-header name=\"Set-Cookie\" exists-action=\"append\">\r\n                                <value>@(context.Variables.GetValueOrDefault<string>(\"approval_cookie\"))</value>\r\n                            </set-header>\r\n                        </return-response>\r\n                    </when>\r\n                    <when condition=\"@(context.Variables.GetValueOrDefault<string>(\"consent_action\") == \"deny\")\">\r\n                        <!-- Process consent denial -->\r\n                        <set-variable name=\"response_status_code\" value=\"403\" />\r\n                        <set-variable name=\"response_content_type\" value=\"text/html\" />\r\n                        <set-variable name=\"response_cache_control\" value=\"no-store, no-cache\" />\r\n                        <set-variable name=\"response_pragma\" value=\"no-cache\" />\r\n                        \r\n                        <!-- Calculate the cookie value right here in inbound before returning response -->\r\n                        <set-variable name=\"denial_cookie\" value=\"@{\r\n                            string cookieName = \"MCP_DENIED_CLIENTS\";\r\n                            \r\n                            // Use already extracted parameters instead of re-parsing form data\r\n                            string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                            string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                            \r\n                            // Create a unique identifier for this client/redirect combination\r\n                            string clientKey = $\"{clientId}:{redirectUri}\";\r\n                            \r\n                            // Check for existing cookie\r\n                            var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\r\n                            JArray deniedClients = new JArray();\r\n                            \r\n                            if (!string.IsNullOrEmpty(cookieHeader)) {\r\n                                // Parse cookies to find our denial cookie\r\n                                string[] cookies = cookieHeader.Split(';');\r\n                                foreach (string cookie in cookies) {\r\n                                    string trimmedCookie = cookie.Trim();\r\n                                    if (trimmedCookie.StartsWith(cookieName + \"=\")) {\r\n                                        try {\r\n                                            // Extract and parse the cookie value\r\n                                            string cookieValue = trimmedCookie.Substring(cookieName.Length + 1);\r\n                                            // Get the payload part (before the first dot if cookie is signed)\r\n                                            string payload = cookieValue.Contains('.') ? \r\n                                                cookieValue.Split('.')[0] : cookieValue;\r\n                                            string decodedValue = System.Text.Encoding.UTF8.GetString(\r\n                                                System.Convert.FromBase64String(payload));\r\n                                            deniedClients = JArray.Parse(decodedValue);\r\n                                        } catch (Exception) {\r\n                                            // If parsing fails, we'll just create a new cookie\r\n                                            deniedClients = new JArray();\r\n                                        }\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                            \r\n                            // Add the current client if not already in the list\r\n                            bool clientExists = false;\r\n                            foreach (var item in deniedClients) {\r\n                                if (item.ToString() == clientKey) {\r\n                                    clientExists = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            \r\n                            if (!clientExists) {\r\n                                deniedClients.Add(clientKey);\r\n                            }\r\n                            \r\n                            // Base64 encode the client list\r\n                            string jsonClients = deniedClients.ToString(Newtonsoft.Json.Formatting.None);\r\n                            string encodedClients = System.Convert.ToBase64String(\r\n                                System.Text.Encoding.UTF8.GetBytes(jsonClients));\r\n                            \r\n                            // Return the full cookie string with appropriate settings\r\n                            return $\"{cookieName}={encodedClients}; Max-Age=31536000; Path=/; Secure; HttpOnly; SameSite=Lax\";\r\n                        }\" />                        <!-- Store the HTML content for the access denied page -->\r\n                        <set-variable name=\"response_body\" value=\"@{\r\n                            string denialTemplate = context.Variables.GetValueOrDefault<string>(\"access_denied_template\");\r\n                            string commonStyles = context.Variables.GetValueOrDefault<string>(\"common_styles\");\r\n                            \r\n                            // Replace placeholders with actual content\r\n                            denialTemplate = denialTemplate.Replace(\"__COMMON_STYLES__\", commonStyles);\r\n                            denialTemplate = denialTemplate.Replace(\"__DENIAL_MESSAGE__\", \r\n                                \"You have denied authorization for this application against the MCP server.\");\r\n                            \r\n                            return denialTemplate;\r\n                        }\" />\r\n                        \r\n                        <!-- Set variables for outbound policy awareness -->\r\n                        <set-variable name=\"consent_denied\" value=\"true\" />\r\n                        <set-variable name=\"cookie_name\" value=\"MCP_DENIED_CLIENTS\" />\r\n                        \r\n                        <!-- Return the response with the cookie already set -->\r\n                        <return-response>\r\n                            <set-status code=\"403\" reason=\"Forbidden\" />\r\n                            <set-header name=\"Content-Type\" exists-action=\"override\">\r\n                                <value>text/html</value>\r\n                            </set-header>\r\n                            <set-header name=\"Cache-Control\" exists-action=\"override\">\r\n                                <value>no-store, no-cache</value>\r\n                            </set-header>\r\n                            <set-header name=\"Pragma\" exists-action=\"override\">\r\n                                <value>no-cache</value>\r\n                            </set-header>\r\n                            <set-header name=\"Set-Cookie\" exists-action=\"append\">\r\n                                <value>@(context.Variables.GetValueOrDefault<string>(\"denial_cookie\"))</value>\r\n                            </set-header>\r\n                            <set-body>@(context.Variables.GetValueOrDefault<string>(\"response_body\", \"\"))</set-body>\r\n                        </return-response>\r\n                    </when>\r\n                    <otherwise>\r\n                        <!-- Invalid consent action - return error -->\r\n                        <return-response>\r\n                            <set-status code=\"403\" reason=\"Forbidden\" />\r\n                            <set-header name=\"Content-Type\" exists-action=\"override\">\r\n                                <value>text/html</value>\r\n                            </set-header>\r\n                            <!-- Explicitly disable any redirects -->\r\n                            <set-header name=\"Cache-Control\" exists-action=\"override\">\r\n                                <value>no-store, no-cache</value>\r\n                            </set-header>\r\n                            <set-header name=\"Pragma\" exists-action=\"override\">\r\n                                <value>no-cache</value>\r\n                            </set-header>\r\n                            <set-body>@{\r\n                                string denialTemplate = context.Variables.GetValueOrDefault<string>(\"access_denied_template\");\r\n                                string commonStyles = context.Variables.GetValueOrDefault<string>(\"common_styles\");\r\n                                string consentAction = context.Variables.GetValueOrDefault<string>(\"consent_action\", \"\");\r\n                                \r\n                                string detailedMessage = $\"Invalid consent action '{consentAction}' received. Expected 'allow' or 'deny'. This may indicate a form tampering attempt or a browser compatibility issue.\";\r\n                                \r\n                                // Replace placeholders with actual content\r\n                                denialTemplate = denialTemplate.Replace(\"__COMMON_STYLES__\", commonStyles);\r\n                                denialTemplate = denialTemplate.Replace(\"__DENIAL_MESSAGE__\", detailedMessage);\r\n                                \r\n                                return denialTemplate;\r\n                            }</set-body>\r\n                        </return-response>\r\n                                            </otherwise>\r\n                                        </choose>\r\n                                    </otherwise>\r\n                                </choose>\r\n                            </otherwise>\r\n                        </choose>\r\n                    </otherwise>\r\n                </choose>\r\n            </when>\r\n            <!-- For GET requests, check for cookies first, then display consent page if no cookie found -->\r\n            <otherwise>\r\n                <choose>\r\n                    <!-- If there's an approval cookie, skip consent and redirect to authorization endpoint -->\r\n                    <when condition=\"@(context.Variables.GetValueOrDefault<bool>(\"has_approval_cookie\"))\">\r\n                        <!-- Set redirect location to authorization endpoint -->\r\n                        <set-variable name=\"response_redirect_location\" value=\"@{\r\n                            string baseUrl = \"{{APIMGatewayURL}}\";\r\n                            string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                            string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                            string state = context.Variables.GetValueOrDefault<string>(\"state\", \"\");\r\n                            \r\n                            // URL encode parameters to prevent injection attacks\r\n                            string encodedClientId = System.Net.WebUtility.UrlEncode(clientId);\r\n                            string encodedRedirectUri = System.Net.WebUtility.UrlEncode(redirectUri);\r\n                            // State is already properly encoded, don't double-encode\r\n                            string encodedState = state;\r\n                            \r\n                            // Add PKCE parameters if they exist\r\n                            string codeChallenge = context.Variables.GetValueOrDefault<string>(\"code_challenge\", \"\");\r\n                            string codeChallengeMethod = context.Variables.GetValueOrDefault<string>(\"code_challenge_method\", \"\");\r\n                            \r\n                            string url = $\"{baseUrl}/authorize?client_id={encodedClientId}&redirect_uri={encodedRedirectUri}&state={encodedState}\";\r\n                            \r\n                            if (!string.IsNullOrEmpty(codeChallenge)) {\r\n                                url += $\"&code_challenge={System.Net.WebUtility.UrlEncode(codeChallenge)}\";\r\n                            }\r\n                            \r\n                            if (!string.IsNullOrEmpty(codeChallengeMethod)) {\r\n                                url += $\"&code_challenge_method={System.Net.WebUtility.UrlEncode(codeChallengeMethod)}\";\r\n                            }\r\n                            \r\n                            return url;\r\n                        }\" />\r\n                        \r\n                        <!-- Redirect to authorization endpoint -->\r\n                        <return-response>\r\n                            <set-status code=\"302\" reason=\"Found\" />\r\n                            <set-header name=\"Location\" exists-action=\"override\">\r\n                                <value>@(context.Variables.GetValueOrDefault<string>(\"response_redirect_location\", \"\"))</value>\r\n                            </set-header>\r\n                        </return-response>\r\n                    </when>\r\n                    \r\n                    <!-- If there's a denial cookie, return access denied page immediately -->\r\n                    <when condition=\"@(context.Variables.GetValueOrDefault<bool>(\"has_denial_cookie\"))\">\r\n                        <return-response>\r\n                            <set-status code=\"403\" reason=\"Forbidden\" />\r\n                            <set-header name=\"Content-Type\" exists-action=\"override\">\r\n                                <value>text/html</value>\r\n                            </set-header>\r\n                            <!-- Explicitly disable any redirects -->\r\n                            <set-header name=\"Cache-Control\" exists-action=\"override\">\r\n                                <value>no-store, no-cache</value>\r\n                            </set-header>\r\n                            <set-header name=\"Pragma\" exists-action=\"override\">\r\n                                <value>no-cache</value>\r\n                            </set-header>\r\n                            <set-body>@{\r\n                                string denialTemplate = context.Variables.GetValueOrDefault<string>(\"access_denied_template\");\r\n                                string commonStyles = context.Variables.GetValueOrDefault<string>(\"common_styles\");\r\n                                \r\n                                // Replace placeholders with actual content\r\n                                denialTemplate = denialTemplate.Replace(\"__COMMON_STYLES__\", commonStyles);\r\n                                denialTemplate = denialTemplate.Replace(\"__DENIAL_MESSAGE__\", \r\n                                    \"You have previously denied access to this application.\");\r\n                                \r\n                                return denialTemplate;\r\n                            }</set-body>\r\n                        </return-response>\r\n                    </when>\r\n                      <!-- If no cookies found, show the consent screen -->\r\n                    <otherwise>\r\n                        <!-- Check if client is registered first -->\r\n                        <choose>\r\n                            <when condition=\"@(!context.Variables.GetValueOrDefault<bool>(\"is_client_registered\"))\">\r\n                                <!-- Client is not registered, show error page -->\r\n                                <return-response>\r\n                                    <set-status code=\"403\" reason=\"Forbidden\" />\r\n                                    <set-header name=\"Content-Type\" exists-action=\"override\">\r\n                                        <value>text/html</value>\r\n                                    </set-header>\r\n                                    <set-header name=\"Cache-Control\" exists-action=\"override\">\r\n                                        <value>no-store, no-cache</value>\r\n                                    </set-header>\r\n                                    <set-header name=\"Pragma\" exists-action=\"override\">\r\n                                        <value>no-cache</value>\r\n                                    </set-header>\r\n                                    <set-body>@{\r\n                                        string template = context.Variables.GetValueOrDefault<string>(\"client_not_found_template\");\r\n                                        string commonStyles = context.Variables.GetValueOrDefault<string>(\"common_styles\");\r\n                                        string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                                        string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                                        \r\n                                        // Replace placeholders with HTML-encoded content to prevent XSS\r\n                                        template = template.Replace(\"__COMMON_STYLES__\", commonStyles);\r\n                                        template = template.Replace(\"__CLIENT_ID_DISPLAY__\", System.Net.WebUtility.HtmlEncode(clientId));\r\n                                        template = template.Replace(\"__REDIRECT_URI__\", System.Net.WebUtility.HtmlEncode(redirectUri));\r\n                                        \r\n                                        return template;\r\n                                    }</set-body>\r\n                                </return-response>\r\n                            </when>\r\n                            <otherwise>                                <!-- Client is registered, get client name from the cache -->\r\n                                <!-- Build consent page using the standardized template -->\r\n                                <set-variable name=\"consent_page\" value=\"@{\r\n                                    string template = context.Variables.GetValueOrDefault<string>(\"consent_page_template\");\r\n                                    string commonStyles = context.Variables.GetValueOrDefault<string>(\"common_styles\");\r\n                                    \r\n                                    // Use the service URL from APIM configuration\r\n                                    string basePath = \"{{APIMGatewayURL}}\";\r\n                                    \r\n                                    string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                                    string clientName = context.Variables.GetValueOrDefault<string>(\"client_name\", \"Unknown Application\");\r\n                                    string clientUri = context.Variables.GetValueOrDefault<string>(\"client_uri\", \"N/A\");\r\n                                    string oauthScopes = context.Variables.GetValueOrDefault<string>(\"oauth_scopes\", \"\");\r\n                                    \r\n                                    // Get the normalized (human-readable) redirect URI for display\r\n                                    string normalizedRedirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                                    \r\n                                    // Use the normalized redirect URI for form submission to ensure consistency\r\n                                    string formRedirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                                    string htmlEncodedFormUri = System.Net.WebUtility.HtmlEncode(formRedirectUri);\r\n                                    \r\n                                    string state = context.Variables.GetValueOrDefault<string>(\"state\", \"\");\r\n                                    string csrfToken = context.Variables.GetValueOrDefault<string>(\"csrf_token\", \"\");\r\n                                    \r\n                                    // Create a temporary placeholder for the form fields\r\n                                    string FORM_FIELD_PLACEHOLDER = \"___ENCODED_REDIRECT_URI___\";\r\n                                    \r\n                                    // Replace the styles first\r\n                                    template = template.Replace(\"__COMMON_STYLES__\", commonStyles);\r\n                                    \r\n                                    // First, create a temporary placeholder for the form fields\r\n                                    template = template.Replace(\"value='__REDIRECT_URI__'\", \"value='\" + FORM_FIELD_PLACEHOLDER + \"'\");\r\n                                      \r\n                                    // Replace template placeholders with properly encoded values\r\n                                    template = template.Replace(\"__CLIENT_NAME__\", System.Net.WebUtility.HtmlEncode(clientName));\r\n                                    template = template.Replace(\"__CLIENT_URI__\", System.Net.WebUtility.HtmlEncode(clientUri));\r\n                                    // For display purposes, use HtmlEncode for safety\r\n                                    template = template.Replace(\"__CLIENT_ID_DISPLAY__\", System.Net.WebUtility.HtmlEncode(clientId));\r\n                                    template = template.Replace(\"__REDIRECT_URI__\", System.Net.WebUtility.HtmlEncode(normalizedRedirectUri));\r\n                                    // For form field values, use HtmlEncode for XSS protection\r\n                                    template = template.Replace(\"__CLIENT_ID_FORM__\", System.Net.WebUtility.HtmlEncode(clientId));\r\n                                    // State needs to be URL-decoded first since it comes URL-encoded from query, then HTML-encoded for form safety\r\n                                    string decodedState = System.Net.WebUtility.UrlDecode(state);\r\n                                    template = template.Replace(\"__STATE__\", System.Net.WebUtility.HtmlEncode(decodedState));\r\n                                    template = template.Replace(\"__CODE_CHALLENGE__\", System.Net.WebUtility.HtmlEncode(context.Variables.GetValueOrDefault<string>(\"code_challenge\", \"\")));\r\n                                    template = template.Replace(\"__CODE_CHALLENGE_METHOD__\", System.Net.WebUtility.HtmlEncode(context.Variables.GetValueOrDefault<string>(\"code_challenge_method\", \"\")));\r\n                                    template = template.Replace(\"__CSRF_TOKEN__\", System.Net.WebUtility.HtmlEncode(csrfToken));\r\n                                    template = template.Replace(\"__CONSENT_ACTION_URL__\", basePath + \"/consent\");                                    \r\n                                    // Handle space-separated OAuth scopes and create individual list items with HTML encoding\r\n                                    string[] scopeArray = oauthScopes.Split(new char[] {' '}, StringSplitOptions.RemoveEmptyEntries);\r\n                                    StringBuilder scopeList = new StringBuilder();\r\n                                    \r\n                                    foreach (string scope in scopeArray) {\r\n                                        scopeList.AppendLine($\"<li><code>{System.Net.WebUtility.HtmlEncode(scope)}</code></li>\");\r\n                                    }\r\n                                    \r\n                                    template = template.Replace(\"__OAUTH_SCOPES__\", scopeList.ToString());\r\n                                    \r\n                                // Replace form field placeholder with encoded URI\r\n                                template = template.Replace(FORM_FIELD_PLACEHOLDER, htmlEncodedFormUri);                                    return template;\r\n                                }\" />\r\n                                \r\n                                <!-- Return consent page -->\r\n                                <return-response>\r\n                                    <set-status code=\"200\" reason=\"OK\" />\r\n                                    <set-header name=\"Content-Type\" exists-action=\"override\">\r\n                                        <value>text/html</value>\r\n                                    </set-header>\r\n                                    <!-- Security headers -->\r\n                                    <set-header name=\"X-Frame-Options\" exists-action=\"override\">\r\n                                        <value>DENY</value>\r\n                                    </set-header>\r\n                                    <set-header name=\"X-Content-Type-Options\" exists-action=\"override\">\r\n                                        <value>nosniff</value>\r\n                                    </set-header>\r\n                                    <set-header name=\"X-XSS-Protection\" exists-action=\"override\">\r\n                                        <value>1; mode=block</value>\r\n                                    </set-header>\r\n                                    <set-header name=\"Referrer-Policy\" exists-action=\"override\">\r\n                                        <value>strict-origin-when-cross-origin</value>\r\n                                    </set-header>\r\n                                    <set-header name=\"Content-Security-Policy\" exists-action=\"override\">\r\n                                        <value>default-src 'self'; style-src 'unsafe-inline'; script-src 'none'; object-src 'none'; base-uri 'self'; form-action 'self' https:</value>\r\n                                    </set-header>\r\n                                    <set-header name=\"Cache-Control\" exists-action=\"override\">\r\n                                        <value>no-store, no-cache, must-revalidate</value>\r\n                                    </set-header>\r\n                                    <set-header name=\"Pragma\" exists-action=\"override\">\r\n                                        <value>no-cache</value>\r\n                                    </set-header>\r\n                                    <set-body>@{\r\n                                        return context.Variables.GetValueOrDefault<string>(\"consent_page\", \"\");\r\n                                    }</set-body>\r\n                                </return-response>\r\n                            </otherwise>\r\n                        </choose>\r\n                    </otherwise>\r\n                </choose>\r\n            </otherwise>\r\n        </choose>\r\n    </inbound>\r\n    <backend>\r\n        <base />\r\n    </backend>\r\n    <outbound>\r\n        <base />\r\n        <!-- Debug trace for variable verification -->\r\n        <trace source=\"outbound-debug\" severity=\"information\">\r\n            <message>@{\r\n                return $\"Outbound policy: consent_approved={context.Variables.GetValueOrDefault<bool>(\"consent_approved\")}, consent_denied={context.Variables.GetValueOrDefault<bool>(\"consent_denied\")}, cookie_name={context.Variables.GetValueOrDefault<string>(\"cookie_name\")}\";\r\n            }</message>\r\n        </trace>\r\n        \r\n        <!-- Set cookies based on consent decision -->\r\n        <choose>\r\n            <!-- Handle approval cookie -->\r\n            <when condition=\"@(context.Variables.GetValueOrDefault<bool>(\"consent_approved\"))\">\r\n                <set-header name=\"Set-Cookie\" exists-action=\"append\">\r\n                    <value>@{\r\n                        string cookieName = context.Variables.GetValueOrDefault<string>(\"cookie_name\", \"MCP_APPROVED_CLIENTS\");\r\n                        string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                        // Use normalized redirect URI for cookies\r\n                        string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                        \r\n                        // Create unique client/redirect identifier\r\n                        string clientKey = $\"{clientId}:{redirectUri}\";\r\n                        \r\n                        // Check for existing cookie\r\n                        var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\r\n                        JArray approvedClients = new JArray();\r\n                        \r\n                        if (!string.IsNullOrEmpty(cookieHeader)) {\r\n                            // Parse cookies to find approval cookie\r\n                            string[] cookies = cookieHeader.Split(';');\r\n                            foreach (string cookie in cookies) {\r\n                                string trimmedCookie = cookie.Trim();\r\n                                if (trimmedCookie.StartsWith(cookieName + \"=\")) {\r\n                                    try {\r\n                                        // Extract and parse cookie value\r\n                                        string cookieValue = trimmedCookie.Substring(cookieName.Length + 1);\r\n                                        // Get payload part (before first dot if signed)\r\n                                        string payload = cookieValue.Contains('.') ? \r\n                                            cookieValue.Split('.')[0] : cookieValue;\r\n                                        string decodedValue = System.Text.Encoding.UTF8.GetString(\r\n                                            System.Convert.FromBase64String(payload));\r\n                                        approvedClients = JArray.Parse(decodedValue);\r\n                                    } catch (Exception) {\r\n                                        // If parsing fails, create new cookie\r\n                                        approvedClients = new JArray();\r\n                                    }\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                        \r\n                        // Add the current client if not already in the list\r\n                        bool clientExists = false;\r\n                        foreach (var item in approvedClients) {\r\n                            if (item.ToString() == clientKey) {\r\n                                clientExists = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        \r\n                        if (!clientExists) {\r\n                            approvedClients.Add(clientKey);\r\n                        }\r\n                        \r\n                        // Base64 encode the client list\r\n                        string jsonClients = approvedClients.ToString(Newtonsoft.Json.Formatting.None);\r\n                        string encodedClients = System.Convert.ToBase64String(\r\n                            System.Text.Encoding.UTF8.GetBytes(jsonClients));\r\n                        \r\n                        // Return the cookie with appropriate settings\r\n                        return $\"{cookieName}={encodedClients}; Max-Age=31536000; Path=/; Secure; HttpOnly; SameSite=Lax\";\r\n                    }</value>\r\n                </set-header>\r\n                \r\n                <!-- Set response status and redirect for approval -->\r\n                <set-status code=\"@(context.Variables.GetValueOrDefault<int>(\"response_status_code\", 302))\" reason=\"Found\" />\r\n                <set-header name=\"Location\" exists-action=\"override\">\r\n                    <value>@(context.Variables.GetValueOrDefault<string>(\"response_redirect_location\", \"\"))</value>\r\n                </set-header>\r\n            </when>\r\n            \r\n            <!-- Handle denial cookie -->\r\n            <when condition=\"@(context.Variables.GetValueOrDefault<bool>(\"consent_denied\"))\">\r\n                <set-header name=\"Set-Cookie\" exists-action=\"append\">\r\n                    <value>@{\r\n                        string cookieName = context.Variables.GetValueOrDefault<string>(\"cookie_name\", \"MCP_DENIED_CLIENTS\");\r\n                        string clientId = context.Variables.GetValueOrDefault<string>(\"client_id\", \"\");\r\n                        // Use normalized redirect URI for cookies\r\n                        string redirectUri = context.Variables.GetValueOrDefault<string>(\"normalized_redirect_uri\", \"\");\r\n                        \r\n                        // Create unique client/redirect identifier\r\n                        string clientKey = $\"{clientId}:{redirectUri}\";\r\n                        \r\n                        // Check for existing cookie\r\n                        var cookieHeader = context.Request.Headers.GetValueOrDefault(\"Cookie\", \"\");\r\n                        JArray deniedClients = new JArray();\r\n                        \r\n                        if (!string.IsNullOrEmpty(cookieHeader)) {\r\n                            // Parse cookies to find denial cookie\r\n                            string[] cookies = cookieHeader.Split(';');\r\n                            foreach (string cookie in cookies) {\r\n                                string trimmedCookie = cookie.Trim();\r\n                                if (trimmedCookie.StartsWith(cookieName + \"=\")) {\r\n                                    try {\r\n                                        // Extract and parse cookie value\r\n                                        string cookieValue = trimmedCookie.Substring(cookieName.Length + 1);\r\n                                        // Get payload part (before first dot if signed)\r\n                                        string payload = cookieValue.Contains('.') ? \r\n                                            cookieValue.Split('.')[0] : cookieValue;\r\n                                        string decodedValue = System.Text.Encoding.UTF8.GetString(\r\n                                            System.Convert.FromBase64String(payload));\r\n                                        deniedClients = JArray.Parse(decodedValue);\r\n                                    } catch (Exception) {\r\n                                        // If parsing fails, create new cookie\r\n                                        deniedClients = new JArray();\r\n                                    }\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                        \r\n                        // Add client if not already in list\r\n                        bool clientExists = false;\r\n                        foreach (var item in deniedClients) {\r\n                            if (item.ToString() == clientKey) {\r\n                                clientExists = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        \r\n                        if (!clientExists) {\r\n                            deniedClients.Add(clientKey);\r\n                        }\r\n                        \r\n                        // Base64 encode client list\r\n                        string jsonClients = deniedClients.ToString(Newtonsoft.Json.Formatting.None);\r\n                        string encodedClients = System.Convert.ToBase64String(\r\n                            System.Text.Encoding.UTF8.GetBytes(jsonClients));\r\n                        \r\n                        // Return cookie with security settings\r\n                        return $\"{cookieName}={encodedClients}; Max-Age=31536000; Path=/; Secure; HttpOnly; SameSite=Lax\";\r\n                    }</value>\r\n                </set-header>\r\n            </when>\r\n        </choose>\r\n    </outbound>\r\n    <on-error>\r\n        <base />\r\n    </on-error>\r\n</policies>\r\n"
          },
          "resources": {
            "apimService": {
              "existing": true,
              "type": "Microsoft.ApiManagement/service",
              "apiVersion": "2021-08-01",
              "name": "[parameters('apimServiceName')]"
            },
            "encryptionKeyNamedValue": {
              "type": "Microsoft.ApiManagement/service/namedValues",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', parameters('apimServiceName'), 'EncryptionKey')]",
              "properties": {
                "displayName": "EncryptionKey",
                "value": "[base64(uniqueString(resourceGroup().id, parameters('apimServiceName'), parameters('location'), 'encryption-key'))]",
                "secret": true
              },
              "dependsOn": [
                "apimService"
              ]
            },
            "encryptionIVNamedValue": {
              "type": "Microsoft.ApiManagement/service/namedValues",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', parameters('apimServiceName'), 'EncryptionIV')]",
              "properties": {
                "displayName": "EncryptionIV",
                "value": "[base64(uniqueString(resourceGroup().id, parameters('apimServiceName'), parameters('location'), 'encryption-iv'))]",
                "secret": true
              },
              "dependsOn": [
                "apimService"
              ]
            },
            "EntraIDTenantIdNamedValue": {
              "type": "Microsoft.ApiManagement/service/namedValues",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', parameters('apimServiceName'), 'EntraIDTenantId')]",
              "properties": {
                "displayName": "EntraIDTenantId",
                "value": "[reference('entraApp').outputs.entraAppTenantId.value]",
                "secret": false
              },
              "dependsOn": [
                "apimService",
                "entraApp"
              ]
            },
            "EntraIDClientIdNamedValue": {
              "type": "Microsoft.ApiManagement/service/namedValues",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', parameters('apimServiceName'), 'EntraIDClientId')]",
              "properties": {
                "displayName": "EntraIDClientId",
                "value": "[reference('entraApp').outputs.entraAppId.value]",
                "secret": false
              },
              "dependsOn": [
                "apimService",
                "entraApp"
              ]
            },
            "EntraIdFicClientIdNamedValue": {
              "type": "Microsoft.ApiManagement/service/namedValues",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', parameters('apimServiceName'), 'EntraIDFicClientId')]",
              "properties": {
                "displayName": "EntraIdFicClientId",
                "value": "[parameters('entraAppUserAssignedIdentityClientId')]",
                "secret": false
              },
              "dependsOn": [
                "apimService"
              ]
            },
            "OAuthCallbackUriNamedValue": {
              "type": "Microsoft.ApiManagement/service/namedValues",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', parameters('apimServiceName'), 'OAuthCallbackUri')]",
              "properties": {
                "displayName": "OAuthCallbackUri",
                "value": "[format('{0}/oauth-callback', reference('apimService').gatewayUrl)]",
                "secret": false
              },
              "dependsOn": [
                "apimService"
              ]
            },
            "OAuthScopesNamedValue": {
              "type": "Microsoft.ApiManagement/service/namedValues",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', parameters('apimServiceName'), 'OAuthScopes')]",
              "properties": {
                "displayName": "OAuthScopes",
                "value": "[parameters('oauthScopes')]",
                "secret": false
              },
              "dependsOn": [
                "apimService"
              ]
            },
            "McpClientIdNamedValue": {
              "type": "Microsoft.ApiManagement/service/namedValues",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', parameters('apimServiceName'), 'McpClientId')]",
              "properties": {
                "displayName": "McpClientId",
                "value": "[reference('entraApp').outputs.entraAppId.value]",
                "secret": false
              },
              "dependsOn": [
                "apimService",
                "entraApp"
              ]
            },
            "APIMGatewayURLNamedValue": {
              "type": "Microsoft.ApiManagement/service/namedValues",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', parameters('apimServiceName'), 'APIMGatewayURL')]",
              "properties": {
                "displayName": "APIMGatewayURL",
                "value": "[reference('apimService').gatewayUrl]",
                "secret": false
              },
              "dependsOn": [
                "apimService"
              ]
            },
            "MCPServerNamedValue": {
              "type": "Microsoft.ApiManagement/service/namedValues",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', parameters('apimServiceName'), 'MCPServerName')]",
              "properties": {
                "displayName": "MCPServerName",
                "value": "[parameters('mcpServerName')]",
                "secret": false
              },
              "dependsOn": [
                "apimService"
              ]
            },
            "oauthApi": {
              "type": "Microsoft.ApiManagement/service/apis",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', parameters('apimServiceName'), 'oauth')]",
              "properties": {
                "displayName": "OAuth",
                "description": "OAuth 2.0 Authentication API",
                "subscriptionRequired": false,
                "path": "",
                "protocols": [
                  "https"
                ],
                "serviceUrl": "[format('{0}{1}/oauth2/v2.0', environment().authentication.loginEndpoint, reference('entraApp').outputs.entraAppTenantId.value)]"
              },
              "dependsOn": [
                "apimService",
                "entraApp"
              ]
            },
            "oauthAuthorizeOperation": {
              "type": "Microsoft.ApiManagement/service/apis/operations",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}', parameters('apimServiceName'), 'oauth', 'authorize')]",
              "properties": {
                "displayName": "Authorize",
                "method": "GET",
                "urlTemplate": "/authorize",
                "description": "OAuth 2.0 authorization endpoint"
              },
              "dependsOn": [
                "oauthApi"
              ]
            },
            "oauthAuthorizePolicy": {
              "type": "Microsoft.ApiManagement/service/apis/operations/policies",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}/{3}', parameters('apimServiceName'), 'oauth', 'authorize', 'policy')]",
              "properties": {
                "format": "rawxml",
                "value": "[variables('$fxv#0')]"
              },
              "dependsOn": [
                "oauthAuthorizeOperation"
              ]
            },
            "oauthTokenOperation": {
              "type": "Microsoft.ApiManagement/service/apis/operations",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}', parameters('apimServiceName'), 'oauth', 'token')]",
              "properties": {
                "displayName": "Token",
                "method": "POST",
                "urlTemplate": "/token",
                "description": "OAuth 2.0 token endpoint"
              },
              "dependsOn": [
                "oauthApi"
              ]
            },
            "oauthTokenPolicy": {
              "type": "Microsoft.ApiManagement/service/apis/operations/policies",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}/{3}', parameters('apimServiceName'), 'oauth', 'token', 'policy')]",
              "properties": {
                "format": "rawxml",
                "value": "[variables('$fxv#1')]"
              },
              "dependsOn": [
                "oauthTokenOperation"
              ]
            },
            "oauthCallbackOperation": {
              "type": "Microsoft.ApiManagement/service/apis/operations",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}', parameters('apimServiceName'), 'oauth', 'oauth-callback')]",
              "properties": {
                "displayName": "OAuth Callback",
                "method": "GET",
                "urlTemplate": "/oauth-callback",
                "description": "OAuth 2.0 callback endpoint to handle authorization code flow"
              },
              "dependsOn": [
                "oauthApi"
              ]
            },
            "oauthCallbackPolicy": {
              "type": "Microsoft.ApiManagement/service/apis/operations/policies",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}/{3}', parameters('apimServiceName'), 'oauth', 'oauth-callback', 'policy')]",
              "properties": {
                "format": "rawxml",
                "value": "[variables('$fxv#2')]"
              },
              "dependsOn": [
                "encryptionIVNamedValue",
                "encryptionKeyNamedValue",
                "oauthCallbackOperation"
              ]
            },
            "oauthRegisterOperation": {
              "type": "Microsoft.ApiManagement/service/apis/operations",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}', parameters('apimServiceName'), 'oauth', 'register')]",
              "properties": {
                "displayName": "Register",
                "method": "POST",
                "urlTemplate": "/register",
                "description": "OAuth 2.0 client registration endpoint"
              },
              "dependsOn": [
                "oauthApi"
              ]
            },
            "oauthRegisterPolicy": {
              "type": "Microsoft.ApiManagement/service/apis/operations/policies",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}/{3}', parameters('apimServiceName'), 'oauth', 'register', 'policy')]",
              "properties": {
                "format": "rawxml",
                "value": "[variables('$fxv#3')]"
              },
              "dependsOn": [
                "oauthRegisterOperation"
              ]
            },
            "oauthRegisterOptionsOperation": {
              "type": "Microsoft.ApiManagement/service/apis/operations",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}', parameters('apimServiceName'), 'oauth', 'register-options')]",
              "properties": {
                "displayName": "Register Options",
                "method": "OPTIONS",
                "urlTemplate": "/register",
                "description": "CORS preflight request handler for register endpoint"
              },
              "dependsOn": [
                "oauthApi"
              ]
            },
            "oauthRegisterOptionsPolicy": {
              "type": "Microsoft.ApiManagement/service/apis/operations/policies",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}/{3}', parameters('apimServiceName'), 'oauth', 'register-options', 'policy')]",
              "properties": {
                "format": "rawxml",
                "value": "[variables('$fxv#4')]"
              },
              "dependsOn": [
                "oauthRegisterOptionsOperation"
              ]
            },
            "oauthMetadataOptionsOperation": {
              "type": "Microsoft.ApiManagement/service/apis/operations",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}', parameters('apimServiceName'), 'oauth', 'oauthmetadata-options')]",
              "properties": {
                "displayName": "OAuth Metadata Options",
                "method": "OPTIONS",
                "urlTemplate": "/.well-known/oauth-authorization-server",
                "description": "CORS preflight request handler for OAuth metadata endpoint"
              },
              "dependsOn": [
                "oauthApi"
              ]
            },
            "oauthMetadataOptionsPolicy": {
              "type": "Microsoft.ApiManagement/service/apis/operations/policies",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}/{3}', parameters('apimServiceName'), 'oauth', 'oauthmetadata-options', 'policy')]",
              "properties": {
                "format": "rawxml",
                "value": "[variables('$fxv#5')]"
              },
              "dependsOn": [
                "oauthMetadataOptionsOperation"
              ]
            },
            "oauthMetadataGetOperation": {
              "type": "Microsoft.ApiManagement/service/apis/operations",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}', parameters('apimServiceName'), 'oauth', 'oauthmetadata-get')]",
              "properties": {
                "displayName": "OAuth Metadata Get",
                "method": "GET",
                "urlTemplate": "/.well-known/oauth-authorization-server",
                "description": "OAuth 2.0 metadata endpoint"
              },
              "dependsOn": [
                "oauthApi"
              ]
            },
            "oauthMetadataGetPolicy": {
              "type": "Microsoft.ApiManagement/service/apis/operations/policies",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}/{3}', parameters('apimServiceName'), 'oauth', 'oauthmetadata-get', 'policy')]",
              "properties": {
                "format": "rawxml",
                "value": "[variables('$fxv#6')]"
              },
              "dependsOn": [
                "oauthMetadataGetOperation"
              ]
            },
            "oauthConsentGetOperation": {
              "type": "Microsoft.ApiManagement/service/apis/operations",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}', parameters('apimServiceName'), 'oauth', 'consent-get')]",
              "properties": {
                "displayName": "Consent Page",
                "method": "GET",
                "urlTemplate": "/consent",
                "description": "Client consent page endpoint"
              },
              "dependsOn": [
                "oauthApi"
              ]
            },
            "oauthConsentGetPolicy": {
              "type": "Microsoft.ApiManagement/service/apis/operations/policies",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}/{3}', parameters('apimServiceName'), 'oauth', 'consent-get', 'policy')]",
              "properties": {
                "format": "rawxml",
                "value": "[variables('$fxv#7')]"
              },
              "dependsOn": [
                "oauthConsentGetOperation"
              ]
            },
            "oauthConsentPostOperation": {
              "type": "Microsoft.ApiManagement/service/apis/operations",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}', parameters('apimServiceName'), 'oauth', 'consent-post')]",
              "properties": {
                "displayName": "Consent Submission",
                "method": "POST",
                "urlTemplate": "/consent",
                "description": "Client consent submission endpoint"
              },
              "dependsOn": [
                "oauthApi"
              ]
            },
            "oauthConsentPostPolicy": {
              "type": "Microsoft.ApiManagement/service/apis/operations/policies",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}/{2}/{3}', parameters('apimServiceName'), 'oauth', 'consent-post', 'policy')]",
              "properties": {
                "format": "rawxml",
                "value": "[variables('$fxv#8')]"
              },
              "dependsOn": [
                "oauthConsentPostOperation"
              ]
            },
            "entraApp": {
              "type": "Microsoft.Resources/deployments",
              "apiVersion": "2022-09-01",
              "name": "entraApp",
              "properties": {
                "expressionEvaluationOptions": {
                  "scope": "inner"
                },
                "mode": "Incremental",
                "parameters": {
                  "entraAppUniqueName": {
                    "value": "[parameters('entraAppUniqueName')]"
                  },
                  "entraAppDisplayName": {
                    "value": "[parameters('entraAppDisplayName')]"
                  },
                  "apimOauthCallback": {
                    "value": "[format('{0}/oauth-callback', reference('apimService').gatewayUrl)]"
                  },
                  "userAssignedIdentityPrincipleId": {
                    "value": "[parameters('entraAppUserAssignedIdentityPrincipleId')]"
                  },
                  "existingEntraAppId": {
                    "value": "[parameters('existingEntraAppId')]"
                  }
                },
                "template": {
                  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
                  "languageVersion": "2.1-experimental",
                  "contentVersion": "1.0.0.0",
                  "metadata": {
                    "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
                    "_EXPERIMENTAL_FEATURES_ENABLED": [
                      "Extensibility"
                    ],
                    "_generator": {
                      "name": "bicep",
                      "version": "0.28.1.47646",
                      "templateHash": "12013192534308673147"
                    }
                  },
                  "parameters": {
                    "entraAppUniqueName": {
                      "type": "string",
                      "metadata": {
                        "description": "The name of the Entra application"
                      }
                    },
                    "entraAppDisplayName": {
                      "type": "string",
                      "metadata": {
                        "description": "The display name of the Entra application"
                      }
                    },
                    "tenantId": {
                      "type": "string",
                      "defaultValue": "[tenant().tenantId]",
                      "metadata": {
                        "description": "Tenant ID where the application is registered"
                      }
                    },
                    "apimOauthCallback": {
                      "type": "string",
                      "metadata": {
                        "description": "The OAuth callback URL for the API Management service"
                      }
                    },
                    "userAssignedIdentityPrincipleId": {
                      "type": "string",
                      "metadata": {
                        "description": "The principle id of the user-assigned managed identity"
                      }
                    },
                    "existingEntraAppId": {
                      "type": "string",
                      "defaultValue": "",
                      "metadata": {
                        "description": "The pre-created Entra application client ID - must be provided for now"
                      }
                    }
                  },
                  "resources": {},
                  "outputs": {
                    "entraAppId": {
                      "type": "string",
                      "value": "[if(not(equals(parameters('existingEntraAppId'), '')), parameters('existingEntraAppId'), '6441e54f-8149-487b-aac4-3a55a049a362')]"
                    },
                    "entraAppTenantId": {
                      "type": "string",
                      "value": "[parameters('tenantId')]"
                    }
                  }
                }
              },
              "dependsOn": [
                "apimService"
              ]
            }
          },
          "outputs": {
            "apiId": {
              "type": "string",
              "value": "[resourceId('Microsoft.ApiManagement/service/apis', parameters('apimServiceName'), 'oauth')]"
            }
          }
        }
      },
      "dependsOn": [
        "apimService",
        "rg"
      ]
    },
    "mcpApiModule": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "mcpApiModule",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "apimServiceName": {
            "value": "[variables('apiManagementName')]"
          },
          "mcpServerBackendUrl": {
            "value": "[format('http://{0}/runtime/webhooks/mcp', reference('mcpPublicIp').outputs.publicIpAddress.value)]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "15046467526686708223"
            }
          },
          "parameters": {
            "apimServiceName": {
              "type": "string",
              "metadata": {
                "description": "The name of the API Management service"
              }
            },
            "mcpServerBackendUrl": {
              "type": "string",
              "metadata": {
                "description": "The backend URL for the MCP server (AKS service endpoint)"
              }
            }
          },
          "variables": {
            "$fxv#0": "<!--\r\n    SIMPLIFIED MCP API POLICY - FOR DEBUGGING\r\n    This is a simplified version to test if the basic MCP infrastructure works\r\n-->\r\n<policies>\r\n    <inbound>\r\n        <base />\r\n        <!-- Check for Authorization header -->\r\n        <check-header name=\"Authorization\" failed-check-httpcode=\"401\" failed-check-error-message=\"Not authorized\" ignore-case=\"false\" />\r\n        \r\n        <!-- For testing, just validate that we have a Bearer token that starts with \"mcp_access_token\" -->\r\n        <set-variable name=\"authHeader\" value=\"@(context.Request.Headers.GetValueOrDefault(\"Authorization\", \"\"))\" />\r\n        <set-variable name=\"bearerToken\" value=\"@{\r\n            string authHeader = (string)context.Variables.GetValueOrDefault(\"authHeader\", \"\");\r\n            return authHeader.StartsWith(\"Bearer \") ? authHeader.Substring(7) : \"\";\r\n        }\" />\r\n        \r\n        <choose>\r\n            <when condition=\"@(!((string)context.Variables.GetValueOrDefault(\"bearerToken\", \"\")).StartsWith(\"mcp_access_token\"))\">\r\n                <return-response>\r\n                    <set-status code=\"401\" reason=\"Unauthorized\" />\r\n                    <set-header name=\"WWW-Authenticate\" exists-action=\"override\">\r\n                        <value>Bearer error=\"invalid_token\", error_description=\"Token must start with mcp_access_token\"</value>\r\n                    </set-header>\r\n                    <set-body>{\"error\": \"invalid_token\", \"message\": \"Invalid or expired access token\"}</set-body>\r\n                </return-response>\r\n            </when>\r\n        </choose>\r\n        \r\n    </inbound>\r\n    <backend>\r\n        <base />\r\n    </backend>\r\n    <outbound>\r\n        <base />\r\n    </outbound>\r\n    <on-error>\r\n        <base />\r\n    </on-error>\r\n</policies>"
          },
          "resources": {
            "apimService": {
              "existing": true,
              "type": "Microsoft.ApiManagement/service",
              "apiVersion": "2023-05-01-preview",
              "name": "[parameters('apimServiceName')]"
            },
            "mcpApi": {
              "type": "Microsoft.ApiManagement/service/apis",
              "apiVersion": "2023-05-01-preview",
              "name": "[format('{0}/{1}', parameters('apimServiceName'), 'mcp')]",
              "properties": {
                "displayName": "MCP API",
                "description": "Model Context Protocol API endpoints - powered by AKS",
                "subscriptionRequired": false,
                "path": "mcp",
                "protocols": [
                  "https"
                ],
                "serviceUrl": "[parameters('mcpServerBackendUrl')]"
              },
              "dependsOn": [
                "apimService"
              ]
            },
            "mcpApiPolicy": {
              "type": "Microsoft.ApiManagement/service/apis/policies",
              "apiVersion": "2023-05-01-preview",
              "name": "[format('{0}/{1}/{2}', parameters('apimServiceName'), 'mcp', 'policy')]",
              "properties": {
                "format": "rawxml",
                "value": "[variables('$fxv#0')]"
              },
              "dependsOn": [
                "mcpApi"
              ]
            },
            "mcpSseOperation": {
              "type": "Microsoft.ApiManagement/service/apis/operations",
              "apiVersion": "2023-05-01-preview",
              "name": "[format('{0}/{1}/{2}', parameters('apimServiceName'), 'mcp', 'mcp-sse')]",
              "properties": {
                "displayName": "MCP SSE Endpoint",
                "method": "GET",
                "urlTemplate": "/sse",
                "description": "Server-Sent Events endpoint for MCP Server"
              },
              "dependsOn": [
                "mcpApi"
              ]
            },
            "mcpMessageOperation": {
              "type": "Microsoft.ApiManagement/service/apis/operations",
              "apiVersion": "2023-05-01-preview",
              "name": "[format('{0}/{1}/{2}', parameters('apimServiceName'), 'mcp', 'mcp-message')]",
              "properties": {
                "displayName": "MCP Message Endpoint",
                "method": "POST",
                "urlTemplate": "/message",
                "description": "Message endpoint for MCP Server"
              },
              "dependsOn": [
                "mcpApi"
              ]
            }
          },
          "outputs": {
            "apiId": {
              "type": "string",
              "value": "[resourceId('Microsoft.ApiManagement/service/apis', parameters('apimServiceName'), 'mcp')]"
            }
          }
        }
      },
      "dependsOn": [
        "aksCluster",
        "apimService",
        "mcpPublicIp",
        "oauthAPIModule",
        "rg"
      ]
    },
    "aksUserAssignedIdentity": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "aksUserAssignedIdentity",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "identityName": "[if(not(empty(parameters('apiUserAssignedIdentityName'))), createObject('value', parameters('apiUserAssignedIdentityName')), createObject('value', format('{0}aks-{1}', variables('abbrs').managedIdentityUserAssignedIdentities, variables('resourceToken'))))]"
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "10442426509339802394"
            }
          },
          "parameters": {
            "identityName": {
              "type": "string"
            },
            "location": {
              "type": "string"
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            }
          },
          "resources": {
            "userAssignedIdentity": {
              "type": "Microsoft.ManagedIdentity/userAssignedIdentities",
              "apiVersion": "2023-07-31-preview",
              "name": "[parameters('identityName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]"
            }
          },
          "outputs": {
            "identityId": {
              "type": "string",
              "value": "[resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', parameters('identityName'))]"
            },
            "identityName": {
              "type": "string",
              "value": "[parameters('identityName')]"
            },
            "identityPrincipalId": {
              "type": "string",
              "value": "[reference('userAssignedIdentity').principalId]"
            },
            "identityClientId": {
              "type": "string",
              "value": "[reference('userAssignedIdentity').clientId]"
            }
          }
        }
      },
      "dependsOn": [
        "rg"
      ]
    },
    "mcpUserAssignedIdentity": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "mcpUserAssignedIdentity",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "identityName": {
            "value": "[format('{0}mcp-{1}', variables('abbrs').managedIdentityUserAssignedIdentities, variables('resourceToken'))]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "10442426509339802394"
            }
          },
          "parameters": {
            "identityName": {
              "type": "string"
            },
            "location": {
              "type": "string"
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            }
          },
          "resources": {
            "userAssignedIdentity": {
              "type": "Microsoft.ManagedIdentity/userAssignedIdentities",
              "apiVersion": "2023-07-31-preview",
              "name": "[parameters('identityName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]"
            }
          },
          "outputs": {
            "identityId": {
              "type": "string",
              "value": "[resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', parameters('identityName'))]"
            },
            "identityName": {
              "type": "string",
              "value": "[parameters('identityName')]"
            },
            "identityPrincipalId": {
              "type": "string",
              "value": "[reference('userAssignedIdentity').principalId]"
            },
            "identityClientId": {
              "type": "string",
              "value": "[reference('userAssignedIdentity').clientId]"
            }
          }
        }
      },
      "dependsOn": [
        "rg"
      ]
    },
    "agentIdentityBlueprint": {
      "condition": "[parameters('agentIdentityEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "agentIdentityBlueprint",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "blueprintDisplayName": {
            "value": "[variables('agentBlueprintName')]"
          },
          "blueprintUniqueName": {
            "value": "[format('nba-blueprint-{0}', variables('resourceToken'))]"
          },
          "federatedIdentityClientId": {
            "value": "[reference('mcpUserAssignedIdentity').outputs.identityName.value]"
          },
          "federatedIdentityPrincipalId": {
            "value": "[reference('mcpUserAssignedIdentity').outputs.identityPrincipalId.value]"
          },
          "sponsorPrincipalIds": "[if(not(empty(parameters('agentSponsorPrincipalId'))), createObject('value', createArray(parameters('agentSponsorPrincipalId'))), createObject('value', createArray()))]",
          "ownerPrincipalIds": "[if(not(empty(parameters('agentSponsorPrincipalId'))), createObject('value', createArray(parameters('agentSponsorPrincipalId'))), createObject('value', createArray()))]",
          "agentScopeValue": {
            "value": "next_best_action"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "406756142079523868"
            }
          },
          "parameters": {
            "blueprintDisplayName": {
              "type": "string",
              "metadata": {
                "description": "Display name for the Entra Agent Identity Blueprint application"
              }
            },
            "blueprintUniqueName": {
              "type": "string",
              "metadata": {
                "description": "Unique name for the Entra Agent Identity Blueprint (used for identifierUri)"
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Location for deployment scripts"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for resources"
              }
            },
            "sponsorPrincipalIds": {
              "type": "array",
              "defaultValue": [],
              "metadata": {
                "description": "Principal IDs of sponsors (users or groups) for the agent identity blueprint"
              }
            },
            "ownerPrincipalIds": {
              "type": "array",
              "defaultValue": [],
              "metadata": {
                "description": "Principal IDs of owners for the agent identity blueprint"
              }
            },
            "federatedIdentityClientId": {
              "type": "string",
              "metadata": {
                "description": "Client ID of the managed identity to use as federated credential for the blueprint"
              }
            },
            "federatedIdentityPrincipalId": {
              "type": "string",
              "metadata": {
                "description": "Principal ID of the managed identity to use as federated credential"
              }
            },
            "tenantId": {
              "type": "string",
              "defaultValue": "[tenant().tenantId]",
              "metadata": {
                "description": "Tenant ID for the Entra ID tenant"
              }
            },
            "agentScopeValue": {
              "type": "string",
              "defaultValue": "access_agent",
              "metadata": {
                "description": "OAuth2 scope value for the agent (default: access_agent)"
              }
            }
          },
          "variables": {
            "entraLoginEndpoint": "[environment().authentication.loginEndpoint]",
            "deploymentScriptName": "[format('ds-agent-blueprint-{0}', uniqueString(parameters('blueprintUniqueName')))]"
          },
          "resources": {
            "agentBlueprintScript": {
              "type": "Microsoft.Resources/deploymentScripts",
              "apiVersion": "2023-08-01",
              "name": "[variables('deploymentScriptName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "kind": "AzurePowerShell",
              "identity": {
                "type": "UserAssigned",
                "userAssignedIdentities": {
                  "[format('{0}', resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', parameters('federatedIdentityClientId')))]": {}
                }
              },
              "properties": {
                "azPowerShellVersion": "12.0",
                "timeout": "PT30M",
                "retentionInterval": "P1D",
                "cleanupPreference": "OnSuccess",
                "arguments": "[format('-BlueprintDisplayName \"{0}\" -BlueprintUniqueName \"{1}\" -TenantId \"{2}\" -FederatedIdentityPrincipalId \"{3}\" -SponsorIds \"{4}\" -OwnerIds \"{5}\" -AgentScopeValue \"{6}\" -EntraLoginEndpoint \"{7}\"', parameters('blueprintDisplayName'), parameters('blueprintUniqueName'), parameters('tenantId'), parameters('federatedIdentityPrincipalId'), join(parameters('sponsorPrincipalIds'), ','), join(parameters('ownerPrincipalIds'), ','), parameters('agentScopeValue'), variables('entraLoginEndpoint'))]",
                "scriptContent": "      param(\r\n        [string]$BlueprintDisplayName,\r\n        [string]$BlueprintUniqueName,\r\n        [string]$TenantId,\r\n        [string]$FederatedIdentityPrincipalId,\r\n        [string]$SponsorIds,\r\n        [string]$OwnerIds,\r\n        [string]$AgentScopeValue,\r\n        [string]$EntraLoginEndpoint\r\n      )\r\n\r\n      # Install Microsoft.Graph modules if needed\r\n      $modules = @('Microsoft.Graph.Authentication', 'Microsoft.Graph.Applications')\r\n      foreach ($module in $modules) {\r\n        if (-not (Get-Module -ListAvailable -Name $module)) {\r\n          Install-Module -Name $module -Force -Scope CurrentUser -AllowClobber\r\n        }\r\n        Import-Module $module -Force\r\n      }\r\n\r\n      # Connect to Microsoft Graph using managed identity\r\n      Connect-MgGraph -Identity -NoWelcome\r\n\r\n      # Prepare sponsors array\r\n      $sponsors = @()\r\n      if ($SponsorIds -and $SponsorIds -ne \"\") {\r\n        $sponsorIdList = $SponsorIds -split ','\r\n        foreach ($id in $sponsorIdList) {\r\n          if ($id.Trim()) {\r\n            $sponsors += \"https://graph.microsoft.com/v1.0/users/$($id.Trim())\"\r\n          }\r\n        }\r\n      }\r\n\r\n      # Prepare owners array\r\n      $owners = @()\r\n      if ($OwnerIds -and $OwnerIds -ne \"\") {\r\n        $ownerIdList = $OwnerIds -split ','\r\n        foreach ($id in $ownerIdList) {\r\n          if ($id.Trim()) {\r\n            $owners += \"https://graph.microsoft.com/v1.0/users/$($id.Trim())\"\r\n          }\r\n        }\r\n      }\r\n\r\n      # Check if blueprint already exists\r\n      $existingApp = Get-MgApplication -Filter \"displayName eq '$BlueprintDisplayName'\" -ErrorAction SilentlyContinue | Where-Object { $_.AdditionalProperties.'@odata.type' -eq '#microsoft.graph.agentIdentityBlueprint' }\r\n\r\n      if ($existingApp) {\r\n        Write-Host \"Agent Identity Blueprint already exists with App ID: $($existingApp.AppId)\"\r\n        $blueprintAppId = $existingApp.AppId\r\n        $blueprintObjectId = $existingApp.Id\r\n      } else {\r\n        # Create Agent Identity Blueprint application\r\n        $blueprintBody = @{\r\n          '@odata.type' = '#microsoft.graph.agentIdentityBlueprint'\r\n          displayName = $BlueprintDisplayName\r\n        }\r\n\r\n        if ($sponsors.Count -gt 0) {\r\n          $blueprintBody['sponsors@odata.bind'] = $sponsors\r\n        }\r\n        if ($owners.Count -gt 0) {\r\n          $blueprintBody['owners@odata.bind'] = $owners\r\n        }\r\n\r\n        # Create the blueprint via Graph API\r\n        $headers = @{\r\n          'OData-Version' = '4.0'\r\n          'Content-Type' = 'application/json'\r\n        }\r\n\r\n        try {\r\n          $blueprintResponse = Invoke-MgGraphRequest -Method POST -Uri 'https://graph.microsoft.com/beta/applications' -Body ($blueprintBody | ConvertTo-Json -Depth 10) -Headers $headers\r\n          $blueprintAppId = $blueprintResponse.appId\r\n          $blueprintObjectId = $blueprintResponse.id\r\n          Write-Host \"Created Agent Identity Blueprint with App ID: $blueprintAppId\"\r\n        } catch {\r\n          Write-Error \"Failed to create Agent Identity Blueprint: $_\"\r\n          throw\r\n        }\r\n\r\n        # Create Service Principal for the blueprint\r\n        $spBody = @{\r\n          appId = $blueprintAppId\r\n        }\r\n\r\n        try {\r\n          $spResponse = Invoke-MgGraphRequest -Method POST -Uri 'https://graph.microsoft.com/beta/serviceprincipals/graph.agentIdentityBlueprintPrincipal' -Body ($spBody | ConvertTo-Json) -Headers $headers\r\n          Write-Host \"Created Service Principal for Agent Identity Blueprint\"\r\n        } catch {\r\n          Write-Warning \"Service Principal may already exist or failed to create: $_\"\r\n        }\r\n\r\n        # Add federated identity credential for managed identity\r\n        $fedCredBody = @{\r\n          name = 'mcp-agent-msi'\r\n          issuer = \"$EntraLoginEndpoint$TenantId/v2.0\"\r\n          subject = $FederatedIdentityPrincipalId\r\n          audiences = @('api://AzureADTokenExchange')\r\n        }\r\n\r\n        try {\r\n          Invoke-MgGraphRequest -Method POST -Uri \"https://graph.microsoft.com/beta/applications/$blueprintObjectId/federatedIdentityCredentials\" -Body ($fedCredBody | ConvertTo-Json) -Headers $headers\r\n          Write-Host \"Added federated identity credential for managed identity\"\r\n        } catch {\r\n          Write-Warning \"Federated credential may already exist: $_\"\r\n        }\r\n\r\n        # Configure identifier URI and OAuth2 scope\r\n        $scopeId = [guid]::NewGuid().ToString()\r\n        $updateBody = @{\r\n          identifierUris = @(\"api://$blueprintAppId\")\r\n          api = @{\r\n            oauth2PermissionScopes = @(\r\n              @{\r\n                adminConsentDescription = \"Allow the application to access the agent on behalf of the signed-in user.\"\r\n                adminConsentDisplayName = \"Access Agent\"\r\n                id = $scopeId\r\n                isEnabled = $true\r\n                type = \"User\"\r\n                value = $AgentScopeValue\r\n              }\r\n            )\r\n          }\r\n        }\r\n\r\n        try {\r\n          Invoke-MgGraphRequest -Method PATCH -Uri \"https://graph.microsoft.com/beta/applications/$blueprintObjectId\" -Body ($updateBody | ConvertTo-Json -Depth 10) -Headers $headers\r\n          Write-Host \"Configured identifier URI and OAuth2 scope\"\r\n        } catch {\r\n          Write-Warning \"Failed to configure identifier URI: $_\"\r\n        }\r\n      }\r\n\r\n      # Output results\r\n      $DeploymentScriptOutputs = @{}\r\n      $DeploymentScriptOutputs['blueprintAppId'] = $blueprintAppId\r\n      $DeploymentScriptOutputs['blueprintObjectId'] = $blueprintObjectId\r\n      $DeploymentScriptOutputs['identifierUri'] = \"api://$blueprintAppId\"\r\n\r\n      Write-Host \"Agent Identity Blueprint setup complete\"\r\n      Write-Host \"Blueprint App ID: $blueprintAppId\"\r\n      Write-Host \"Blueprint Object ID: $blueprintObjectId\"\r\n    "
              }
            }
          },
          "outputs": {
            "blueprintAppId": {
              "type": "string",
              "value": "[reference('agentBlueprintScript').outputs.blueprintAppId]"
            },
            "blueprintObjectId": {
              "type": "string",
              "value": "[reference('agentBlueprintScript').outputs.blueprintObjectId]"
            },
            "identifierUri": {
              "type": "string",
              "value": "[reference('agentBlueprintScript').outputs.identifierUri]"
            }
          }
        }
      },
      "dependsOn": [
        "mcpUserAssignedIdentity",
        "rg"
      ]
    },
    "nextBestActionAgentIdentity": {
      "condition": "[parameters('agentIdentityEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "nextBestActionAgentIdentity",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "agentDisplayName": {
            "value": "[variables('agentName')]"
          },
          "blueprintAppId": {
            "value": "[reference('agentIdentityBlueprint').outputs.blueprintAppId.value]"
          },
          "managedIdentityResourceId": {
            "value": "[reference('mcpUserAssignedIdentity').outputs.identityId.value]"
          },
          "sponsorPrincipalIds": "[if(not(empty(parameters('agentSponsorPrincipalId'))), createObject('value', createArray(parameters('agentSponsorPrincipalId'))), createObject('value', createArray()))]"
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "5792129572458528281"
            }
          },
          "parameters": {
            "agentDisplayName": {
              "type": "string",
              "metadata": {
                "description": "Display name for the Entra Agent Identity"
              }
            },
            "blueprintAppId": {
              "type": "string",
              "metadata": {
                "description": "App ID of the Agent Identity Blueprint"
              }
            },
            "sponsorPrincipalIds": {
              "type": "array",
              "defaultValue": [],
              "metadata": {
                "description": "Principal IDs of sponsors (users or groups) for the agent identity"
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Location for deployment scripts"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for resources"
              }
            },
            "managedIdentityResourceId": {
              "type": "string",
              "metadata": {
                "description": "Resource ID of the managed identity (full resource ID)"
              }
            }
          },
          "variables": {
            "deploymentScriptName": "[format('ds-agent-identity-{0}', uniqueString(parameters('agentDisplayName')))]"
          },
          "resources": {
            "agentIdentityScript": {
              "type": "Microsoft.Resources/deploymentScripts",
              "apiVersion": "2023-08-01",
              "name": "[variables('deploymentScriptName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "kind": "AzurePowerShell",
              "identity": {
                "type": "UserAssigned",
                "userAssignedIdentities": {
                  "[format('{0}', parameters('managedIdentityResourceId'))]": {}
                }
              },
              "properties": {
                "azPowerShellVersion": "12.0",
                "timeout": "PT30M",
                "retentionInterval": "P1D",
                "cleanupPreference": "OnSuccess",
                "arguments": "[format('-AgentDisplayName \"{0}\" -BlueprintAppId \"{1}\" -SponsorIds \"{2}\"', parameters('agentDisplayName'), parameters('blueprintAppId'), join(parameters('sponsorPrincipalIds'), ','))]",
                "scriptContent": "      param(\r\n        [string]$AgentDisplayName,\r\n        [string]$BlueprintAppId,\r\n        [string]$SponsorIds\r\n      )\r\n\r\n      # Install Microsoft.Graph modules if needed\r\n      $modules = @('Microsoft.Graph.Authentication')\r\n      foreach ($module in $modules) {\r\n        if (-not (Get-Module -ListAvailable -Name $module)) {\r\n          Install-Module -Name $module -Force -Scope CurrentUser -AllowClobber\r\n        }\r\n        Import-Module $module -Force\r\n      }\r\n\r\n      # Connect to Microsoft Graph using managed identity\r\n      Connect-MgGraph -Identity -NoWelcome\r\n\r\n      # Get the blueprint service principal to obtain token\r\n      $blueprintSp = Get-MgServicePrincipal -Filter \"appId eq '$BlueprintAppId'\" -ErrorAction SilentlyContinue\r\n\r\n      if (-not $blueprintSp) {\r\n        Write-Error \"Blueprint service principal not found for App ID: $BlueprintAppId\"\r\n        throw \"Blueprint not found\"\r\n      }\r\n\r\n      # Check if agent identity already exists\r\n      $existingSp = Get-MgServicePrincipal -Filter \"displayName eq '$AgentDisplayName' and servicePrincipalType eq 'AgentIdentity'\" -ErrorAction SilentlyContinue\r\n\r\n      if ($existingSp) {\r\n        Write-Host \"Agent Identity already exists with ID: $($existingSp.Id)\"\r\n        $agentIdentityId = $existingSp.Id\r\n        $agentIdentityAppId = $existingSp.AppId\r\n      } else {\r\n        # Prepare sponsors array\r\n        $sponsors = @()\r\n        if ($SponsorIds -and $SponsorIds -ne \"\") {\r\n          $sponsorIdList = $SponsorIds -split ','\r\n          foreach ($id in $sponsorIdList) {\r\n            if ($id.Trim()) {\r\n              $sponsors += \"https://graph.microsoft.com/v1.0/users/$($id.Trim())\"\r\n            }\r\n          }\r\n        }\r\n\r\n        # Create Agent Identity via Graph API\r\n        $headers = @{\r\n          'OData-Version' = '4.0'\r\n          'Content-Type' = 'application/json'\r\n        }\r\n\r\n        $agentBody = @{\r\n          displayName = $AgentDisplayName\r\n          agentIdentityBlueprintId = $BlueprintAppId\r\n        }\r\n\r\n        if ($sponsors.Count -gt 0) {\r\n          $agentBody['sponsors@odata.bind'] = $sponsors\r\n        }\r\n\r\n        try {\r\n          $agentResponse = Invoke-MgGraphRequest -Method POST -Uri 'https://graph.microsoft.com/beta/serviceprincipals/Microsoft.Graph.AgentIdentity' -Body ($agentBody | ConvertTo-Json -Depth 10) -Headers $headers\r\n          $agentIdentityId = $agentResponse.id\r\n          $agentIdentityAppId = $agentResponse.appId\r\n          Write-Host \"Created Agent Identity with ID: $agentIdentityId\"\r\n        } catch {\r\n          Write-Error \"Failed to create Agent Identity: $_\"\r\n          throw\r\n        }\r\n      }\r\n\r\n      # Get the full service principal details for the agent identity\r\n      $agentSp = Invoke-MgGraphRequest -Method GET -Uri \"https://graph.microsoft.com/beta/serviceprincipals/$agentIdentityId\" -ErrorAction SilentlyContinue\r\n\r\n      # Output results\r\n      $DeploymentScriptOutputs = @{}\r\n      $DeploymentScriptOutputs['agentIdentityId'] = $agentIdentityId\r\n      $DeploymentScriptOutputs['agentIdentityAppId'] = if ($agentIdentityAppId) { $agentIdentityAppId } else { $agentSp.appId }\r\n      $DeploymentScriptOutputs['agentIdentityPrincipalId'] = $agentIdentityId\r\n      $DeploymentScriptOutputs['agentDisplayName'] = $AgentDisplayName\r\n\r\n      Write-Host \"Agent Identity creation complete\"\r\n      Write-Host \"Agent Identity ID: $agentIdentityId\"\r\n    "
              }
            }
          },
          "outputs": {
            "agentIdentityId": {
              "type": "string",
              "value": "[reference('agentIdentityScript').outputs.agentIdentityId]"
            },
            "agentIdentityAppId": {
              "type": "string",
              "value": "[reference('agentIdentityScript').outputs.agentIdentityAppId]"
            },
            "agentIdentityPrincipalId": {
              "type": "string",
              "value": "[reference('agentIdentityScript').outputs.agentIdentityPrincipalId]"
            },
            "agentDisplayName": {
              "type": "string",
              "value": "[reference('agentIdentityScript').outputs.agentDisplayName]"
            }
          }
        }
      },
      "dependsOn": [
        "agentIdentityBlueprint",
        "mcpUserAssignedIdentity",
        "rg"
      ]
    },
    "serviceVirtualNetworkEarly": {
      "condition": "[parameters('vnetEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "serviceVirtualNetworkEarly",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "vNetName": {
            "value": "[variables('serviceVirtualNetworkName')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "12028796055207520394"
            }
          },
          "parameters": {
            "vNetName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the virtual network."
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Specifies the location."
              }
            },
            "peSubnetName": {
              "type": "string",
              "defaultValue": "private-endpoints-subnet",
              "metadata": {
                "description": "Specifies the name of the subnet for the Service Bus private endpoint."
              }
            },
            "appSubnetName": {
              "type": "string",
              "defaultValue": "app",
              "metadata": {
                "description": "Specifies the name of the subnet for Function App virtual network integration."
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            }
          },
          "resources": {
            "virtualNetwork": {
              "type": "Microsoft.Network/virtualNetworks",
              "apiVersion": "2023-05-01",
              "name": "[parameters('vNetName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "addressSpace": {
                  "addressPrefixes": [
                    "10.0.0.0/16"
                  ]
                },
                "encryption": {
                  "enabled": false,
                  "enforcement": "AllowUnencrypted"
                },
                "subnets": [
                  {
                    "name": "[parameters('peSubnetName')]",
                    "id": "[resourceId('Microsoft.Network/virtualNetworks/subnets', parameters('vNetName'), 'private-endpoints-subnet')]",
                    "properties": {
                      "addressPrefixes": [
                        "10.0.1.0/24"
                      ],
                      "delegations": [],
                      "privateEndpointNetworkPolicies": "Disabled",
                      "privateLinkServiceNetworkPolicies": "Enabled"
                    },
                    "type": "Microsoft.Network/virtualNetworks/subnets"
                  },
                  {
                    "name": "[parameters('appSubnetName')]",
                    "id": "[resourceId('Microsoft.Network/virtualNetworks/subnets', parameters('vNetName'), 'app')]",
                    "properties": {
                      "addressPrefixes": [
                        "10.0.2.0/24"
                      ],
                      "delegations": [],
                      "privateEndpointNetworkPolicies": "Disabled",
                      "privateLinkServiceNetworkPolicies": "Enabled"
                    },
                    "type": "Microsoft.Network/virtualNetworks/subnets"
                  }
                ],
                "virtualNetworkPeerings": [],
                "enableDdosProtection": false
              }
            }
          },
          "outputs": {
            "peSubnetName": {
              "type": "string",
              "value": "[reference('virtualNetwork').subnets[0].name]"
            },
            "peSubnetID": {
              "type": "string",
              "value": "[reference('virtualNetwork').subnets[0].id]"
            },
            "appSubnetName": {
              "type": "string",
              "value": "[reference('virtualNetwork').subnets[1].name]"
            },
            "appSubnetID": {
              "type": "string",
              "value": "[reference('virtualNetwork').subnets[1].id]"
            }
          }
        }
      },
      "dependsOn": [
        "rg"
      ]
    },
    "containerRegistry": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "containerRegistry",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "containerRegistryName": {
            "value": "[format('{0}{1}', variables('abbrs').containerRegistryRegistries, variables('resourceToken'))]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "sku": "[if(parameters('vnetEnabled'), createObject('value', 'Premium'), createObject('value', 'Standard'))]",
          "publicNetworkAccess": "[if(parameters('vnetEnabled'), createObject('value', 'Disabled'), createObject('value', 'Enabled'))]"
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "13519068738875194567"
            }
          },
          "parameters": {
            "containerRegistryName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Azure Container Registry"
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Location for the container registry"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for the container registry"
              }
            },
            "sku": {
              "type": "string",
              "defaultValue": "Standard",
              "allowedValues": [
                "Basic",
                "Standard",
                "Premium"
              ],
              "metadata": {
                "description": "SKU for the container registry"
              }
            },
            "adminUserEnabled": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enable admin user"
              }
            },
            "publicNetworkAccess": {
              "type": "string",
              "defaultValue": "Enabled",
              "allowedValues": [
                "Enabled",
                "Disabled"
              ],
              "metadata": {
                "description": "Public network access setting"
              }
            }
          },
          "resources": {
            "containerRegistry": {
              "type": "Microsoft.ContainerRegistry/registries",
              "apiVersion": "2023-07-01",
              "name": "[parameters('containerRegistryName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "sku": {
                "name": "[parameters('sku')]"
              },
              "properties": {
                "adminUserEnabled": "[parameters('adminUserEnabled')]",
                "publicNetworkAccess": "[parameters('publicNetworkAccess')]",
                "networkRuleBypassOptions": "AzureServices"
              }
            }
          },
          "outputs": {
            "containerRegistryId": {
              "type": "string",
              "value": "[resourceId('Microsoft.ContainerRegistry/registries', parameters('containerRegistryName'))]"
            },
            "containerRegistryName": {
              "type": "string",
              "value": "[parameters('containerRegistryName')]"
            },
            "containerRegistryLoginServer": {
              "type": "string",
              "value": "[reference('containerRegistry').loginServer]"
            }
          }
        }
      },
      "dependsOn": [
        "rg"
      ]
    },
    "azureMonitorWorkspace": {
      "condition": "[parameters('grafanaEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "azureMonitorWorkspace",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "name": {
            "value": "[variables('azureMonitorWorkspaceName')]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "publicNetworkAccess": {
            "value": "Enabled"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "7195397707672345960"
            }
          },
          "parameters": {
            "name": {
              "type": "string",
              "metadata": {
                "description": "Name of the Azure Monitor Workspace"
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Location for the Azure Monitor Workspace"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for the Azure Monitor Workspace"
              }
            },
            "publicNetworkAccess": {
              "type": "string",
              "defaultValue": "Enabled",
              "allowedValues": [
                "Enabled",
                "Disabled"
              ],
              "metadata": {
                "description": "Enable public network access"
              }
            }
          },
          "resources": {
            "azureMonitorWorkspace": {
              "type": "Microsoft.Monitor/accounts",
              "apiVersion": "2023-04-03",
              "name": "[parameters('name')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "publicNetworkAccess": "[parameters('publicNetworkAccess')]"
              }
            }
          },
          "outputs": {
            "id": {
              "type": "string",
              "metadata": {
                "description": "The resource ID of the Azure Monitor Workspace"
              },
              "value": "[resourceId('Microsoft.Monitor/accounts', parameters('name'))]"
            },
            "name": {
              "type": "string",
              "metadata": {
                "description": "The name of the Azure Monitor Workspace"
              },
              "value": "[parameters('name')]"
            },
            "prometheusQueryEndpoint": {
              "type": "string",
              "metadata": {
                "description": "The Prometheus query endpoint"
              },
              "value": "[reference('azureMonitorWorkspace').metrics.prometheusQueryEndpoint]"
            },
            "dataCollectionRuleId": {
              "type": "string",
              "metadata": {
                "description": "The default data collection rule resource ID"
              },
              "value": "[reference('azureMonitorWorkspace').defaultIngestionSettings.dataCollectionRuleResourceId]"
            },
            "dataCollectionEndpointId": {
              "type": "string",
              "metadata": {
                "description": "The default data collection endpoint resource ID"
              },
              "value": "[reference('azureMonitorWorkspace').defaultIngestionSettings.dataCollectionEndpointResourceId]"
            }
          }
        }
      },
      "dependsOn": [
        "rg"
      ]
    },
    "aksCluster": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "aksCluster",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "aksClusterName": {
            "value": "[format('{0}{1}', variables('abbrs').containerServiceManagedClusters, variables('resourceToken'))]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "kubernetesVersion": {
            "value": "1.32.0"
          },
          "systemNodePoolVmSize": {
            "value": "Standard_DS2_v2"
          },
          "systemNodePoolCount": {
            "value": 2
          },
          "userAssignedIdentityId": {
            "value": "[reference('aksUserAssignedIdentity').outputs.identityId.value]"
          },
          "logAnalyticsWorkspaceId": {
            "value": "[reference('monitoring').outputs.logAnalyticsWorkspaceId.value]"
          },
          "subnetId": "[if(parameters('vnetEnabled'), createObject('value', format('{0}/providers/Microsoft.Network/virtualNetworks/{1}/subnets/{2}', subscriptionResourceId('Microsoft.Resources/resourceGroups', if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))), variables('serviceVirtualNetworkName'), variables('serviceVirtualNetworkAppSubnetName'))), createObject('value', ''))]",
          "enablePrometheus": {
            "value": "[parameters('grafanaEnabled')]"
          },
          "azureMonitorWorkspaceId": "[if(parameters('grafanaEnabled'), createObject('value', reference('azureMonitorWorkspace').outputs.id.value), createObject('value', ''))]"
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "14373536021663033119"
            }
          },
          "parameters": {
            "aksClusterName": {
              "type": "string",
              "metadata": {
                "description": "Name of the AKS cluster"
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Location for the AKS cluster"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for the AKS cluster"
              }
            },
            "kubernetesVersion": {
              "type": "string",
              "defaultValue": "1.32.0",
              "metadata": {
                "description": "Kubernetes version"
              }
            },
            "systemNodePoolVmSize": {
              "type": "string",
              "defaultValue": "Standard_DS2_v2",
              "metadata": {
                "description": "System node pool VM size"
              }
            },
            "systemNodePoolCount": {
              "type": "int",
              "defaultValue": 2,
              "metadata": {
                "description": "System node pool count"
              }
            },
            "userAssignedIdentityId": {
              "type": "string",
              "metadata": {
                "description": "User assigned managed identity ID for AKS"
              }
            },
            "logAnalyticsWorkspaceId": {
              "type": "string",
              "metadata": {
                "description": "Log Analytics workspace ID"
              }
            },
            "subnetId": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Virtual Network Subnet ID"
              }
            },
            "enableAzureRbac": {
              "type": "bool",
              "defaultValue": true,
              "metadata": {
                "description": "Enable Azure AD RBAC"
              }
            },
            "enableMonitoring": {
              "type": "bool",
              "defaultValue": true,
              "metadata": {
                "description": "Enable monitoring"
              }
            },
            "skuTier": {
              "type": "string",
              "defaultValue": "Standard",
              "allowedValues": [
                "Free",
                "Standard"
              ],
              "metadata": {
                "description": "AKS SKU tier - Free or Standard"
              }
            },
            "azureMonitorWorkspaceId": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Azure Monitor Workspace ID for Prometheus metrics"
              }
            },
            "enablePrometheus": {
              "type": "bool",
              "defaultValue": true,
              "metadata": {
                "description": "Enable Prometheus metrics collection"
              }
            }
          },
          "resources": {
            "aksCluster": {
              "type": "Microsoft.ContainerService/managedClusters",
              "apiVersion": "2024-02-01",
              "name": "[parameters('aksClusterName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "sku": {
                "name": "Base",
                "tier": "[parameters('skuTier')]"
              },
              "identity": {
                "type": "UserAssigned",
                "userAssignedIdentities": {
                  "[format('{0}', parameters('userAssignedIdentityId'))]": {}
                }
              },
              "properties": {
                "kubernetesVersion": "[parameters('kubernetesVersion')]",
                "dnsPrefix": "[parameters('aksClusterName')]",
                "enableRBAC": true,
                "aadProfile": {
                  "managed": true,
                  "enableAzureRBAC": "[parameters('enableAzureRbac')]"
                },
                "agentPoolProfiles": [
                  {
                    "name": "system",
                    "count": "[parameters('systemNodePoolCount')]",
                    "vmSize": "[parameters('systemNodePoolVmSize')]",
                    "osType": "Linux",
                    "mode": "System",
                    "type": "VirtualMachineScaleSets",
                    "enableAutoScaling": true,
                    "minCount": "[parameters('systemNodePoolCount')]",
                    "maxCount": "[add(parameters('systemNodePoolCount'), 2)]",
                    "vnetSubnetID": "[if(not(empty(parameters('subnetId'))), parameters('subnetId'), null())]",
                    "tags": "[parameters('tags')]"
                  }
                ],
                "networkProfile": {
                  "networkPlugin": "azure",
                  "networkPolicy": "azure",
                  "serviceCidr": "10.240.0.0/16",
                  "dnsServiceIP": "10.240.0.10",
                  "loadBalancerSku": "standard"
                },
                "addonProfiles": "[if(parameters('enableMonitoring'), createObject('omsagent', createObject('enabled', true(), 'config', createObject('logAnalyticsWorkspaceResourceID', parameters('logAnalyticsWorkspaceId')))), createObject())]",
                "oidcIssuerProfile": {
                  "enabled": true
                },
                "securityProfile": {
                  "workloadIdentity": {
                    "enabled": true
                  }
                },
                "azureMonitorProfile": "[if(and(parameters('enablePrometheus'), not(empty(parameters('azureMonitorWorkspaceId')))), createObject('metrics', createObject('enabled', true(), 'kubeStateMetrics', createObject('metricLabelsAllowlist', '*', 'metricAnnotationsAllowList', '*'))), null())]"
              }
            }
          },
          "outputs": {
            "aksClusterId": {
              "type": "string",
              "value": "[resourceId('Microsoft.ContainerService/managedClusters', parameters('aksClusterName'))]"
            },
            "aksClusterName": {
              "type": "string",
              "value": "[parameters('aksClusterName')]"
            },
            "aksClusterFqdn": {
              "type": "string",
              "value": "[reference('aksCluster').fqdn]"
            },
            "aksClusterOidcIssuerUrl": {
              "type": "string",
              "value": "[reference('aksCluster').oidcIssuerProfile.issuerURL]"
            }
          }
        }
      },
      "dependsOn": [
        "aksUserAssignedIdentity",
        "azureMonitorWorkspace",
        "monitoring",
        "rg",
        "serviceVirtualNetworkEarly"
      ]
    },
    "mcpPublicIp": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "mcpPublicIp",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "publicIpName": {
            "value": "[format('pip-mcp-{0}', variables('resourceToken'))]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "dnsLabel": {
            "value": "[format('mcp-{0}', variables('resourceToken'))]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "13235050243755381749"
            }
          },
          "parameters": {
            "publicIpName": {
              "type": "string",
              "metadata": {
                "description": "Name of the public IP address"
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Location for the public IP"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for the resource"
              }
            },
            "sku": {
              "type": "string",
              "defaultValue": "Standard",
              "metadata": {
                "description": "SKU for the public IP (Standard required for LoadBalancer)"
              }
            },
            "allocationMethod": {
              "type": "string",
              "defaultValue": "Static",
              "metadata": {
                "description": "Allocation method (Static required for LoadBalancer)"
              }
            },
            "dnsLabel": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "DNS label for the public IP (optional)"
              }
            }
          },
          "resources": {
            "publicIp": {
              "type": "Microsoft.Network/publicIPAddresses",
              "apiVersion": "2023-05-01",
              "name": "[parameters('publicIpName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "sku": {
                "name": "[parameters('sku')]",
                "tier": "Regional"
              },
              "properties": {
                "publicIPAllocationMethod": "[parameters('allocationMethod')]",
                "dnsSettings": "[if(not(empty(parameters('dnsLabel'))), createObject('domainNameLabel', parameters('dnsLabel')), null())]"
              }
            }
          },
          "outputs": {
            "publicIpId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/publicIPAddresses', parameters('publicIpName'))]"
            },
            "publicIpAddress": {
              "type": "string",
              "value": "[reference('publicIp').ipAddress]"
            },
            "publicIpFqdn": {
              "type": "string",
              "value": "[if(not(empty(parameters('dnsLabel'))), reference('publicIp').dnsSettings.fqdn, '')]"
            }
          }
        }
      },
      "dependsOn": [
        "rg"
      ]
    },
    "acrPullRoleAssignment": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "acrPullRoleAssignment",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "containerRegistryName": {
            "value": "[reference('containerRegistry').outputs.containerRegistryName.value]"
          },
          "roleDefinitionID": {
            "value": "[variables('acrPullRoleDefinitionId')]"
          },
          "principalID": {
            "value": "[reference('aksUserAssignedIdentity').outputs.identityPrincipalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "11813188951282439005"
            }
          },
          "parameters": {
            "principalID": {
              "type": "string"
            },
            "roleDefinitionID": {
              "type": "string"
            },
            "containerRegistryName": {
              "type": "string"
            },
            "nameSuffix": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Optional suffix to make role assignment name unique across deployments"
              }
            }
          },
          "resources": {
            "containerRegistry": {
              "existing": true,
              "type": "Microsoft.ContainerRegistry/registries",
              "apiVersion": "2023-07-01",
              "name": "[parameters('containerRegistryName')]"
            },
            "acrRoleAssignment": {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.ContainerRegistry/registries/{0}', parameters('containerRegistryName'))]",
              "name": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.ContainerRegistry/registries', parameters('containerRegistryName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.ContainerRegistry/registries', parameters('containerRegistryName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalId": "[parameters('principalID')]",
                "principalType": "ServicePrincipal"
              },
              "dependsOn": [
                "containerRegistry"
              ]
            }
          },
          "outputs": {
            "roleAssignmentName": {
              "type": "string",
              "value": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.ContainerRegistry/registries', parameters('containerRegistryName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.ContainerRegistry/registries', parameters('containerRegistryName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]"
            }
          }
        }
      },
      "dependsOn": [
        "aksCluster",
        "aksUserAssignedIdentity",
        "containerRegistry",
        "rg"
      ]
    },
    "acrPrivateEndpoint": {
      "condition": "[parameters('vnetEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "acrPrivateEndpoint",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "virtualNetworkName": {
            "value": "[variables('serviceVirtualNetworkName')]"
          },
          "subnetName": "[if(parameters('vnetEnabled'), createObject('value', variables('serviceVirtualNetworkPrivateEndpointSubnetName')), createObject('value', ''))]",
          "acrName": {
            "value": "[reference('containerRegistry').outputs.containerRegistryName.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "17782222565987401451"
            }
          },
          "parameters": {
            "virtualNetworkName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the virtual network."
              }
            },
            "subnetName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the subnet which contains the private endpoints."
              }
            },
            "acrName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the Azure Container Registry."
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Specifies the location."
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            }
          },
          "variables": {
            "acrPrivateDNSZoneName": "privatelink.azurecr.io",
            "acrPrivateDnsZoneVirtualNetworkLinkName": "[format('{0}-acr-link-{1}', parameters('acrName'), take(toLower(uniqueString(parameters('acrName'), parameters('virtualNetworkName'))), 4))]"
          },
          "resources": {
            "vnet": {
              "existing": true,
              "type": "Microsoft.Network/virtualNetworks",
              "apiVersion": "2021-08-01",
              "name": "[parameters('virtualNetworkName')]"
            },
            "acr": {
              "existing": true,
              "type": "Microsoft.ContainerRegistry/registries",
              "apiVersion": "2023-07-01",
              "name": "[parameters('acrName')]"
            },
            "acrPrivateDnsZone": {
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2020-06-01",
              "name": "[variables('acrPrivateDNSZoneName')]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {},
              "dependsOn": [
                "vnet"
              ]
            },
            "acrPrivateDnsZoneVirtualNetworkLink": {
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('acrPrivateDNSZoneName'), variables('acrPrivateDnsZoneVirtualNetworkLinkName'))]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "acrPrivateDnsZone",
                "vnet"
              ]
            },
            "acrPrivateEndpoint": {
              "type": "Microsoft.Network/privateEndpoints",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}-pe', parameters('acrName'))]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "privateLinkServiceConnections": [
                  {
                    "name": "acrPrivateLinkConnection",
                    "properties": {
                      "privateLinkServiceId": "[resourceId('Microsoft.ContainerRegistry/registries', parameters('acrName'))]",
                      "groupIds": [
                        "registry"
                      ]
                    }
                  }
                ],
                "subnet": {
                  "id": "[format('{0}/subnets/{1}', resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName')), parameters('subnetName'))]"
                }
              },
              "dependsOn": [
                "acr",
                "vnet"
              ]
            },
            "acrPrivateDnsZoneGroup": {
              "type": "Microsoft.Network/privateEndpoints/privateDnsZoneGroups",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', format('{0}-pe', parameters('acrName')), 'acrPrivateDnsZoneGroup')]",
              "properties": {
                "privateDnsZoneConfigs": [
                  {
                    "name": "config1",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('acrPrivateDNSZoneName'))]"
                    }
                  }
                ]
              },
              "dependsOn": [
                "acrPrivateDnsZone",
                "acrPrivateEndpoint"
              ]
            }
          },
          "outputs": {
            "privateEndpointId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateEndpoints', format('{0}-pe', parameters('acrName')))]"
            },
            "privateDnsZoneId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateDnsZones', variables('acrPrivateDNSZoneName'))]"
            }
          }
        }
      },
      "dependsOn": [
        "containerRegistry",
        "rg",
        "serviceVirtualNetwork"
      ]
    },
    "agentFederatedCredential": {
      "condition": "[parameters('agentIdentityEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "agentFederatedCredential",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "aksClusterName": {
            "value": "[reference('aksCluster').outputs.aksClusterName.value]"
          },
          "serviceAccountNamespace": {
            "value": "mcp-agents"
          },
          "serviceAccountName": {
            "value": "mcp-agent-sa"
          },
          "identityClientId": {
            "value": "[reference('nextBestActionAgentIdentity').outputs.agentIdentityAppId.value]"
          },
          "identityPrincipalId": {
            "value": "[reference('nextBestActionAgentIdentity').outputs.agentIdentityPrincipalId.value]"
          },
          "federatedCredentialName": {
            "value": "aks-mcp-agent-fed"
          },
          "configurationIdentityResourceId": {
            "value": "[reference('mcpUserAssignedIdentity').outputs.identityId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "3100188267378684617"
            }
          },
          "parameters": {
            "aksClusterName": {
              "type": "string",
              "metadata": {
                "description": "Name of the AKS cluster"
              }
            },
            "serviceAccountNamespace": {
              "type": "string",
              "metadata": {
                "description": "Namespace for the Kubernetes service account"
              }
            },
            "serviceAccountName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Kubernetes service account"
              }
            },
            "identityClientId": {
              "type": "string",
              "metadata": {
                "description": "App ID (client ID) of the Agent Identity or User Assigned Identity"
              }
            },
            "identityPrincipalId": {
              "type": "string",
              "metadata": {
                "description": "Principal ID of the Agent Identity or User Assigned Identity"
              }
            },
            "federatedCredentialName": {
              "type": "string",
              "metadata": {
                "description": "Name for the federated credential"
              }
            },
            "subjectIdentifier": {
              "type": "string",
              "defaultValue": "[format('system:serviceaccount:{0}:{1}', parameters('serviceAccountNamespace'), parameters('serviceAccountName'))]",
              "metadata": {
                "description": "Subject identifier for the service account (format: system:serviceaccount:namespace:serviceAccountName)"
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Location for deployment scripts"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for resources"
              }
            },
            "configurationIdentityResourceId": {
              "type": "string",
              "metadata": {
                "description": "Resource ID of a managed identity with permissions to configure federated credentials"
              }
            }
          },
          "variables": {
            "deploymentScriptName": "[format('ds-fed-cred-{0}', uniqueString(parameters('identityClientId'), parameters('serviceAccountName')))]"
          },
          "resources": {
            "aksCluster": {
              "existing": true,
              "type": "Microsoft.ContainerService/managedClusters",
              "apiVersion": "2024-02-01",
              "name": "[parameters('aksClusterName')]"
            },
            "federatedCredentialScript": {
              "type": "Microsoft.Resources/deploymentScripts",
              "apiVersion": "2023-08-01",
              "name": "[variables('deploymentScriptName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "kind": "AzurePowerShell",
              "identity": {
                "type": "UserAssigned",
                "userAssignedIdentities": {
                  "[format('{0}', parameters('configurationIdentityResourceId'))]": {}
                }
              },
              "properties": {
                "azPowerShellVersion": "12.0",
                "timeout": "PT30M",
                "retentionInterval": "P1D",
                "cleanupPreference": "OnSuccess",
                "arguments": "[format('-IdentityPrincipalId \"{0}\" -FederatedCredentialName \"{1}\" -OidcIssuerUrl \"{2}\" -Subject \"{3}\"', parameters('identityPrincipalId'), parameters('federatedCredentialName'), reference('aksCluster').oidcIssuerProfile.issuerURL, parameters('subjectIdentifier'))]",
                "scriptContent": "      param(\r\n        [string]$IdentityPrincipalId,\r\n        [string]$FederatedCredentialName,\r\n        [string]$OidcIssuerUrl,\r\n        [string]$Subject\r\n      )\r\n\r\n      # Install Microsoft.Graph modules if needed\r\n      $modules = @('Microsoft.Graph.Authentication', 'Microsoft.Graph.Applications')\r\n      foreach ($module in $modules) {\r\n        if (-not (Get-Module -ListAvailable -Name $module)) {\r\n          Install-Module -Name $module -Force -Scope CurrentUser -AllowClobber\r\n        }\r\n        Import-Module $module -Force\r\n      }\r\n\r\n      # Connect to Microsoft Graph using managed identity\r\n      Connect-MgGraph -Identity -NoWelcome\r\n\r\n      # Get the service principal (agent identity)\r\n      $sp = Get-MgServicePrincipal -ServicePrincipalId $IdentityPrincipalId -ErrorAction SilentlyContinue\r\n\r\n      if (-not $sp) {\r\n        Write-Error \"Service Principal not found with ID: $IdentityPrincipalId\"\r\n        throw \"Service principal not found\"\r\n      }\r\n\r\n      # Get the associated application\r\n      $app = Get-MgApplication -Filter \"appId eq '$($sp.AppId)'\" -ErrorAction SilentlyContinue\r\n\r\n      if (-not $app) {\r\n        # For agent identities, the federated credential is added to the blueprint, not the agent identity itself\r\n        # Try to get the blueprint application\r\n        Write-Host \"Application not found for service principal. Agent identities inherit credentials from their blueprint.\"\r\n        Write-Host \"Skipping federated credential creation - ensure the blueprint has appropriate credentials configured.\"\r\n        \r\n        $DeploymentScriptOutputs = @{}\r\n        $DeploymentScriptOutputs['status'] = 'skipped'\r\n        $DeploymentScriptOutputs['message'] = 'Agent identities use blueprint credentials'\r\n        return\r\n      }\r\n\r\n      # Check if federated credential already exists\r\n      $existingCreds = Get-MgApplicationFederatedIdentityCredential -ApplicationId $app.Id -ErrorAction SilentlyContinue\r\n      $existingCred = $existingCreds | Where-Object { $_.Name -eq $FederatedCredentialName }\r\n\r\n      if ($existingCred) {\r\n        Write-Host \"Federated credential '$FederatedCredentialName' already exists\"\r\n        $DeploymentScriptOutputs = @{}\r\n        $DeploymentScriptOutputs['status'] = 'exists'\r\n        $DeploymentScriptOutputs['credentialId'] = $existingCred.Id\r\n        return\r\n      }\r\n\r\n      # Create federated identity credential\r\n      $credBody = @{\r\n        name = $FederatedCredentialName\r\n        issuer = $OidcIssuerUrl\r\n        subject = $Subject\r\n        audiences = @('api://AzureADTokenExchange')\r\n        description = \"AKS Workload Identity for MCP Agent\"\r\n      }\r\n\r\n      try {\r\n        $headers = @{\r\n          'OData-Version' = '4.0'\r\n          'Content-Type' = 'application/json'\r\n        }\r\n        \r\n        $newCred = Invoke-MgGraphRequest -Method POST -Uri \"https://graph.microsoft.com/beta/applications/$($app.Id)/federatedIdentityCredentials\" -Body ($credBody | ConvertTo-Json) -Headers $headers\r\n        Write-Host \"Created federated identity credential: $FederatedCredentialName\"\r\n        \r\n        $DeploymentScriptOutputs = @{}\r\n        $DeploymentScriptOutputs['status'] = 'created'\r\n        $DeploymentScriptOutputs['credentialId'] = $newCred.id\r\n      } catch {\r\n        Write-Error \"Failed to create federated identity credential: $_\"\r\n        throw\r\n      }\r\n    "
              },
              "dependsOn": [
                "aksCluster"
              ]
            }
          },
          "outputs": {
            "oidcIssuerUrl": {
              "type": "string",
              "value": "[reference('aksCluster').oidcIssuerProfile.issuerURL]"
            },
            "subjectIdentifier": {
              "type": "string",
              "value": "[parameters('subjectIdentifier')]"
            }
          }
        }
      },
      "dependsOn": [
        "aksCluster",
        "mcpUserAssignedIdentity",
        "nextBestActionAgentIdentity",
        "rg"
      ]
    },
    "storage": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "storage",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "name": "[if(not(empty(parameters('storageAccountName'))), createObject('value', parameters('storageAccountName')), createObject('value', format('{0}{1}', variables('abbrs').storageStorageAccounts, variables('resourceToken'))))]",
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "containers": {
            "value": [
              {
                "name": "[variables('deploymentStorageContainerName')]"
              },
              {
                "name": "snippets"
              }
            ]
          },
          "publicNetworkAccess": "[if(parameters('vnetEnabled'), createObject('value', 'Disabled'), createObject('value', 'Enabled'))]",
          "networkAcls": "[if(not(parameters('vnetEnabled')), createObject('value', createObject()), createObject('value', createObject('defaultAction', 'Deny')))]",
          "allowSharedKeyAccess": {
            "value": true
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "4456596093947429742"
            }
          },
          "parameters": {
            "name": {
              "type": "string"
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]"
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            },
            "allowBlobPublicAccess": {
              "type": "bool",
              "defaultValue": false
            },
            "publicNetworkAccess": {
              "type": "string",
              "defaultValue": "Enabled",
              "allowedValues": [
                "Enabled",
                "Disabled"
              ]
            },
            "containers": {
              "type": "array",
              "defaultValue": []
            },
            "kind": {
              "type": "string",
              "defaultValue": "StorageV2"
            },
            "minimumTlsVersion": {
              "type": "string",
              "defaultValue": "TLS1_2"
            },
            "sku": {
              "type": "object",
              "defaultValue": {
                "name": "Standard_LRS"
              }
            },
            "networkAcls": {
              "type": "object",
              "defaultValue": {
                "bypass": "AzureServices",
                "defaultAction": "Allow"
              }
            },
            "allowSharedKeyAccess": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Controls whether Shared Key authorization is permitted. Leave disabled to enforce managed identity only access."
              }
            }
          },
          "resources": {
            "storage::blobServices::container": {
              "copy": {
                "name": "container",
                "count": "[length(parameters('containers'))]"
              },
              "condition": "[not(empty(parameters('containers')))]",
              "type": "Microsoft.Storage/storageAccounts/blobServices/containers",
              "apiVersion": "2023-01-01",
              "name": "[format('{0}/{1}/{2}', parameters('name'), 'default', parameters('containers')[copyIndex()].name)]",
              "properties": {
                "publicAccess": "[coalesce(tryGet(parameters('containers')[copyIndex()], 'publicAccess'), 'None')]"
              },
              "dependsOn": [
                "storage::blobServices"
              ]
            },
            "storage::blobServices": {
              "condition": "[not(empty(parameters('containers')))]",
              "type": "Microsoft.Storage/storageAccounts/blobServices",
              "apiVersion": "2023-01-01",
              "name": "[format('{0}/{1}', parameters('name'), 'default')]",
              "dependsOn": [
                "storage"
              ]
            },
            "storage": {
              "type": "Microsoft.Storage/storageAccounts",
              "apiVersion": "2023-01-01",
              "name": "[parameters('name')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "kind": "[parameters('kind')]",
              "sku": "[parameters('sku')]",
              "properties": {
                "minimumTlsVersion": "[parameters('minimumTlsVersion')]",
                "allowBlobPublicAccess": "[parameters('allowBlobPublicAccess')]",
                "publicNetworkAccess": "[parameters('publicNetworkAccess')]",
                "allowSharedKeyAccess": "[parameters('allowSharedKeyAccess')]",
                "networkAcls": "[parameters('networkAcls')]"
              }
            }
          },
          "outputs": {
            "name": {
              "type": "string",
              "value": "[parameters('name')]"
            },
            "primaryEndpoints": {
              "type": "object",
              "value": "[reference('storage').primaryEndpoints]"
            }
          }
        }
      },
      "dependsOn": [
        "rg"
      ]
    },
    "blobRoleAssignmentMcp": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "blobRoleAssignmentMcp",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "storageAccountName": {
            "value": "[reference('storage').outputs.name.value]"
          },
          "roleDefinitionID": {
            "value": "[variables('StorageBlobDataOwner')]"
          },
          "principalID": {
            "value": "[reference('mcpUserAssignedIdentity').outputs.identityPrincipalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "13780381521660447827"
            }
          },
          "parameters": {
            "principalID": {
              "type": "string"
            },
            "roleDefinitionID": {
              "type": "string"
            },
            "storageAccountName": {
              "type": "string"
            },
            "nameSuffix": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Optional suffix to make role assignment name unique across deployments"
              }
            }
          },
          "resources": {
            "storageAccount": {
              "existing": true,
              "type": "Microsoft.Storage/storageAccounts",
              "apiVersion": "2021-09-01",
              "name": "[parameters('storageAccountName')]"
            },
            "storageRoleAssignment": {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.Storage/storageAccounts/{0}', parameters('storageAccountName'))]",
              "name": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalId": "[parameters('principalID')]",
                "principalType": "ServicePrincipal"
              },
              "dependsOn": [
                "storageAccount"
              ]
            }
          },
          "outputs": {
            "ROLE_ASSIGNMENT_NAME": {
              "type": "string",
              "value": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]"
            }
          }
        }
      },
      "dependsOn": [
        "mcpUserAssignedIdentity",
        "rg",
        "storage"
      ]
    },
    "queueRoleAssignmentMcp": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "queueRoleAssignmentMcp",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "storageAccountName": {
            "value": "[reference('storage').outputs.name.value]"
          },
          "roleDefinitionID": {
            "value": "[variables('StorageQueueDataContributor')]"
          },
          "principalID": {
            "value": "[reference('mcpUserAssignedIdentity').outputs.identityPrincipalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "13780381521660447827"
            }
          },
          "parameters": {
            "principalID": {
              "type": "string"
            },
            "roleDefinitionID": {
              "type": "string"
            },
            "storageAccountName": {
              "type": "string"
            },
            "nameSuffix": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Optional suffix to make role assignment name unique across deployments"
              }
            }
          },
          "resources": {
            "storageAccount": {
              "existing": true,
              "type": "Microsoft.Storage/storageAccounts",
              "apiVersion": "2021-09-01",
              "name": "[parameters('storageAccountName')]"
            },
            "storageRoleAssignment": {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.Storage/storageAccounts/{0}', parameters('storageAccountName'))]",
              "name": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalId": "[parameters('principalID')]",
                "principalType": "ServicePrincipal"
              },
              "dependsOn": [
                "storageAccount"
              ]
            }
          },
          "outputs": {
            "ROLE_ASSIGNMENT_NAME": {
              "type": "string",
              "value": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]"
            }
          }
        }
      },
      "dependsOn": [
        "mcpUserAssignedIdentity",
        "rg",
        "storage"
      ]
    },
    "serviceVirtualNetwork": {
      "condition": "[parameters('vnetEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "serviceVirtualNetwork",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "vNetName": {
            "value": "[variables('serviceVirtualNetworkName')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "12028796055207520394"
            }
          },
          "parameters": {
            "vNetName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the virtual network."
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Specifies the location."
              }
            },
            "peSubnetName": {
              "type": "string",
              "defaultValue": "private-endpoints-subnet",
              "metadata": {
                "description": "Specifies the name of the subnet for the Service Bus private endpoint."
              }
            },
            "appSubnetName": {
              "type": "string",
              "defaultValue": "app",
              "metadata": {
                "description": "Specifies the name of the subnet for Function App virtual network integration."
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            }
          },
          "resources": {
            "virtualNetwork": {
              "type": "Microsoft.Network/virtualNetworks",
              "apiVersion": "2023-05-01",
              "name": "[parameters('vNetName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "addressSpace": {
                  "addressPrefixes": [
                    "10.0.0.0/16"
                  ]
                },
                "encryption": {
                  "enabled": false,
                  "enforcement": "AllowUnencrypted"
                },
                "subnets": [
                  {
                    "name": "[parameters('peSubnetName')]",
                    "id": "[resourceId('Microsoft.Network/virtualNetworks/subnets', parameters('vNetName'), 'private-endpoints-subnet')]",
                    "properties": {
                      "addressPrefixes": [
                        "10.0.1.0/24"
                      ],
                      "delegations": [],
                      "privateEndpointNetworkPolicies": "Disabled",
                      "privateLinkServiceNetworkPolicies": "Enabled"
                    },
                    "type": "Microsoft.Network/virtualNetworks/subnets"
                  },
                  {
                    "name": "[parameters('appSubnetName')]",
                    "id": "[resourceId('Microsoft.Network/virtualNetworks/subnets', parameters('vNetName'), 'app')]",
                    "properties": {
                      "addressPrefixes": [
                        "10.0.2.0/24"
                      ],
                      "delegations": [],
                      "privateEndpointNetworkPolicies": "Disabled",
                      "privateLinkServiceNetworkPolicies": "Enabled"
                    },
                    "type": "Microsoft.Network/virtualNetworks/subnets"
                  }
                ],
                "virtualNetworkPeerings": [],
                "enableDdosProtection": false
              }
            }
          },
          "outputs": {
            "peSubnetName": {
              "type": "string",
              "value": "[reference('virtualNetwork').subnets[0].name]"
            },
            "peSubnetID": {
              "type": "string",
              "value": "[reference('virtualNetwork').subnets[0].id]"
            },
            "appSubnetName": {
              "type": "string",
              "value": "[reference('virtualNetwork').subnets[1].name]"
            },
            "appSubnetID": {
              "type": "string",
              "value": "[reference('virtualNetwork').subnets[1].id]"
            }
          }
        }
      },
      "dependsOn": [
        "rg"
      ]
    },
    "storagePrivateEndpoint": {
      "condition": "[parameters('vnetEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "servicePrivateEndpoint",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "virtualNetworkName": {
            "value": "[variables('serviceVirtualNetworkName')]"
          },
          "subnetName": "[if(parameters('vnetEnabled'), createObject('value', variables('serviceVirtualNetworkPrivateEndpointSubnetName')), createObject('value', ''))]",
          "resourceName": {
            "value": "[reference('storage').outputs.name.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "1033442020867061602"
            }
          },
          "parameters": {
            "virtualNetworkName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the virtual network."
              }
            },
            "subnetName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the subnet which contains the virtual machine."
              }
            },
            "resourceName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the resource name of the Storage resource with an endpoint."
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Specifies the location."
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            }
          },
          "variables": {
            "blobPrivateDNSZoneName": "[format('privatelink.blob.{0}', environment().suffixes.storage)]",
            "blobPrivateDnsZoneVirtualNetworkLinkName": "[format('{0}-blob-link-{1}', parameters('resourceName'), take(toLower(uniqueString(parameters('resourceName'), parameters('virtualNetworkName'))), 4))]",
            "queuePrivateDNSZoneName": "[format('privatelink.queue.{0}', environment().suffixes.storage)]",
            "queuePrivateDnsZoneVirtualNetworkLinkName": "[format('{0}-queue-link-{1}', parameters('resourceName'), take(toLower(uniqueString(parameters('resourceName'), parameters('virtualNetworkName'))), 4))]"
          },
          "resources": {
            "vnet": {
              "existing": true,
              "type": "Microsoft.Network/virtualNetworks",
              "apiVersion": "2021-08-01",
              "name": "[parameters('virtualNetworkName')]"
            },
            "storageAccount": {
              "existing": true,
              "type": "Microsoft.Storage/storageAccounts",
              "apiVersion": "2021-09-01",
              "name": "[parameters('resourceName')]"
            },
            "blobPrivateDnsZone": {
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2020-06-01",
              "name": "[variables('blobPrivateDNSZoneName')]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {},
              "dependsOn": [
                "vnet"
              ]
            },
            "queuePrivateDnsZone": {
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2020-06-01",
              "name": "[variables('queuePrivateDNSZoneName')]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {},
              "dependsOn": [
                "vnet"
              ]
            },
            "blobPrivateDnsZoneVirtualNetworkLink": {
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('blobPrivateDNSZoneName'), variables('blobPrivateDnsZoneVirtualNetworkLinkName'))]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "blobPrivateDnsZone",
                "vnet"
              ]
            },
            "queuePrivateDnsZoneVirtualNetworkLink": {
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('queuePrivateDNSZoneName'), variables('queuePrivateDnsZoneVirtualNetworkLinkName'))]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "queuePrivateDnsZone",
                "vnet"
              ]
            },
            "blobPrivateEndpoint": {
              "type": "Microsoft.Network/privateEndpoints",
              "apiVersion": "2021-08-01",
              "name": "blob-private-endpoint",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "privateLinkServiceConnections": [
                  {
                    "name": "blobPrivateLinkConnection",
                    "properties": {
                      "privateLinkServiceId": "[resourceId('Microsoft.Storage/storageAccounts', parameters('resourceName'))]",
                      "groupIds": [
                        "blob"
                      ]
                    }
                  }
                ],
                "subnet": {
                  "id": "[format('{0}/subnets/{1}', resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName')), parameters('subnetName'))]"
                }
              },
              "dependsOn": [
                "storageAccount",
                "vnet"
              ]
            },
            "blobPrivateDnsZoneGroupName": {
              "type": "Microsoft.Network/privateEndpoints/privateDnsZoneGroups",
              "apiVersion": "2022-01-01",
              "name": "[format('{0}/{1}', 'blob-private-endpoint', 'blobPrivateDnsZoneGroup')]",
              "properties": {
                "privateDnsZoneConfigs": [
                  {
                    "name": "storageBlobARecord",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('blobPrivateDNSZoneName'))]"
                    }
                  }
                ]
              },
              "dependsOn": [
                "blobPrivateDnsZone",
                "blobPrivateEndpoint"
              ]
            },
            "queuePrivateEndpoint": {
              "type": "Microsoft.Network/privateEndpoints",
              "apiVersion": "2021-08-01",
              "name": "queue-private-endpoint",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "privateLinkServiceConnections": [
                  {
                    "name": "queuePrivateLinkConnection",
                    "properties": {
                      "privateLinkServiceId": "[resourceId('Microsoft.Storage/storageAccounts', parameters('resourceName'))]",
                      "groupIds": [
                        "queue"
                      ]
                    }
                  }
                ],
                "subnet": {
                  "id": "[format('{0}/subnets/{1}', resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName')), parameters('subnetName'))]"
                }
              },
              "dependsOn": [
                "storageAccount",
                "vnet"
              ]
            },
            "queuePrivateDnsZoneGroupName": {
              "type": "Microsoft.Network/privateEndpoints/privateDnsZoneGroups",
              "apiVersion": "2022-01-01",
              "name": "[format('{0}/{1}', 'queue-private-endpoint', 'queuePrivateDnsZoneGroup')]",
              "properties": {
                "privateDnsZoneConfigs": [
                  {
                    "name": "storageQueueARecord",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('queuePrivateDNSZoneName'))]"
                    }
                  }
                ]
              },
              "dependsOn": [
                "queuePrivateDnsZone",
                "queuePrivateEndpoint"
              ]
            }
          }
        }
      },
      "dependsOn": [
        "rg",
        "serviceVirtualNetwork",
        "storage"
      ]
    },
    "foundry": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "foundry",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "foundryName": {
            "value": "[variables('foundryResourceName')]"
          },
          "bingName": {
            "value": "[variables('bingResourceName')]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "modelDeploymentName": {
            "value": "[parameters('foundryModelDeploymentName')]"
          },
          "modelName": {
            "value": "[parameters('foundryModelName')]"
          },
          "modelVersion": {
            "value": "[parameters('foundryModelVersion')]"
          },
          "modelCapacity": {
            "value": "[parameters('foundryModelCapacity')]"
          },
          "embeddingModelDeploymentName": {
            "value": "[parameters('embeddingModelDeploymentName')]"
          },
          "embeddingModelName": {
            "value": "[parameters('embeddingModelName')]"
          },
          "embeddingModelVersion": {
            "value": "[parameters('embeddingModelVersion')]"
          },
          "embeddingModelCapacity": {
            "value": "[parameters('embeddingModelCapacity')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "enablePrivateEndpoint": {
            "value": "[parameters('vnetEnabled')]"
          },
          "publicNetworkAccess": "[if(parameters('vnetEnabled'), createObject('value', 'Disabled'), createObject('value', 'Enabled'))]"
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "1914232862028335702"
            }
          },
          "parameters": {
            "foundryName": {
              "type": "string",
              "metadata": {
                "description": "Name of the foundry resource"
              }
            },
            "bingName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Bing Grounding resource"
              }
            },
            "location": {
              "type": "string",
              "metadata": {
                "description": "Location for all resources"
              }
            },
            "modelDeploymentName": {
              "type": "string",
              "metadata": {
                "description": "Model deployment name"
              }
            },
            "modelName": {
              "type": "string",
              "metadata": {
                "description": "Model name"
              }
            },
            "modelVersion": {
              "type": "string",
              "metadata": {
                "description": "Model version"
              }
            },
            "modelCapacity": {
              "type": "int",
              "metadata": {
                "description": "Model capacity"
              }
            },
            "embeddingModelDeploymentName": {
              "type": "string",
              "defaultValue": "text-embedding-3-large",
              "metadata": {
                "description": "Embedding model deployment name"
              }
            },
            "embeddingModelName": {
              "type": "string",
              "defaultValue": "text-embedding-3-large",
              "metadata": {
                "description": "Embedding model name"
              }
            },
            "embeddingModelVersion": {
              "type": "string",
              "defaultValue": "1",
              "metadata": {
                "description": "Embedding model version"
              }
            },
            "embeddingModelCapacity": {
              "type": "int",
              "defaultValue": 10,
              "metadata": {
                "description": "Embedding model capacity"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for resources"
              }
            },
            "enablePrivateEndpoint": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enable private endpoint"
              }
            },
            "publicNetworkAccess": {
              "type": "string",
              "defaultValue": "Enabled",
              "metadata": {
                "description": "Public network access setting"
              }
            }
          },
          "resources": {
            "bingGrounding": {
              "type": "Microsoft.Bing/accounts",
              "apiVersion": "2020-06-10",
              "name": "[parameters('bingName')]",
              "location": "global",
              "sku": {
                "name": "G1"
              },
              "kind": "Bing.Grounding",
              "properties": {
                "statisticsEnabled": false
              }
            },
            "foundryAccount": {
              "type": "Microsoft.CognitiveServices/accounts",
              "apiVersion": "2025-06-01",
              "name": "[parameters('foundryName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "sku": {
                "name": "S0"
              },
              "kind": "AIServices",
              "identity": {
                "type": "SystemAssigned"
              },
              "properties": {
                "apiProperties": {},
                "customSubDomainName": "[parameters('foundryName')]",
                "networkAcls": {
                  "defaultAction": "[if(parameters('enablePrivateEndpoint'), 'Deny', 'Allow')]",
                  "virtualNetworkRules": [],
                  "ipRules": []
                },
                "allowProjectManagement": true,
                "defaultProject": "proj-default",
                "associatedProjects": [
                  "proj-default"
                ],
                "publicNetworkAccess": "[parameters('publicNetworkAccess')]",
                "disableLocalAuth": true
              }
            },
            "agentsCapabilityHost": {
              "type": "Microsoft.CognitiveServices/accounts/capabilityHosts",
              "apiVersion": "2025-06-01",
              "name": "[format('{0}/{1}', parameters('foundryName'), 'Agents')]",
              "properties": {
                "capabilityHostKind": "Agents"
              },
              "dependsOn": [
                "foundryAccount"
              ]
            },
            "modelDeployment": {
              "type": "Microsoft.CognitiveServices/accounts/deployments",
              "apiVersion": "2025-06-01",
              "name": "[format('{0}/{1}', parameters('foundryName'), parameters('modelDeploymentName'))]",
              "sku": {
                "name": "GlobalStandard",
                "capacity": "[parameters('modelCapacity')]"
              },
              "properties": {
                "model": {
                  "format": "OpenAI",
                  "name": "[parameters('modelName')]",
                  "version": "[parameters('modelVersion')]"
                },
                "versionUpgradeOption": "OnceNewDefaultVersionAvailable",
                "currentCapacity": "[parameters('modelCapacity')]",
                "raiPolicyName": "Microsoft.DefaultV2"
              },
              "dependsOn": [
                "foundryAccount"
              ]
            },
            "embeddingModelDeployment": {
              "type": "Microsoft.CognitiveServices/accounts/deployments",
              "apiVersion": "2025-06-01",
              "name": "[format('{0}/{1}', parameters('foundryName'), parameters('embeddingModelDeploymentName'))]",
              "sku": {
                "name": "Standard",
                "capacity": "[parameters('embeddingModelCapacity')]"
              },
              "properties": {
                "model": {
                  "format": "OpenAI",
                  "name": "[parameters('embeddingModelName')]",
                  "version": "[parameters('embeddingModelVersion')]"
                },
                "versionUpgradeOption": "OnceNewDefaultVersionAvailable",
                "currentCapacity": "[parameters('embeddingModelCapacity')]",
                "raiPolicyName": "Microsoft.DefaultV2"
              },
              "dependsOn": [
                "foundryAccount",
                "modelDeployment"
              ]
            },
            "defaultProject": {
              "type": "Microsoft.CognitiveServices/accounts/projects",
              "apiVersion": "2025-06-01",
              "name": "[format('{0}/{1}', parameters('foundryName'), 'proj-default')]",
              "location": "[parameters('location')]",
              "kind": "AIServices",
              "identity": {
                "type": "SystemAssigned"
              },
              "properties": {
                "description": "Default project for web summarization with Bing grounding",
                "displayName": "proj-default"
              },
              "dependsOn": [
                "foundryAccount"
              ]
            },
            "bingConnection": {
              "type": "Microsoft.CognitiveServices/accounts/projects/connections",
              "apiVersion": "2025-06-01",
              "name": "[format('{0}/{1}/{2}', parameters('foundryName'), 'proj-default', parameters('bingName'))]",
              "properties": {
                "authType": "ApiKey",
                "category": "ApiKey",
                "target": "https://api.bing.microsoft.com/",
                "credentials": {
                  "key": "[listKeys(resourceId('Microsoft.Bing/accounts', parameters('bingName')), '2020-06-10').key1]"
                },
                "useWorkspaceManagedIdentity": false,
                "isSharedToAll": false,
                "sharedUserList": [],
                "peRequirement": "NotRequired",
                "peStatus": "NotApplicable",
                "metadata": {
                  "type": "bing_grounding",
                  "ApiType": "Azure",
                  "ResourceId": "[resourceId('Microsoft.Bing/accounts', parameters('bingName'))]"
                }
              },
              "dependsOn": [
                "bingGrounding",
                "defaultProject"
              ]
            }
          },
          "outputs": {
            "foundryAccountId": {
              "type": "string",
              "value": "[resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryName'))]"
            },
            "foundryAccountName": {
              "type": "string",
              "value": "[parameters('foundryName')]"
            },
            "foundryEndpoint": {
              "type": "string",
              "value": "[reference('foundryAccount').endpoint]"
            },
            "projectId": {
              "type": "string",
              "value": "[resourceId('Microsoft.CognitiveServices/accounts/projects', parameters('foundryName'), 'proj-default')]"
            },
            "projectEndpoint": {
              "type": "string",
              "value": "[format('https://{0}.services.ai.azure.com/api/projects/proj-default', parameters('foundryName'))]"
            },
            "bingConnectionId": {
              "type": "string",
              "value": "[resourceId('Microsoft.CognitiveServices/accounts/projects/connections', parameters('foundryName'), 'proj-default', parameters('bingName'))]"
            },
            "bingConnectionName": {
              "type": "string",
              "value": "[parameters('bingName')]"
            },
            "bingResourceId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Bing/accounts', parameters('bingName'))]"
            },
            "modelDeploymentName": {
              "type": "string",
              "value": "[parameters('modelDeploymentName')]"
            },
            "embeddingModelDeploymentName": {
              "type": "string",
              "value": "[parameters('embeddingModelDeploymentName')]"
            }
          }
        }
      },
      "dependsOn": [
        "rg"
      ]
    },
    "foundryPrivateEndpoint": {
      "condition": "[parameters('vnetEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "foundryPrivateEndpoint",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "virtualNetworkName": {
            "value": "[variables('serviceVirtualNetworkName')]"
          },
          "subnetName": "[if(parameters('vnetEnabled'), createObject('value', variables('serviceVirtualNetworkPrivateEndpointSubnetName')), createObject('value', ''))]",
          "resourceName": {
            "value": "[reference('foundry').outputs.foundryAccountName.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "14459099472993383279"
            }
          },
          "parameters": {
            "virtualNetworkName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the virtual network."
              }
            },
            "subnetName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the subnet which contains the private endpoints."
              }
            },
            "resourceName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the resource name of the Foundry/Cognitive Services resource."
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Specifies the location."
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            }
          },
          "variables": {
            "cognitiveServicesPrivateDNSZoneName": "privatelink.cognitiveservices.azure.com",
            "openAIPrivateDNSZoneName": "privatelink.openai.azure.com",
            "servicesAIPrivateDNSZoneName": "privatelink.services.ai.azure.com",
            "cognitiveServicesDnsZoneLinkName": "[format('{0}-cogservices-link-{1}', parameters('resourceName'), take(toLower(uniqueString(parameters('resourceName'), parameters('virtualNetworkName'))), 4))]",
            "openAIDnsZoneLinkName": "[format('{0}-openai-link-{1}', parameters('resourceName'), take(toLower(uniqueString(parameters('resourceName'), parameters('virtualNetworkName'))), 4))]",
            "servicesAIDnsZoneLinkName": "[format('{0}-servicesai-link-{1}', parameters('resourceName'), take(toLower(uniqueString(parameters('resourceName'), parameters('virtualNetworkName'))), 4))]"
          },
          "resources": {
            "vnet": {
              "existing": true,
              "type": "Microsoft.Network/virtualNetworks",
              "apiVersion": "2021-08-01",
              "name": "[parameters('virtualNetworkName')]"
            },
            "foundryAccount": {
              "existing": true,
              "type": "Microsoft.CognitiveServices/accounts",
              "apiVersion": "2025-06-01",
              "name": "[parameters('resourceName')]"
            },
            "cognitiveServicesPrivateDnsZone": {
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2020-06-01",
              "name": "[variables('cognitiveServicesPrivateDNSZoneName')]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {},
              "dependsOn": [
                "vnet"
              ]
            },
            "openAIPrivateDnsZone": {
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2020-06-01",
              "name": "[variables('openAIPrivateDNSZoneName')]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {},
              "dependsOn": [
                "vnet"
              ]
            },
            "servicesAIPrivateDnsZone": {
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2020-06-01",
              "name": "[variables('servicesAIPrivateDNSZoneName')]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {},
              "dependsOn": [
                "vnet"
              ]
            },
            "cognitiveServicesPrivateDnsZoneVirtualNetworkLink": {
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('cognitiveServicesPrivateDNSZoneName'), variables('cognitiveServicesDnsZoneLinkName'))]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "cognitiveServicesPrivateDnsZone",
                "vnet"
              ]
            },
            "openAIPrivateDnsZoneVirtualNetworkLink": {
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('openAIPrivateDNSZoneName'), variables('openAIDnsZoneLinkName'))]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "openAIPrivateDnsZone",
                "vnet"
              ]
            },
            "servicesAIPrivateDnsZoneVirtualNetworkLink": {
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('servicesAIPrivateDNSZoneName'), variables('servicesAIDnsZoneLinkName'))]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "servicesAIPrivateDnsZone",
                "vnet"
              ]
            },
            "foundryPrivateEndpoint": {
              "type": "Microsoft.Network/privateEndpoints",
              "apiVersion": "2021-08-01",
              "name": "[format('pe-{0}-account', parameters('resourceName'))]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "privateLinkServiceConnections": [
                  {
                    "name": "foundryAccountPrivateLinkConnection",
                    "properties": {
                      "privateLinkServiceId": "[resourceId('Microsoft.CognitiveServices/accounts', parameters('resourceName'))]",
                      "groupIds": [
                        "account"
                      ]
                    }
                  }
                ],
                "subnet": {
                  "id": "[format('{0}/subnets/{1}', resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName')), parameters('subnetName'))]"
                }
              },
              "dependsOn": [
                "foundryAccount",
                "vnet"
              ]
            },
            "foundryPrivateEndpointDnsZoneGroup": {
              "type": "Microsoft.Network/privateEndpoints/privateDnsZoneGroups",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', format('pe-{0}-account', parameters('resourceName')), 'foundryPrivateDnsZoneGroup')]",
              "properties": {
                "privateDnsZoneConfigs": [
                  {
                    "name": "cognitiveservices-config",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('cognitiveServicesPrivateDNSZoneName'))]"
                    }
                  },
                  {
                    "name": "openai-config",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('openAIPrivateDNSZoneName'))]"
                    }
                  },
                  {
                    "name": "servicesai-config",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('servicesAIPrivateDNSZoneName'))]"
                    }
                  }
                ]
              },
              "dependsOn": [
                "cognitiveServicesPrivateDnsZone",
                "foundryPrivateEndpoint",
                "openAIPrivateDnsZone",
                "servicesAIPrivateDnsZone"
              ]
            }
          },
          "outputs": {
            "privateEndpointId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateEndpoints', format('pe-{0}-account', parameters('resourceName')))]"
            },
            "cognitiveServicesPrivateDnsZoneId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateDnsZones', variables('cognitiveServicesPrivateDNSZoneName'))]"
            },
            "openAIPrivateDnsZoneId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateDnsZones', variables('openAIPrivateDNSZoneName'))]"
            },
            "servicesAIPrivateDnsZoneId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateDnsZones', variables('servicesAIPrivateDNSZoneName'))]"
            }
          }
        }
      },
      "dependsOn": [
        "foundry",
        "rg",
        "serviceVirtualNetwork"
      ]
    },
    "foundryRoleAssignmentMcp": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "foundryRoleAssignmentMcp",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "foundryAccountName": {
            "value": "[reference('foundry').outputs.foundryAccountName.value]"
          },
          "roleDefinitionID": {
            "value": "[variables('CognitiveServicesOpenAIUser')]"
          },
          "principalID": {
            "value": "[reference('mcpUserAssignedIdentity').outputs.identityPrincipalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "13595829061267634085"
            }
          },
          "parameters": {
            "foundryAccountName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Foundry/Cognitive Services account"
              }
            },
            "roleDefinitionID": {
              "type": "string",
              "metadata": {
                "description": "The role definition ID to assign"
              }
            },
            "principalID": {
              "type": "string",
              "metadata": {
                "description": "The principal ID to assign the role to"
              }
            },
            "nameSuffix": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Optional suffix to make role assignment name unique across deployments"
              }
            }
          },
          "resources": {
            "foundryAccount": {
              "existing": true,
              "type": "Microsoft.CognitiveServices/accounts",
              "apiVersion": "2025-06-01",
              "name": "[parameters('foundryAccountName')]"
            },
            "roleAssignment": {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.CognitiveServices/accounts/{0}', parameters('foundryAccountName'))]",
              "name": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryAccountName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryAccountName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalId": "[parameters('principalID')]",
                "principalType": "ServicePrincipal"
              },
              "dependsOn": [
                "foundryAccount"
              ]
            }
          }
        }
      },
      "dependsOn": [
        "foundry",
        "mcpUserAssignedIdentity",
        "rg"
      ]
    },
    "foundryRoleAssignmentMcpAIDeveloper": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "foundryRoleAssignmentMcpAIDeveloper",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "foundryAccountName": {
            "value": "[reference('foundry').outputs.foundryAccountName.value]"
          },
          "roleDefinitionID": {
            "value": "[variables('AzureAIDeveloper')]"
          },
          "principalID": {
            "value": "[reference('mcpUserAssignedIdentity').outputs.identityPrincipalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "13595829061267634085"
            }
          },
          "parameters": {
            "foundryAccountName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Foundry/Cognitive Services account"
              }
            },
            "roleDefinitionID": {
              "type": "string",
              "metadata": {
                "description": "The role definition ID to assign"
              }
            },
            "principalID": {
              "type": "string",
              "metadata": {
                "description": "The principal ID to assign the role to"
              }
            },
            "nameSuffix": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Optional suffix to make role assignment name unique across deployments"
              }
            }
          },
          "resources": {
            "foundryAccount": {
              "existing": true,
              "type": "Microsoft.CognitiveServices/accounts",
              "apiVersion": "2025-06-01",
              "name": "[parameters('foundryAccountName')]"
            },
            "roleAssignment": {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.CognitiveServices/accounts/{0}', parameters('foundryAccountName'))]",
              "name": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryAccountName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryAccountName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalId": "[parameters('principalID')]",
                "principalType": "ServicePrincipal"
              },
              "dependsOn": [
                "foundryAccount"
              ]
            }
          }
        }
      },
      "dependsOn": [
        "foundry",
        "mcpUserAssignedIdentity",
        "rg"
      ]
    },
    "cosmosAccount": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "cosmosAccount",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "name": {
            "value": "[variables('cosmosResourceName')]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "enableServerless": {
            "value": true
          },
          "enableVectorSearch": {
            "value": true
          },
          "disableKeyBasedAuth": {
            "value": true
          },
          "ipRules": "[if(not(empty(parameters('developerIpAddress'))), createObject('value', createArray(parameters('developerIpAddress'))), createObject('value', createArray()))]"
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "8119582828444710146"
            },
            "description": "Create an Azure Cosmos DB for NoSQL account."
          },
          "parameters": {
            "name": {
              "type": "string"
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]"
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            },
            "enableServerless": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enables serverless for this account. Defaults to false."
              }
            },
            "disableKeyBasedAuth": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Disables key-based authentication. Defaults to false."
              }
            },
            "enableVectorSearch": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enables vector search for this account. Defaults to false."
              }
            },
            "enableNoSQLFullTextSearch": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enables NoSQL full text search for this account. Defaults to false."
              }
            },
            "ipRules": {
              "type": "array",
              "defaultValue": [],
              "metadata": {
                "description": "IP addresses or CIDR ranges allowed to access the account (for developer access)."
              }
            }
          },
          "resources": {
            "account": {
              "type": "Microsoft.Resources/deployments",
              "apiVersion": "2022-09-01",
              "name": "cosmos-db-nosql-account",
              "properties": {
                "expressionEvaluationOptions": {
                  "scope": "inner"
                },
                "mode": "Incremental",
                "parameters": {
                  "name": {
                    "value": "[parameters('name')]"
                  },
                  "location": {
                    "value": "[parameters('location')]"
                  },
                  "tags": {
                    "value": "[parameters('tags')]"
                  },
                  "kind": {
                    "value": "GlobalDocumentDB"
                  },
                  "enableServerless": {
                    "value": "[parameters('enableServerless')]"
                  },
                  "enableNoSQLVectorSearch": {
                    "value": "[parameters('enableVectorSearch')]"
                  },
                  "enableNoSQLFullTextSearch": {
                    "value": "[parameters('enableNoSQLFullTextSearch')]"
                  },
                  "disableKeyBasedAuth": {
                    "value": "[parameters('disableKeyBasedAuth')]"
                  },
                  "ipRules": {
                    "value": "[parameters('ipRules')]"
                  }
                },
                "template": {
                  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
                  "languageVersion": "2.1-experimental",
                  "contentVersion": "1.0.0.0",
                  "metadata": {
                    "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
                    "_EXPERIMENTAL_FEATURES_ENABLED": [
                      "Extensibility"
                    ],
                    "_generator": {
                      "name": "bicep",
                      "version": "0.28.1.47646",
                      "templateHash": "16177244908006356012"
                    },
                    "description": "Create an Azure Cosmos DB account."
                  },
                  "parameters": {
                    "name": {
                      "type": "string"
                    },
                    "location": {
                      "type": "string",
                      "defaultValue": "[resourceGroup().location]"
                    },
                    "tags": {
                      "type": "object",
                      "defaultValue": {}
                    },
                    "kind": {
                      "type": "string",
                      "defaultValue": "GlobalDocumentDB",
                      "allowedValues": [
                        "GlobalDocumentDB"
                      ],
                      "metadata": {
                        "description": "Sets the kind of account."
                      }
                    },
                    "enableServerless": {
                      "type": "bool",
                      "defaultValue": true,
                      "metadata": {
                        "description": "Enables serverless for this account. Defaults to false."
                      }
                    },
                    "enableNoSQLVectorSearch": {
                      "type": "bool",
                      "defaultValue": false,
                      "metadata": {
                        "description": "Enables NoSQL vector search for this account. Defaults to false."
                      }
                    },
                    "enableNoSQLFullTextSearch": {
                      "type": "bool",
                      "defaultValue": false,
                      "metadata": {
                        "description": "Enables NoSQL full text search for this account. Defaults to false."
                      }
                    },
                    "disableKeyBasedAuth": {
                      "type": "bool",
                      "defaultValue": false,
                      "metadata": {
                        "description": "Disables key-based authentication. Defaults to false."
                      }
                    },
                    "ipRules": {
                      "type": "array",
                      "defaultValue": [],
                      "metadata": {
                        "description": "IP addresses or CIDR ranges allowed to access the account (for developer access)."
                      }
                    }
                  },
                  "resources": {
                    "account": {
                      "type": "Microsoft.DocumentDB/databaseAccounts",
                      "apiVersion": "2024-05-15",
                      "name": "[parameters('name')]",
                      "location": "[parameters('location')]",
                      "tags": "[parameters('tags')]",
                      "kind": "[parameters('kind')]",
                      "properties": {
                        "copy": [
                          {
                            "name": "ipRules",
                            "count": "[length(parameters('ipRules'))]",
                            "input": {
                              "ipAddressOrRange": "[parameters('ipRules')[copyIndex('ipRules')]]"
                            }
                          }
                        ],
                        "consistencyPolicy": {
                          "defaultConsistencyLevel": "Session"
                        },
                        "databaseAccountOfferType": "Standard",
                        "locations": [
                          {
                            "locationName": "[parameters('location')]",
                            "failoverPriority": 0,
                            "isZoneRedundant": false
                          }
                        ],
                        "enableAutomaticFailover": false,
                        "enableMultipleWriteLocations": false,
                        "disableLocalAuth": "[parameters('disableKeyBasedAuth')]",
                        "publicNetworkAccess": "[if(empty(parameters('ipRules')), 'Disabled', 'SecuredByPerimeter')]",
                        "capabilities": "[union(if(parameters('enableServerless'), createArray(createObject('name', 'EnableServerless')), createArray()), if(parameters('enableNoSQLVectorSearch'), createArray(createObject('name', 'EnableNoSQLVectorSearch')), createArray()), if(parameters('enableNoSQLFullTextSearch'), createArray(createObject('name', 'EnableNoSQLFullTextSearch')), createArray()))]"
                      }
                    }
                  },
                  "outputs": {
                    "endpoint": {
                      "type": "string",
                      "value": "[reference('account').documentEndpoint]"
                    },
                    "name": {
                      "type": "string",
                      "value": "[parameters('name')]"
                    }
                  }
                }
              }
            }
          },
          "outputs": {
            "endpoint": {
              "type": "string",
              "value": "[reference('account').outputs.endpoint.value]"
            },
            "name": {
              "type": "string",
              "value": "[reference('account').outputs.name.value]"
            }
          }
        }
      },
      "dependsOn": [
        "rg"
      ]
    },
    "cosmosDatabase": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "cosmosDatabase",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "name": {
            "value": "[parameters('cosmosDatabaseName')]"
          },
          "parentAccountName": {
            "value": "[reference('cosmosAccount').outputs.name.value]"
          },
          "tags": {
            "value": "[variables('tags')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "2653027184754066009"
            },
            "description": "Create an Azure Cosmos DB for NoSQL database."
          },
          "parameters": {
            "name": {
              "type": "string"
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            },
            "parentAccountName": {
              "type": "string",
              "metadata": {
                "description": "Name of the parent Azure Cosmos DB account."
              }
            },
            "setThroughput": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enables throughput setting at this resource level. Defaults to false."
              }
            },
            "autoscale": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enables autoscale. If setThroughput is enabled, defaults to false."
              }
            },
            "throughput": {
              "type": "int",
              "defaultValue": 400,
              "metadata": {
                "description": "The amount of throughput set. If setThroughput is enabled, defaults to 400."
              }
            }
          },
          "variables": {
            "options": "[if(parameters('setThroughput'), if(parameters('autoscale'), createObject('autoscaleSettings', createObject('maxThroughput', parameters('throughput'))), createObject('throughput', parameters('throughput'))), createObject())]"
          },
          "resources": {
            "account": {
              "existing": true,
              "type": "Microsoft.DocumentDB/databaseAccounts",
              "apiVersion": "2024-05-15",
              "name": "[parameters('parentAccountName')]"
            },
            "database": {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}', parameters('parentAccountName'), parameters('name'))]",
              "tags": "[parameters('tags')]",
              "properties": {
                "options": "[variables('options')]",
                "resource": {
                  "id": "[parameters('name')]"
                }
              },
              "dependsOn": [
                "account"
              ]
            }
          },
          "outputs": {
            "name": {
              "type": "string",
              "value": "[parameters('name')]"
            }
          }
        }
      },
      "dependsOn": [
        "cosmosAccount",
        "rg"
      ]
    },
    "cosmosTasksContainer": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "cosmosTasksContainer",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "name": {
            "value": "tasks"
          },
          "parentAccountName": {
            "value": "[reference('cosmosAccount').outputs.name.value]"
          },
          "parentDatabaseName": {
            "value": "[reference('cosmosDatabase').outputs.name.value]"
          },
          "partitionKeyPaths": {
            "value": [
              "/id"
            ]
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "vectorEmbeddingPolicy": {
            "value": {
              "vectorEmbeddings": [
                {
                  "path": "/embedding",
                  "dataType": "float32",
                  "dimensions": 3072,
                  "distanceFunction": "cosine"
                }
              ]
            }
          },
          "indexingPolicy": {
            "value": {
              "automatic": true,
              "indexingMode": "consistent",
              "includedPaths": [
                {
                  "path": "/*"
                }
              ],
              "excludedPaths": [
                {
                  "path": "/embedding/*"
                }
              ],
              "vectorIndexes": [
                {
                  "path": "/embedding",
                  "type": "quantizedFlat"
                }
              ]
            }
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "13930794330651170344"
            },
            "description": "Create an Azure Cosmos DB for NoSQL container."
          },
          "parameters": {
            "name": {
              "type": "string"
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            },
            "parentAccountName": {
              "type": "string",
              "metadata": {
                "description": "Name of the parent Azure Cosmos DB account."
              }
            },
            "parentDatabaseName": {
              "type": "string",
              "metadata": {
                "description": "Name of the parent Azure Cosmos DB database."
              }
            },
            "setThroughput": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enables throughput setting at this resource level. Defaults to true."
              }
            },
            "autoscale": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enables autoscale. If setThroughput is enabled, defaults to false."
              }
            },
            "throughput": {
              "type": "int",
              "defaultValue": 400,
              "metadata": {
                "description": "The amount of throughput set. If setThroughput is enabled, defaults to 400."
              }
            },
            "partitionKeyPaths": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "defaultValue": [
                "/id"
              ],
              "metadata": {
                "description": "List of hierarhical partition key paths. Defaults to an array that only contains /id."
              }
            },
            "indexingPolicy": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Optional custom indexing policy for the container."
              }
            },
            "vectorEmbeddingPolicy": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Optional vector embedding policy for the container."
              }
            },
            "fullTextPolicy": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Optional full text policy for the container."
              }
            }
          },
          "variables": {
            "options": "[if(parameters('setThroughput'), if(parameters('autoscale'), createObject('autoscaleSettings', createObject('maxThroughput', parameters('throughput'))), createObject('throughput', parameters('throughput'))), createObject())]"
          },
          "resources": {
            "account": {
              "existing": true,
              "type": "Microsoft.DocumentDB/databaseAccounts",
              "apiVersion": "2024-05-15",
              "name": "[parameters('parentAccountName')]"
            },
            "database": {
              "existing": true,
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}', parameters('parentAccountName'), parameters('parentDatabaseName'))]",
              "dependsOn": [
                "account"
              ]
            },
            "container": {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases/containers",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}/{2}', parameters('parentAccountName'), parameters('parentDatabaseName'), parameters('name'))]",
              "tags": "[parameters('tags')]",
              "properties": {
                "options": "[variables('options')]",
                "resource": "[union(createObject('id', parameters('name'), 'partitionKey', createObject('paths', parameters('partitionKeyPaths'), 'kind', 'MultiHash', 'version', 2)), if(not(empty(parameters('indexingPolicy'))), createObject('indexingPolicy', parameters('indexingPolicy')), createObject()), if(not(empty(parameters('vectorEmbeddingPolicy'))), createObject('vectorEmbeddingPolicy', parameters('vectorEmbeddingPolicy')), createObject()), if(not(empty(parameters('fullTextPolicy'))), createObject('fullTextPolicy', parameters('fullTextPolicy')), createObject()))]"
              },
              "dependsOn": [
                "database"
              ]
            }
          },
          "outputs": {
            "name": {
              "type": "string",
              "value": "[parameters('name')]"
            }
          }
        }
      },
      "dependsOn": [
        "cosmosAccount",
        "cosmosDatabase",
        "rg"
      ]
    },
    "cosmosPlansContainer": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "cosmosPlansContainer",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "name": {
            "value": "plans"
          },
          "parentAccountName": {
            "value": "[reference('cosmosAccount').outputs.name.value]"
          },
          "parentDatabaseName": {
            "value": "[reference('cosmosDatabase').outputs.name.value]"
          },
          "partitionKeyPaths": {
            "value": [
              "/taskId"
            ]
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "indexingPolicy": {
            "value": {
              "automatic": true,
              "indexingMode": "consistent",
              "includedPaths": [
                {
                  "path": "/*"
                }
              ]
            }
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "13930794330651170344"
            },
            "description": "Create an Azure Cosmos DB for NoSQL container."
          },
          "parameters": {
            "name": {
              "type": "string"
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            },
            "parentAccountName": {
              "type": "string",
              "metadata": {
                "description": "Name of the parent Azure Cosmos DB account."
              }
            },
            "parentDatabaseName": {
              "type": "string",
              "metadata": {
                "description": "Name of the parent Azure Cosmos DB database."
              }
            },
            "setThroughput": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enables throughput setting at this resource level. Defaults to true."
              }
            },
            "autoscale": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enables autoscale. If setThroughput is enabled, defaults to false."
              }
            },
            "throughput": {
              "type": "int",
              "defaultValue": 400,
              "metadata": {
                "description": "The amount of throughput set. If setThroughput is enabled, defaults to 400."
              }
            },
            "partitionKeyPaths": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "defaultValue": [
                "/id"
              ],
              "metadata": {
                "description": "List of hierarhical partition key paths. Defaults to an array that only contains /id."
              }
            },
            "indexingPolicy": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Optional custom indexing policy for the container."
              }
            },
            "vectorEmbeddingPolicy": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Optional vector embedding policy for the container."
              }
            },
            "fullTextPolicy": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Optional full text policy for the container."
              }
            }
          },
          "variables": {
            "options": "[if(parameters('setThroughput'), if(parameters('autoscale'), createObject('autoscaleSettings', createObject('maxThroughput', parameters('throughput'))), createObject('throughput', parameters('throughput'))), createObject())]"
          },
          "resources": {
            "account": {
              "existing": true,
              "type": "Microsoft.DocumentDB/databaseAccounts",
              "apiVersion": "2024-05-15",
              "name": "[parameters('parentAccountName')]"
            },
            "database": {
              "existing": true,
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}', parameters('parentAccountName'), parameters('parentDatabaseName'))]",
              "dependsOn": [
                "account"
              ]
            },
            "container": {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases/containers",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}/{2}', parameters('parentAccountName'), parameters('parentDatabaseName'), parameters('name'))]",
              "tags": "[parameters('tags')]",
              "properties": {
                "options": "[variables('options')]",
                "resource": "[union(createObject('id', parameters('name'), 'partitionKey', createObject('paths', parameters('partitionKeyPaths'), 'kind', 'MultiHash', 'version', 2)), if(not(empty(parameters('indexingPolicy'))), createObject('indexingPolicy', parameters('indexingPolicy')), createObject()), if(not(empty(parameters('vectorEmbeddingPolicy'))), createObject('vectorEmbeddingPolicy', parameters('vectorEmbeddingPolicy')), createObject()), if(not(empty(parameters('fullTextPolicy'))), createObject('fullTextPolicy', parameters('fullTextPolicy')), createObject()))]"
              },
              "dependsOn": [
                "database"
              ]
            }
          },
          "outputs": {
            "name": {
              "type": "string",
              "value": "[parameters('name')]"
            }
          }
        }
      },
      "dependsOn": [
        "cosmosAccount",
        "cosmosDatabase",
        "rg"
      ]
    },
    "cosmosShortTermMemoryContainer": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "cosmosShortTermMemoryContainer",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "name": {
            "value": "short_term_memory"
          },
          "parentAccountName": {
            "value": "[reference('cosmosAccount').outputs.name.value]"
          },
          "parentDatabaseName": {
            "value": "[reference('cosmosDatabase').outputs.name.value]"
          },
          "partitionKeyPaths": {
            "value": [
              "/session_id"
            ]
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "vectorEmbeddingPolicy": {
            "value": {
              "vectorEmbeddings": [
                {
                  "path": "/embedding",
                  "dataType": "float32",
                  "dimensions": 3072,
                  "distanceFunction": "cosine"
                }
              ]
            }
          },
          "indexingPolicy": {
            "value": {
              "automatic": true,
              "indexingMode": "consistent",
              "includedPaths": [
                {
                  "path": "/*"
                }
              ],
              "excludedPaths": [
                {
                  "path": "/embedding/*"
                }
              ],
              "vectorIndexes": [
                {
                  "path": "/embedding",
                  "type": "quantizedFlat"
                }
              ]
            }
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "13930794330651170344"
            },
            "description": "Create an Azure Cosmos DB for NoSQL container."
          },
          "parameters": {
            "name": {
              "type": "string"
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            },
            "parentAccountName": {
              "type": "string",
              "metadata": {
                "description": "Name of the parent Azure Cosmos DB account."
              }
            },
            "parentDatabaseName": {
              "type": "string",
              "metadata": {
                "description": "Name of the parent Azure Cosmos DB database."
              }
            },
            "setThroughput": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enables throughput setting at this resource level. Defaults to true."
              }
            },
            "autoscale": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enables autoscale. If setThroughput is enabled, defaults to false."
              }
            },
            "throughput": {
              "type": "int",
              "defaultValue": 400,
              "metadata": {
                "description": "The amount of throughput set. If setThroughput is enabled, defaults to 400."
              }
            },
            "partitionKeyPaths": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "defaultValue": [
                "/id"
              ],
              "metadata": {
                "description": "List of hierarhical partition key paths. Defaults to an array that only contains /id."
              }
            },
            "indexingPolicy": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Optional custom indexing policy for the container."
              }
            },
            "vectorEmbeddingPolicy": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Optional vector embedding policy for the container."
              }
            },
            "fullTextPolicy": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Optional full text policy for the container."
              }
            }
          },
          "variables": {
            "options": "[if(parameters('setThroughput'), if(parameters('autoscale'), createObject('autoscaleSettings', createObject('maxThroughput', parameters('throughput'))), createObject('throughput', parameters('throughput'))), createObject())]"
          },
          "resources": {
            "account": {
              "existing": true,
              "type": "Microsoft.DocumentDB/databaseAccounts",
              "apiVersion": "2024-05-15",
              "name": "[parameters('parentAccountName')]"
            },
            "database": {
              "existing": true,
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}', parameters('parentAccountName'), parameters('parentDatabaseName'))]",
              "dependsOn": [
                "account"
              ]
            },
            "container": {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases/containers",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}/{2}', parameters('parentAccountName'), parameters('parentDatabaseName'), parameters('name'))]",
              "tags": "[parameters('tags')]",
              "properties": {
                "options": "[variables('options')]",
                "resource": "[union(createObject('id', parameters('name'), 'partitionKey', createObject('paths', parameters('partitionKeyPaths'), 'kind', 'MultiHash', 'version', 2)), if(not(empty(parameters('indexingPolicy'))), createObject('indexingPolicy', parameters('indexingPolicy')), createObject()), if(not(empty(parameters('vectorEmbeddingPolicy'))), createObject('vectorEmbeddingPolicy', parameters('vectorEmbeddingPolicy')), createObject()), if(not(empty(parameters('fullTextPolicy'))), createObject('fullTextPolicy', parameters('fullTextPolicy')), createObject()))]"
              },
              "dependsOn": [
                "database"
              ]
            }
          },
          "outputs": {
            "name": {
              "type": "string",
              "value": "[parameters('name')]"
            }
          }
        }
      },
      "dependsOn": [
        "cosmosAccount",
        "cosmosDatabase",
        "rg"
      ]
    },
    "lightningCosmos": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "lightningCosmos",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "parentAccountName": {
            "value": "[reference('cosmosAccount').outputs.name.value]"
          },
          "databaseName": {
            "value": "agent_rl"
          },
          "tags": {
            "value": "[variables('tags')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "10233618705548034247"
            }
          },
          "parameters": {
            "parentAccountName": {
              "type": "string",
              "metadata": {
                "description": "Name of the parent Azure Cosmos DB account."
              }
            },
            "databaseName": {
              "type": "string",
              "defaultValue": "agent_rl",
              "metadata": {
                "description": "Name of the Lightning database (default: agent_rl)."
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for all resources."
              }
            }
          },
          "resources": {
            "account": {
              "existing": true,
              "type": "Microsoft.DocumentDB/databaseAccounts",
              "apiVersion": "2024-05-15",
              "name": "[parameters('parentAccountName')]"
            },
            "lightningDatabase": {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}', parameters('parentAccountName'), parameters('databaseName'))]",
              "tags": "[parameters('tags')]",
              "properties": {
                "resource": {
                  "id": "[parameters('databaseName')]"
                }
              },
              "dependsOn": [
                "account"
              ]
            },
            "episodesContainer": {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases/containers",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}/{2}', parameters('parentAccountName'), parameters('databaseName'), 'rl_episodes')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "resource": {
                  "id": "rl_episodes",
                  "partitionKey": {
                    "paths": [
                      "/agent_id"
                    ],
                    "kind": "Hash",
                    "version": 2
                  },
                  "indexingPolicy": {
                    "automatic": true,
                    "indexingMode": "consistent",
                    "includedPaths": [
                      {
                        "path": "/*"
                      }
                    ],
                    "excludedPaths": [
                      {
                        "path": "/\"_etag\"/?"
                      }
                    ]
                  },
                  "defaultTtl": -1
                }
              },
              "dependsOn": [
                "lightningDatabase"
              ]
            },
            "rewardsContainer": {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases/containers",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}/{2}', parameters('parentAccountName'), parameters('databaseName'), 'rl_rewards')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "resource": {
                  "id": "rl_rewards",
                  "partitionKey": {
                    "paths": [
                      "/agent_id"
                    ],
                    "kind": "Hash",
                    "version": 2
                  },
                  "indexingPolicy": {
                    "automatic": true,
                    "indexingMode": "consistent",
                    "includedPaths": [
                      {
                        "path": "/*"
                      }
                    ],
                    "excludedPaths": [
                      {
                        "path": "/\"_etag\"/?"
                      }
                    ]
                  }
                }
              },
              "dependsOn": [
                "lightningDatabase"
              ]
            },
            "datasetsContainer": {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases/containers",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}/{2}', parameters('parentAccountName'), parameters('databaseName'), 'rl_datasets')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "resource": {
                  "id": "rl_datasets",
                  "partitionKey": {
                    "paths": [
                      "/agent_id"
                    ],
                    "kind": "Hash",
                    "version": 2
                  },
                  "indexingPolicy": {
                    "automatic": true,
                    "indexingMode": "consistent",
                    "includedPaths": [
                      {
                        "path": "/*"
                      }
                    ],
                    "excludedPaths": [
                      {
                        "path": "/\"_etag\"/?"
                      }
                    ]
                  }
                }
              },
              "dependsOn": [
                "lightningDatabase"
              ]
            },
            "trainingRunsContainer": {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases/containers",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}/{2}', parameters('parentAccountName'), parameters('databaseName'), 'rl_training_runs')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "resource": {
                  "id": "rl_training_runs",
                  "partitionKey": {
                    "paths": [
                      "/agent_id"
                    ],
                    "kind": "Hash",
                    "version": 2
                  },
                  "indexingPolicy": {
                    "automatic": true,
                    "indexingMode": "consistent",
                    "includedPaths": [
                      {
                        "path": "/*"
                      }
                    ],
                    "excludedPaths": [
                      {
                        "path": "/\"_etag\"/?"
                      }
                    ]
                  }
                }
              },
              "dependsOn": [
                "lightningDatabase"
              ]
            },
            "deploymentsContainer": {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases/containers",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}/{2}', parameters('parentAccountName'), parameters('databaseName'), 'rl_deployments')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "resource": {
                  "id": "rl_deployments",
                  "partitionKey": {
                    "paths": [
                      "/agent_id"
                    ],
                    "kind": "Hash",
                    "version": 2
                  },
                  "indexingPolicy": {
                    "automatic": true,
                    "indexingMode": "consistent",
                    "includedPaths": [
                      {
                        "path": "/*"
                      }
                    ],
                    "excludedPaths": [
                      {
                        "path": "/\"_etag\"/?"
                      }
                    ]
                  }
                }
              },
              "dependsOn": [
                "lightningDatabase"
              ]
            }
          },
          "outputs": {
            "databaseName": {
              "type": "string",
              "value": "[parameters('databaseName')]"
            },
            "episodesContainerName": {
              "type": "string",
              "value": "rl_episodes"
            },
            "rewardsContainerName": {
              "type": "string",
              "value": "rl_rewards"
            },
            "datasetsContainerName": {
              "type": "string",
              "value": "rl_datasets"
            },
            "trainingRunsContainerName": {
              "type": "string",
              "value": "rl_training_runs"
            },
            "deploymentsContainerName": {
              "type": "string",
              "value": "rl_deployments"
            }
          }
        }
      },
      "dependsOn": [
        "cosmosAccount",
        "rg"
      ]
    },
    "cosmosPrivateEndpoint": {
      "condition": "[parameters('vnetEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "cosmosPrivateEndpoint",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "virtualNetworkName": {
            "value": "[variables('serviceVirtualNetworkName')]"
          },
          "subnetName": "[if(parameters('vnetEnabled'), createObject('value', variables('serviceVirtualNetworkPrivateEndpointSubnetName')), createObject('value', ''))]",
          "resourceName": {
            "value": "[reference('cosmosAccount').outputs.name.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "11410551698247569045"
            }
          },
          "parameters": {
            "virtualNetworkName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the virtual network."
              }
            },
            "subnetName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the subnet which contains the private endpoints."
              }
            },
            "resourceName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the resource name of the Cosmos DB account."
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Specifies the location."
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            }
          },
          "variables": {
            "cosmosPrivateDNSZoneName": "privatelink.documents.azure.com",
            "cosmosPrivateDnsZoneVirtualNetworkLinkName": "[format('{0}-cosmos-link-{1}', parameters('resourceName'), take(toLower(uniqueString(parameters('resourceName'), parameters('virtualNetworkName'))), 4))]"
          },
          "resources": {
            "vnet": {
              "existing": true,
              "type": "Microsoft.Network/virtualNetworks",
              "apiVersion": "2021-08-01",
              "name": "[parameters('virtualNetworkName')]"
            },
            "cosmosDbAccount": {
              "existing": true,
              "type": "Microsoft.DocumentDB/databaseAccounts",
              "apiVersion": "2024-05-15",
              "name": "[parameters('resourceName')]"
            },
            "cosmosPrivateDnsZone": {
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2020-06-01",
              "name": "[variables('cosmosPrivateDNSZoneName')]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {},
              "dependsOn": [
                "vnet"
              ]
            },
            "cosmosPrivateDnsZoneVirtualNetworkLink": {
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('cosmosPrivateDNSZoneName'), variables('cosmosPrivateDnsZoneVirtualNetworkLinkName'))]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "cosmosPrivateDnsZone",
                "vnet"
              ]
            },
            "cosmosPrivateEndpoint": {
              "type": "Microsoft.Network/privateEndpoints",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}-cosmos-private-endpoint', parameters('resourceName'))]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "privateLinkServiceConnections": [
                  {
                    "name": "cosmosPrivateLinkConnection",
                    "properties": {
                      "privateLinkServiceId": "[resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('resourceName'))]",
                      "groupIds": [
                        "Sql"
                      ]
                    }
                  }
                ],
                "subnet": {
                  "id": "[format('{0}/subnets/{1}', resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName')), parameters('subnetName'))]"
                }
              },
              "dependsOn": [
                "cosmosDbAccount",
                "vnet"
              ]
            },
            "cosmosPrivateDnsZoneGroup": {
              "type": "Microsoft.Network/privateEndpoints/privateDnsZoneGroups",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', format('{0}-cosmos-private-endpoint', parameters('resourceName')), 'cosmosPrivateDnsZoneGroup')]",
              "properties": {
                "privateDnsZoneConfigs": [
                  {
                    "name": "config1",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('cosmosPrivateDNSZoneName'))]"
                    }
                  }
                ]
              },
              "dependsOn": [
                "cosmosPrivateDnsZone",
                "cosmosPrivateEndpoint"
              ]
            }
          },
          "outputs": {
            "privateEndpointId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateEndpoints', format('{0}-cosmos-private-endpoint', parameters('resourceName')))]"
            },
            "privateDnsZoneId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateDnsZones', variables('cosmosPrivateDNSZoneName'))]"
            }
          }
        }
      },
      "dependsOn": [
        "cosmosAccount",
        "rg",
        "serviceVirtualNetwork"
      ]
    },
    "cosmosRoleAssignmentMcp": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "cosmosRoleAssignmentMcp",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "cosmosAccountName": {
            "value": "[reference('cosmosAccount').outputs.name.value]"
          },
          "roleDefinitionID": {
            "value": "[variables('CosmosDBDataContributor')]"
          },
          "principalID": {
            "value": "[reference('mcpUserAssignedIdentity').outputs.identityPrincipalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "3777928649650282036"
            }
          },
          "parameters": {
            "cosmosAccountName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Cosmos DB account."
              }
            },
            "roleDefinitionID": {
              "type": "string",
              "metadata": {
                "description": "Role definition ID to assign."
              }
            },
            "principalID": {
              "type": "string",
              "metadata": {
                "description": "Principal ID to assign the role to."
              }
            },
            "principalType": {
              "type": "string",
              "defaultValue": "ServicePrincipal",
              "metadata": {
                "description": "Principal type: User, Group, or ServicePrincipal."
              }
            }
          },
          "resources": {
            "cosmosAccount": {
              "existing": true,
              "type": "Microsoft.DocumentDB/databaseAccounts",
              "apiVersion": "2024-05-15",
              "name": "[parameters('cosmosAccountName')]"
            },
            "cosmosRoleAssignment": {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlRoleAssignments",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}', parameters('cosmosAccountName'), guid(resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName')), parameters('principalID'), parameters('roleDefinitionID')))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[format('{0}/sqlRoleDefinitions/{1}', resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName')), parameters('roleDefinitionID'))]",
                "scope": "[resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName'))]"
              },
              "dependsOn": [
                "cosmosAccount"
              ]
            }
          },
          "outputs": {
            "roleAssignmentId": {
              "type": "string",
              "value": "[resourceId('Microsoft.DocumentDB/databaseAccounts/sqlRoleAssignments', parameters('cosmosAccountName'), guid(resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName')), parameters('principalID'), parameters('roleDefinitionID')))]"
            }
          }
        }
      },
      "dependsOn": [
        "cosmosAccount",
        "mcpUserAssignedIdentity",
        "rg"
      ]
    },
    "cosmosRoleAssignmentDeveloper": {
      "condition": "[not(empty(parameters('developerPrincipalId')))]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "cosmosRoleAssignmentDeveloper",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "cosmosAccountName": {
            "value": "[reference('cosmosAccount').outputs.name.value]"
          },
          "roleDefinitionID": {
            "value": "[variables('CosmosDBDataContributor')]"
          },
          "principalID": {
            "value": "[parameters('developerPrincipalId')]"
          },
          "principalType": {
            "value": "User"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "3777928649650282036"
            }
          },
          "parameters": {
            "cosmosAccountName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Cosmos DB account."
              }
            },
            "roleDefinitionID": {
              "type": "string",
              "metadata": {
                "description": "Role definition ID to assign."
              }
            },
            "principalID": {
              "type": "string",
              "metadata": {
                "description": "Principal ID to assign the role to."
              }
            },
            "principalType": {
              "type": "string",
              "defaultValue": "ServicePrincipal",
              "metadata": {
                "description": "Principal type: User, Group, or ServicePrincipal."
              }
            }
          },
          "resources": {
            "cosmosAccount": {
              "existing": true,
              "type": "Microsoft.DocumentDB/databaseAccounts",
              "apiVersion": "2024-05-15",
              "name": "[parameters('cosmosAccountName')]"
            },
            "cosmosRoleAssignment": {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlRoleAssignments",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}', parameters('cosmosAccountName'), guid(resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName')), parameters('principalID'), parameters('roleDefinitionID')))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[format('{0}/sqlRoleDefinitions/{1}', resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName')), parameters('roleDefinitionID'))]",
                "scope": "[resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName'))]"
              },
              "dependsOn": [
                "cosmosAccount"
              ]
            }
          },
          "outputs": {
            "roleAssignmentId": {
              "type": "string",
              "value": "[resourceId('Microsoft.DocumentDB/databaseAccounts/sqlRoleAssignments', parameters('cosmosAccountName'), guid(resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName')), parameters('principalID'), parameters('roleDefinitionID')))]"
            }
          }
        }
      },
      "dependsOn": [
        "cosmosAccount",
        "rg"
      ]
    },
    "searchService": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "searchService",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "name": {
            "value": "[variables('searchResourceName')]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "sku": {
            "value": "basic"
          },
          "replicaCount": {
            "value": 1
          },
          "partitionCount": {
            "value": 1
          },
          "semanticSearch": {
            "value": "standard"
          },
          "publicNetworkAccess": "[if(parameters('vnetEnabled'), createObject('value', 'Disabled'), createObject('value', 'Enabled'))]",
          "disableLocalAuth": {
            "value": true
          },
          "enablePrivateEndpoint": {
            "value": "[parameters('vnetEnabled')]"
          },
          "virtualNetworkName": "[if(parameters('vnetEnabled'), createObject('value', variables('serviceVirtualNetworkName')), createObject('value', ''))]",
          "subnetName": "[if(parameters('vnetEnabled'), createObject('value', variables('serviceVirtualNetworkPrivateEndpointSubnetName')), createObject('value', ''))]"
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "1766752601647578087"
            }
          },
          "parameters": {
            "name": {
              "type": "string",
              "metadata": {
                "description": "Name of the Azure AI Search service"
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Location for the resource"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for the resource"
              }
            },
            "sku": {
              "type": "string",
              "defaultValue": "basic",
              "allowedValues": [
                "basic",
                "standard",
                "standard2",
                "standard3"
              ],
              "metadata": {
                "description": "SKU for the search service"
              }
            },
            "replicaCount": {
              "type": "int",
              "defaultValue": 1,
              "minValue": 1,
              "maxValue": 12,
              "metadata": {
                "description": "Number of replicas (1-12 for standard, 1-3 for basic)"
              }
            },
            "partitionCount": {
              "type": "int",
              "defaultValue": 1,
              "allowedValues": [
                1,
                2,
                3,
                4,
                6,
                12
              ],
              "metadata": {
                "description": "Number of partitions (1, 2, 3, 4, 6, or 12)"
              }
            },
            "semanticSearch": {
              "type": "string",
              "defaultValue": "standard",
              "allowedValues": [
                "disabled",
                "free",
                "standard"
              ],
              "metadata": {
                "description": "Enable semantic search capability"
              }
            },
            "publicNetworkAccess": {
              "type": "string",
              "defaultValue": "Enabled",
              "allowedValues": [
                "Enabled",
                "Disabled"
              ],
              "metadata": {
                "description": "Public network access setting"
              }
            },
            "disableLocalAuth": {
              "type": "bool",
              "defaultValue": true,
              "metadata": {
                "description": "Disable local authentication (API keys)"
              }
            },
            "enablePrivateEndpoint": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enable private endpoint"
              }
            },
            "virtualNetworkName": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Virtual network name for private endpoint"
              }
            },
            "subnetName": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Subnet name for private endpoint"
              }
            }
          },
          "resources": {
            "searchService": {
              "type": "Microsoft.Search/searchServices",
              "apiVersion": "2024-06-01-preview",
              "name": "[parameters('name')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "identity": {
                "type": "SystemAssigned"
              },
              "sku": {
                "name": "[parameters('sku')]"
              },
              "properties": {
                "replicaCount": "[parameters('replicaCount')]",
                "partitionCount": "[parameters('partitionCount')]",
                "hostingMode": "default",
                "publicNetworkAccess": "[parameters('publicNetworkAccess')]",
                "networkRuleSet": {
                  "bypass": "AzurePortal"
                },
                "disableLocalAuth": "[parameters('disableLocalAuth')]",
                "authOptions": "[if(parameters('disableLocalAuth'), null(), createObject('aadOrApiKey', createObject('aadAuthFailureMode', 'http401WithBearerChallenge')))]",
                "semanticSearch": "[parameters('semanticSearch')]"
              }
            },
            "privateDnsZone": {
              "condition": "[parameters('enablePrivateEndpoint')]",
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2024-06-01",
              "name": "privatelink.search.windows.net",
              "location": "global",
              "tags": "[parameters('tags')]"
            },
            "privateDnsZoneLink": {
              "condition": "[and(parameters('enablePrivateEndpoint'), not(empty(parameters('virtualNetworkName'))))]",
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2024-06-01",
              "name": "[format('{0}/{1}', 'privatelink.search.windows.net', format('{0}-dns-link', parameters('name')))]",
              "location": "global",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "privateDnsZone"
              ]
            },
            "privateEndpoint": {
              "condition": "[and(and(parameters('enablePrivateEndpoint'), not(empty(parameters('virtualNetworkName')))), not(empty(parameters('subnetName'))))]",
              "type": "Microsoft.Network/privateEndpoints",
              "apiVersion": "2024-05-01",
              "name": "[format('{0}-pe', parameters('name'))]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "subnet": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks/subnets', parameters('virtualNetworkName'), parameters('subnetName'))]"
                },
                "privateLinkServiceConnections": [
                  {
                    "name": "[format('{0}-psc', parameters('name'))]",
                    "properties": {
                      "privateLinkServiceId": "[resourceId('Microsoft.Search/searchServices', parameters('name'))]",
                      "groupIds": [
                        "searchService"
                      ]
                    }
                  }
                ]
              },
              "dependsOn": [
                "searchService"
              ]
            },
            "privateDnsZoneGroup": {
              "condition": "[parameters('enablePrivateEndpoint')]",
              "type": "Microsoft.Network/privateEndpoints/privateDnsZoneGroups",
              "apiVersion": "2024-05-01",
              "name": "[format('{0}/{1}', format('{0}-pe', parameters('name')), 'default')]",
              "properties": {
                "privateDnsZoneConfigs": [
                  {
                    "name": "privatelink-search-windows-net",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', 'privatelink.search.windows.net')]"
                    }
                  }
                ]
              },
              "dependsOn": [
                "privateDnsZone",
                "privateEndpoint"
              ]
            }
          },
          "outputs": {
            "name": {
              "type": "string",
              "value": "[parameters('name')]"
            },
            "endpoint": {
              "type": "string",
              "value": "[format('https://{0}.search.windows.net', parameters('name'))]"
            },
            "principalId": {
              "type": "string",
              "value": "[reference('searchService', '2024-06-01-preview', 'full').identity.principalId]"
            },
            "resourceId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Search/searchServices', parameters('name'))]"
            }
          }
        }
      },
      "dependsOn": [
        "rg",
        "serviceVirtualNetwork"
      ]
    },
    "searchRoleAssignmentMcp": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "searchRoleAssignmentMcp",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "searchServiceName": {
            "value": "[reference('searchService').outputs.name.value]"
          },
          "roleDefinitionID": {
            "value": "[variables('SearchIndexDataContributor')]"
          },
          "principalID": {
            "value": "[reference('mcpUserAssignedIdentity').outputs.identityPrincipalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "18042041442813590893"
            }
          },
          "parameters": {
            "searchServiceName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Azure AI Search service"
              }
            },
            "roleDefinitionID": {
              "type": "string",
              "metadata": {
                "description": "Role Definition ID to assign"
              }
            },
            "principalID": {
              "type": "string",
              "metadata": {
                "description": "Principal ID to assign the role to"
              }
            },
            "principalType": {
              "type": "string",
              "defaultValue": "ServicePrincipal",
              "allowedValues": [
                "ServicePrincipal",
                "User",
                "Group"
              ],
              "metadata": {
                "description": "Principal type (ServicePrincipal, User, Group)"
              }
            },
            "nameSuffix": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Optional suffix to make role assignment name unique across deployments"
              }
            }
          },
          "resources": {
            "searchService": {
              "existing": true,
              "type": "Microsoft.Search/searchServices",
              "apiVersion": "2024-06-01-preview",
              "name": "[parameters('searchServiceName')]"
            },
            "roleAssignment": {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.Search/searchServices/{0}', parameters('searchServiceName'))]",
              "name": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalId": "[parameters('principalID')]",
                "principalType": "[parameters('principalType')]"
              },
              "dependsOn": [
                "searchService"
              ]
            }
          },
          "outputs": {
            "roleAssignmentId": {
              "type": "string",
              "value": "[extensionResourceId(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), 'Microsoft.Authorization/roleAssignments', if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix'))))]"
            }
          }
        }
      },
      "dependsOn": [
        "mcpUserAssignedIdentity",
        "rg",
        "searchService"
      ]
    },
    "searchServiceRoleAssignmentMcp": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "searchServiceRoleAssignmentMcp",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "searchServiceName": {
            "value": "[reference('searchService').outputs.name.value]"
          },
          "roleDefinitionID": {
            "value": "[variables('SearchServiceContributor')]"
          },
          "principalID": {
            "value": "[reference('mcpUserAssignedIdentity').outputs.identityPrincipalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "18042041442813590893"
            }
          },
          "parameters": {
            "searchServiceName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Azure AI Search service"
              }
            },
            "roleDefinitionID": {
              "type": "string",
              "metadata": {
                "description": "Role Definition ID to assign"
              }
            },
            "principalID": {
              "type": "string",
              "metadata": {
                "description": "Principal ID to assign the role to"
              }
            },
            "principalType": {
              "type": "string",
              "defaultValue": "ServicePrincipal",
              "allowedValues": [
                "ServicePrincipal",
                "User",
                "Group"
              ],
              "metadata": {
                "description": "Principal type (ServicePrincipal, User, Group)"
              }
            },
            "nameSuffix": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Optional suffix to make role assignment name unique across deployments"
              }
            }
          },
          "resources": {
            "searchService": {
              "existing": true,
              "type": "Microsoft.Search/searchServices",
              "apiVersion": "2024-06-01-preview",
              "name": "[parameters('searchServiceName')]"
            },
            "roleAssignment": {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.Search/searchServices/{0}', parameters('searchServiceName'))]",
              "name": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalId": "[parameters('principalID')]",
                "principalType": "[parameters('principalType')]"
              },
              "dependsOn": [
                "searchService"
              ]
            }
          },
          "outputs": {
            "roleAssignmentId": {
              "type": "string",
              "value": "[extensionResourceId(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), 'Microsoft.Authorization/roleAssignments', if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix'))))]"
            }
          }
        }
      },
      "dependsOn": [
        "mcpUserAssignedIdentity",
        "rg",
        "searchService"
      ]
    },
    "fabricCapacity": {
      "condition": "[parameters('fabricEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "fabricCapacity",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "name": {
            "value": "[variables('fabricResourceName')]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "skuName": {
            "value": "[parameters('fabricSkuName')]"
          },
          "adminMembers": "[if(not(empty(parameters('fabricAdminEmail'))), createObject('value', createArray(parameters('fabricAdminEmail'))), createObject('value', createArray()))]"
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "17500370237378285734"
            }
          },
          "parameters": {
            "name": {
              "type": "string",
              "metadata": {
                "description": "Name of the Fabric capacity"
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Location for the Fabric capacity"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for the Fabric capacity"
              }
            },
            "skuName": {
              "type": "string",
              "defaultValue": "F2",
              "allowedValues": [
                "F2",
                "F4",
                "F8",
                "F16",
                "F32",
                "F64",
                "F128",
                "F256",
                "F512",
                "F1024",
                "F2048"
              ],
              "metadata": {
                "description": "SKU name for the Fabric capacity (F2, F4, F8, F16, F32, F64, F128, F256, F512, F1024, F2048)"
              }
            },
            "adminMembers": {
              "type": "array",
              "metadata": {
                "description": "List of admin members (email addresses) for the Fabric capacity"
              }
            }
          },
          "resources": {
            "fabricCapacity": {
              "type": "Microsoft.Fabric/capacities",
              "apiVersion": "2023-11-01",
              "name": "[parameters('name')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "sku": {
                "name": "[parameters('skuName')]",
                "tier": "Fabric"
              },
              "properties": {
                "administration": {
                  "members": "[parameters('adminMembers')]"
                }
              }
            }
          },
          "outputs": {
            "id": {
              "type": "string",
              "value": "[resourceId('Microsoft.Fabric/capacities', parameters('name'))]"
            },
            "name": {
              "type": "string",
              "value": "[parameters('name')]"
            },
            "state": {
              "type": "string",
              "value": "[reference('fabricCapacity').state]"
            }
          }
        }
      },
      "dependsOn": [
        "rg"
      ]
    },
    "fabricPrivateEndpoint": {
      "condition": "[and(parameters('fabricEnabled'), parameters('vnetEnabled'))]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "fabricPrivateEndpoint",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "virtualNetworkName": {
            "value": "[variables('serviceVirtualNetworkName')]"
          },
          "subnetName": "[if(parameters('vnetEnabled'), createObject('value', variables('serviceVirtualNetworkPrivateEndpointSubnetName')), createObject('value', ''))]",
          "fabricCapacityId": {
            "value": "[reference('fabricCapacity').outputs.id.value]"
          },
          "fabricCapacityName": {
            "value": "[variables('fabricResourceName')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "13868351273422984503"
            }
          },
          "parameters": {
            "virtualNetworkName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the virtual network."
              }
            },
            "subnetName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the subnet which contains the private endpoints."
              }
            },
            "fabricCapacityId": {
              "type": "string",
              "metadata": {
                "description": "Specifies the resource ID of the Fabric capacity."
              }
            },
            "fabricCapacityName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the Fabric capacity (for naming conventions)."
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Specifies the location."
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for all resources."
              }
            }
          },
          "variables": {
            "fabricDfsPrivateDNSZoneName": "privatelink.dfs.fabric.microsoft.com",
            "fabricBlobPrivateDNSZoneName": "privatelink.blob.fabric.microsoft.com",
            "fabricApiPrivateDNSZoneName": "privatelink.api.fabric.microsoft.com",
            "onelakeDfsPrivateDNSZoneName": "[format('privatelink.dfs.{0}', environment().suffixes.storage)]",
            "fabricDfsDnsZoneLinkName": "[format('{0}-fabric-dfs-link-{1}', parameters('fabricCapacityName'), take(toLower(uniqueString(parameters('fabricCapacityName'), parameters('virtualNetworkName'))), 4))]",
            "fabricBlobDnsZoneLinkName": "[format('{0}-fabric-blob-link-{1}', parameters('fabricCapacityName'), take(toLower(uniqueString(parameters('fabricCapacityName'), parameters('virtualNetworkName'))), 4))]",
            "fabricApiDnsZoneLinkName": "[format('{0}-fabric-api-link-{1}', parameters('fabricCapacityName'), take(toLower(uniqueString(parameters('fabricCapacityName'), parameters('virtualNetworkName'))), 4))]",
            "onelakeDfsDnsZoneLinkName": "[format('{0}-onelake-dfs-link-{1}', parameters('fabricCapacityName'), take(toLower(uniqueString(parameters('fabricCapacityName'), parameters('virtualNetworkName'))), 4))]"
          },
          "resources": {
            "vnet": {
              "existing": true,
              "type": "Microsoft.Network/virtualNetworks",
              "apiVersion": "2021-08-01",
              "name": "[parameters('virtualNetworkName')]"
            },
            "fabricDfsPrivateDnsZone": {
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2020-06-01",
              "name": "[variables('fabricDfsPrivateDNSZoneName')]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {},
              "dependsOn": [
                "vnet"
              ]
            },
            "fabricBlobPrivateDnsZone": {
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2020-06-01",
              "name": "[variables('fabricBlobPrivateDNSZoneName')]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {},
              "dependsOn": [
                "vnet"
              ]
            },
            "fabricApiPrivateDnsZone": {
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2020-06-01",
              "name": "[variables('fabricApiPrivateDNSZoneName')]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {},
              "dependsOn": [
                "vnet"
              ]
            },
            "onelakeDfsPrivateDnsZone": {
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2020-06-01",
              "name": "[variables('onelakeDfsPrivateDNSZoneName')]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {},
              "dependsOn": [
                "vnet"
              ]
            },
            "fabricDfsPrivateDnsZoneVirtualNetworkLink": {
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('fabricDfsPrivateDNSZoneName'), variables('fabricDfsDnsZoneLinkName'))]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "fabricDfsPrivateDnsZone",
                "vnet"
              ]
            },
            "fabricBlobPrivateDnsZoneVirtualNetworkLink": {
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('fabricBlobPrivateDNSZoneName'), variables('fabricBlobDnsZoneLinkName'))]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "fabricBlobPrivateDnsZone",
                "vnet"
              ]
            },
            "fabricApiPrivateDnsZoneVirtualNetworkLink": {
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('fabricApiPrivateDNSZoneName'), variables('fabricApiDnsZoneLinkName'))]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "fabricApiPrivateDnsZone",
                "vnet"
              ]
            },
            "onelakeDfsPrivateDnsZoneVirtualNetworkLink": {
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('onelakeDfsPrivateDNSZoneName'), variables('onelakeDfsDnsZoneLinkName'))]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "onelakeDfsPrivateDnsZone",
                "vnet"
              ]
            },
            "onelakePrivateEndpoint": {
              "type": "Microsoft.Network/privateEndpoints",
              "apiVersion": "2021-08-01",
              "name": "[format('pe-{0}-onelake', parameters('fabricCapacityName'))]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "privateLinkServiceConnections": [
                  {
                    "name": "onelakePrivateLinkConnection",
                    "properties": {
                      "privateLinkServiceId": "[parameters('fabricCapacityId')]",
                      "groupIds": [
                        "onelake"
                      ]
                    }
                  }
                ],
                "subnet": {
                  "id": "[format('{0}/subnets/{1}', resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName')), parameters('subnetName'))]"
                }
              },
              "dependsOn": [
                "vnet"
              ]
            },
            "onelakePrivateEndpointDnsZoneGroup": {
              "type": "Microsoft.Network/privateEndpoints/privateDnsZoneGroups",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', format('pe-{0}-onelake', parameters('fabricCapacityName')), 'onelakePrivateDnsZoneGroup')]",
              "properties": {
                "privateDnsZoneConfigs": [
                  {
                    "name": "fabric-dfs-config",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('fabricDfsPrivateDNSZoneName'))]"
                    }
                  },
                  {
                    "name": "fabric-blob-config",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('fabricBlobPrivateDNSZoneName'))]"
                    }
                  },
                  {
                    "name": "fabric-api-config",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('fabricApiPrivateDNSZoneName'))]"
                    }
                  },
                  {
                    "name": "onelake-dfs-config",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('onelakeDfsPrivateDNSZoneName'))]"
                    }
                  }
                ]
              },
              "dependsOn": [
                "fabricApiPrivateDnsZone",
                "fabricBlobPrivateDnsZone",
                "fabricDfsPrivateDnsZone",
                "onelakeDfsPrivateDnsZone",
                "onelakePrivateEndpoint"
              ]
            },
            "onelakeDfsARecord": {
              "type": "Microsoft.Network/privateDnsZones/A",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('fabricDfsPrivateDNSZoneName'), 'onelake')]",
              "properties": {
                "ttl": 3600,
                "aRecords": [
                  {
                    "ipv4Address": "[reference('onelakePrivateEndpoint').customDnsConfigs[0].ipAddresses[0]]"
                  }
                ]
              },
              "dependsOn": [
                "fabricDfsPrivateDnsZone",
                "onelakePrivateEndpoint"
              ]
            },
            "onelakeBlobARecord": {
              "type": "Microsoft.Network/privateDnsZones/A",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('fabricBlobPrivateDNSZoneName'), 'onelake')]",
              "properties": {
                "ttl": 3600,
                "aRecords": [
                  {
                    "ipv4Address": "[reference('onelakePrivateEndpoint').customDnsConfigs[0].ipAddresses[0]]"
                  }
                ]
              },
              "dependsOn": [
                "fabricBlobPrivateDnsZone",
                "onelakePrivateEndpoint"
              ]
            }
          },
          "outputs": {
            "privateEndpointId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateEndpoints', format('pe-{0}-onelake', parameters('fabricCapacityName')))]"
            },
            "fabricDfsPrivateDnsZoneId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateDnsZones', variables('fabricDfsPrivateDNSZoneName'))]"
            },
            "fabricBlobPrivateDnsZoneId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateDnsZones', variables('fabricBlobPrivateDNSZoneName'))]"
            },
            "fabricApiPrivateDnsZoneId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateDnsZones', variables('fabricApiPrivateDNSZoneName'))]"
            },
            "onelakeDfsPrivateDnsZoneId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateDnsZones', variables('onelakeDfsPrivateDNSZoneName'))]"
            }
          }
        }
      },
      "dependsOn": [
        "fabricCapacity",
        "rg",
        "serviceVirtualNetwork"
      ]
    },
    "fabricDataAgents": {
      "condition": "[and(parameters('fabricEnabled'), parameters('fabricDataAgentsEnabled'))]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "fabricDataAgents",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "agentPrincipalId": "[if(parameters('agentIdentityEnabled'), createObject('value', reference('nextBestActionAgentIdentity').outputs.agentIdentityPrincipalId.value), createObject('value', reference('mcpUserAssignedIdentity').outputs.identityPrincipalId.value))]",
          "fabricCapacityId": {
            "value": "[reference('fabricCapacity').outputs.id.value]"
          },
          "fabricCapacityName": {
            "value": "[variables('fabricResourceName')]"
          },
          "fabricWorkspaceId": {
            "value": "[parameters('fabricWorkspaceId')]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "fabricDataAgentsEnabled": {
            "value": "[parameters('fabricDataAgentsEnabled')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "14534104186002438041"
            }
          },
          "parameters": {
            "agentPrincipalId": {
              "type": "string",
              "metadata": {
                "description": "Principal ID of the agent identity"
              }
            },
            "fabricCapacityId": {
              "type": "string",
              "metadata": {
                "description": "Resource ID of the Fabric capacity"
              }
            },
            "fabricCapacityName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Fabric capacity"
              }
            },
            "fabricWorkspaceId": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Fabric workspace ID for data agents"
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Location for Fabric resources"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for all resources"
              }
            },
            "fabricDataAgentsEnabled": {
              "type": "bool",
              "defaultValue": false,
              "metadata": {
                "description": "Enable Fabric Data Agents (default: false)"
              }
            },
            "deploymentSuffix": {
              "type": "string",
              "defaultValue": "fabric-data-v1",
              "metadata": {
                "description": "Unique suffix for role assignment names"
              }
            }
          },
          "variables": {
            "FabricReader": "acdd72a7-3385-48ef-bd42-f606fba81ae7",
            "FabricContributor": "b24988ac-6180-42a0-ab88-20f7382dd24c",
            "StorageBlobDataReader": "2a2b9908-6ea1-4ae2-8e65-a410df84e7d1",
            "StorageBlobDataContributor": "ba92f5b4-2d11-453d-a403-e96b0029c9fe"
          },
          "resources": {
            "fabricCapacity": {
              "existing": true,
              "type": "Microsoft.Fabric/capacities",
              "apiVersion": "2023-11-01",
              "name": "[parameters('fabricCapacityName')]"
            },
            "fabricReaderRoleAssignment": {
              "condition": "[parameters('fabricDataAgentsEnabled')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.Fabric/capacities/{0}', parameters('fabricCapacityName'))]",
              "name": "[guid(resourceId('Microsoft.Fabric/capacities', parameters('fabricCapacityName')), parameters('agentPrincipalId'), variables('FabricReader'), parameters('deploymentSuffix'))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', variables('FabricReader'))]",
                "principalId": "[parameters('agentPrincipalId')]",
                "principalType": "ServicePrincipal",
                "description": "Allows Fabric Data Agents to view workspace and resources"
              },
              "dependsOn": [
                "fabricCapacity"
              ]
            },
            "fabricContributorRoleAssignment": {
              "condition": "[parameters('fabricDataAgentsEnabled')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.Fabric/capacities/{0}', parameters('fabricCapacityName'))]",
              "name": "[guid(resourceId('Microsoft.Fabric/capacities', parameters('fabricCapacityName')), parameters('agentPrincipalId'), variables('FabricContributor'), parameters('deploymentSuffix'))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', variables('FabricContributor'))]",
                "principalId": "[parameters('agentPrincipalId')]",
                "principalType": "ServicePrincipal",
                "description": "Allows Fabric Data Agents to manage lakehouses, warehouses, and pipelines"
              },
              "dependsOn": [
                "fabricCapacity"
              ]
            },
            "onelakeDataContributorRoleAssignment": {
              "condition": "[parameters('fabricDataAgentsEnabled')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.Fabric/capacities/{0}', parameters('fabricCapacityName'))]",
              "name": "[guid(resourceId('Microsoft.Fabric/capacities', parameters('fabricCapacityName')), parameters('agentPrincipalId'), variables('StorageBlobDataContributor'), parameters('deploymentSuffix'), 'onelake')]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', variables('StorageBlobDataContributor'))]",
                "principalId": "[parameters('agentPrincipalId')]",
                "principalType": "ServicePrincipal",
                "description": "Allows Fabric Data Agents to read/write data through OneLake"
              },
              "dependsOn": [
                "fabricCapacity"
              ]
            }
          },
          "outputs": {
            "fabricReaderRoleAssignmentId": {
              "type": "string",
              "value": "[if(parameters('fabricDataAgentsEnabled'), extensionResourceId(resourceId('Microsoft.Fabric/capacities', parameters('fabricCapacityName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.Fabric/capacities', parameters('fabricCapacityName')), parameters('agentPrincipalId'), variables('FabricReader'), parameters('deploymentSuffix'))), '')]"
            },
            "fabricContributorRoleAssignmentId": {
              "type": "string",
              "value": "[if(parameters('fabricDataAgentsEnabled'), extensionResourceId(resourceId('Microsoft.Fabric/capacities', parameters('fabricCapacityName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.Fabric/capacities', parameters('fabricCapacityName')), parameters('agentPrincipalId'), variables('FabricContributor'), parameters('deploymentSuffix'))), '')]"
            },
            "onelakeDataContributorRoleAssignmentId": {
              "type": "string",
              "value": "[if(parameters('fabricDataAgentsEnabled'), extensionResourceId(resourceId('Microsoft.Fabric/capacities', parameters('fabricCapacityName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.Fabric/capacities', parameters('fabricCapacityName')), parameters('agentPrincipalId'), variables('StorageBlobDataContributor'), parameters('deploymentSuffix'), 'onelake')), '')]"
            },
            "fabricWorkspaceId": {
              "type": "string",
              "value": "[parameters('fabricWorkspaceId')]"
            }
          }
        }
      },
      "dependsOn": [
        "fabricCapacity",
        "mcpUserAssignedIdentity",
        "nextBestActionAgentIdentity",
        "rg"
      ]
    },
    "monitoring": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "monitoring",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "logAnalyticsName": "[if(not(empty(parameters('logAnalyticsName'))), createObject('value', parameters('logAnalyticsName')), createObject('value', format('{0}{1}', variables('abbrs').operationalInsightsWorkspaces, variables('resourceToken'))))]",
          "applicationInsightsName": "[if(not(empty(parameters('applicationInsightsName'))), createObject('value', parameters('applicationInsightsName')), createObject('value', format('{0}{1}', variables('abbrs').insightsComponents, variables('resourceToken'))))]",
          "disableLocalAuth": {
            "value": "[parameters('disableLocalAuth')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "7448301686395053287"
            }
          },
          "parameters": {
            "logAnalyticsName": {
              "type": "string"
            },
            "applicationInsightsName": {
              "type": "string"
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]"
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            },
            "disableLocalAuth": {
              "type": "bool",
              "defaultValue": false
            }
          },
          "resources": {
            "logAnalytics": {
              "type": "Microsoft.Resources/deployments",
              "apiVersion": "2022-09-01",
              "name": "loganalytics",
              "properties": {
                "expressionEvaluationOptions": {
                  "scope": "inner"
                },
                "mode": "Incremental",
                "parameters": {
                  "name": {
                    "value": "[parameters('logAnalyticsName')]"
                  },
                  "location": {
                    "value": "[parameters('location')]"
                  },
                  "tags": {
                    "value": "[parameters('tags')]"
                  }
                },
                "template": {
                  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
                  "languageVersion": "2.1-experimental",
                  "contentVersion": "1.0.0.0",
                  "metadata": {
                    "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
                    "_EXPERIMENTAL_FEATURES_ENABLED": [
                      "Extensibility"
                    ],
                    "_generator": {
                      "name": "bicep",
                      "version": "0.28.1.47646",
                      "templateHash": "2621439323348702860"
                    }
                  },
                  "parameters": {
                    "name": {
                      "type": "string"
                    },
                    "location": {
                      "type": "string",
                      "defaultValue": "[resourceGroup().location]"
                    },
                    "tags": {
                      "type": "object",
                      "defaultValue": {}
                    }
                  },
                  "resources": {
                    "logAnalytics": {
                      "type": "Microsoft.OperationalInsights/workspaces",
                      "apiVersion": "2021-12-01-preview",
                      "name": "[parameters('name')]",
                      "location": "[parameters('location')]",
                      "tags": "[parameters('tags')]",
                      "properties": {
                        "retentionInDays": 30,
                        "features": {
                          "searchVersion": 1
                        },
                        "sku": {
                          "name": "PerGB2018"
                        }
                      }
                    }
                  },
                  "outputs": {
                    "id": {
                      "type": "string",
                      "value": "[resourceId('Microsoft.OperationalInsights/workspaces', parameters('name'))]"
                    },
                    "name": {
                      "type": "string",
                      "value": "[parameters('name')]"
                    }
                  }
                }
              }
            },
            "applicationInsights": {
              "type": "Microsoft.Resources/deployments",
              "apiVersion": "2022-09-01",
              "name": "applicationinsights",
              "properties": {
                "expressionEvaluationOptions": {
                  "scope": "inner"
                },
                "mode": "Incremental",
                "parameters": {
                  "name": {
                    "value": "[parameters('applicationInsightsName')]"
                  },
                  "location": {
                    "value": "[parameters('location')]"
                  },
                  "tags": {
                    "value": "[parameters('tags')]"
                  },
                  "logAnalyticsWorkspaceId": {
                    "value": "[reference('logAnalytics').outputs.id.value]"
                  },
                  "disableLocalAuth": {
                    "value": "[parameters('disableLocalAuth')]"
                  }
                },
                "template": {
                  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
                  "languageVersion": "2.1-experimental",
                  "contentVersion": "1.0.0.0",
                  "metadata": {
                    "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
                    "_EXPERIMENTAL_FEATURES_ENABLED": [
                      "Extensibility"
                    ],
                    "_generator": {
                      "name": "bicep",
                      "version": "0.28.1.47646",
                      "templateHash": "13318299466077675376"
                    }
                  },
                  "parameters": {
                    "name": {
                      "type": "string"
                    },
                    "location": {
                      "type": "string",
                      "defaultValue": "[resourceGroup().location]"
                    },
                    "tags": {
                      "type": "object",
                      "defaultValue": {}
                    },
                    "logAnalyticsWorkspaceId": {
                      "type": "string"
                    },
                    "disableLocalAuth": {
                      "type": "bool",
                      "defaultValue": false
                    }
                  },
                  "resources": {
                    "applicationInsights": {
                      "type": "Microsoft.Insights/components",
                      "apiVersion": "2020-02-02",
                      "name": "[parameters('name')]",
                      "location": "[parameters('location')]",
                      "tags": "[parameters('tags')]",
                      "kind": "web",
                      "properties": {
                        "Application_Type": "web",
                        "WorkspaceResourceId": "[parameters('logAnalyticsWorkspaceId')]",
                        "DisableLocalAuth": "[parameters('disableLocalAuth')]"
                      }
                    }
                  },
                  "outputs": {
                    "connectionString": {
                      "type": "string",
                      "value": "[reference('applicationInsights').ConnectionString]"
                    },
                    "instrumentationKey": {
                      "type": "string",
                      "value": "[reference('applicationInsights').InstrumentationKey]"
                    },
                    "name": {
                      "type": "string",
                      "value": "[parameters('name')]"
                    }
                  }
                }
              },
              "dependsOn": [
                "logAnalytics"
              ]
            }
          },
          "outputs": {
            "applicationInsightsConnectionString": {
              "type": "string",
              "value": "[reference('applicationInsights').outputs.connectionString.value]"
            },
            "applicationInsightsInstrumentationKey": {
              "type": "string",
              "value": "[reference('applicationInsights').outputs.instrumentationKey.value]"
            },
            "applicationInsightsName": {
              "type": "string",
              "value": "[reference('applicationInsights').outputs.name.value]"
            },
            "logAnalyticsWorkspaceId": {
              "type": "string",
              "value": "[reference('logAnalytics').outputs.id.value]"
            },
            "logAnalyticsWorkspaceName": {
              "type": "string",
              "value": "[reference('logAnalytics').outputs.name.value]"
            }
          }
        }
      },
      "dependsOn": [
        "rg"
      ]
    },
    "prometheusDcrAssociation": {
      "condition": "[parameters('grafanaEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "prometheusDcrAssociation",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "aksClusterName": {
            "value": "[reference('aksCluster').outputs.aksClusterName.value]"
          },
          "dataCollectionRuleId": {
            "value": "[reference('azureMonitorWorkspace').outputs.dataCollectionRuleId.value]"
          },
          "dataCollectionEndpointId": {
            "value": "[reference('azureMonitorWorkspace').outputs.dataCollectionEndpointId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "4831292168972418689"
            }
          },
          "parameters": {
            "aksClusterName": {
              "type": "string",
              "metadata": {
                "description": "Name of the AKS cluster"
              }
            },
            "dataCollectionRuleId": {
              "type": "string",
              "metadata": {
                "description": "Data Collection Rule ID for Prometheus metrics"
              }
            },
            "dataCollectionEndpointId": {
              "type": "string",
              "metadata": {
                "description": "Data Collection Endpoint ID for Prometheus metrics"
              }
            }
          },
          "resources": {
            "aksCluster": {
              "existing": true,
              "type": "Microsoft.ContainerService/managedClusters",
              "apiVersion": "2024-02-01",
              "name": "[parameters('aksClusterName')]"
            },
            "prometheusDataCollectionRuleAssociation": {
              "type": "Microsoft.Insights/dataCollectionRuleAssociations",
              "apiVersion": "2022-06-01",
              "scope": "[format('Microsoft.ContainerService/managedClusters/{0}', parameters('aksClusterName'))]",
              "name": "configurationAccessEndpoint",
              "properties": {
                "dataCollectionEndpointId": "[parameters('dataCollectionEndpointId')]"
              },
              "dependsOn": [
                "aksCluster"
              ]
            },
            "prometheusDcrAssociation": {
              "type": "Microsoft.Insights/dataCollectionRuleAssociations",
              "apiVersion": "2022-06-01",
              "scope": "[format('Microsoft.ContainerService/managedClusters/{0}', parameters('aksClusterName'))]",
              "name": "ContainerInsightsMetricsExtension",
              "properties": {
                "dataCollectionRuleId": "[parameters('dataCollectionRuleId')]",
                "description": "Association of data collection rule for Prometheus metrics"
              },
              "dependsOn": [
                "aksCluster"
              ]
            }
          },
          "outputs": {
            "dataCollectionRuleAssociationName": {
              "type": "string",
              "value": "ContainerInsightsMetricsExtension"
            }
          }
        }
      },
      "dependsOn": [
        "aksCluster",
        "azureMonitorWorkspace",
        "rg"
      ]
    },
    "grafana": {
      "condition": "[parameters('grafanaEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "grafana",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "grafanaName": {
            "value": "[variables('grafanaResourceName')]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "skuName": {
            "value": "Standard"
          },
          "publicNetworkAccess": {
            "value": "Enabled"
          },
          "enableSystemAssignedIdentity": {
            "value": true
          },
          "azureMonitorWorkspaceId": {
            "value": "[reference('azureMonitorWorkspace').outputs.id.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "10474466495216273145"
            }
          },
          "parameters": {
            "grafanaName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Azure Managed Grafana instance"
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Location for the Grafana resource"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags for the resource"
              }
            },
            "skuName": {
              "type": "string",
              "defaultValue": "Standard",
              "allowedValues": [
                "Standard",
                "Essential"
              ],
              "metadata": {
                "description": "SKU name for Grafana - Standard or Essential"
              }
            },
            "publicNetworkAccess": {
              "type": "string",
              "defaultValue": "Enabled",
              "allowedValues": [
                "Enabled",
                "Disabled"
              ],
              "metadata": {
                "description": "Enable public network access"
              }
            },
            "zoneRedundancy": {
              "type": "string",
              "defaultValue": "Disabled",
              "allowedValues": [
                "Enabled",
                "Disabled"
              ],
              "metadata": {
                "description": "Enable zone redundancy"
              }
            },
            "apiKeyEnabled": {
              "type": "string",
              "defaultValue": "Disabled",
              "allowedValues": [
                "Enabled",
                "Disabled"
              ],
              "metadata": {
                "description": "Enable API key authentication"
              }
            },
            "deterministicOutboundIP": {
              "type": "string",
              "defaultValue": "Disabled",
              "allowedValues": [
                "Enabled",
                "Disabled"
              ],
              "metadata": {
                "description": "Enable deterministic outbound IP"
              }
            },
            "enableSystemAssignedIdentity": {
              "type": "bool",
              "defaultValue": true,
              "metadata": {
                "description": "Enable system assigned managed identity"
              }
            },
            "azureMonitorWorkspaceId": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Azure Monitor Workspace Resource ID for Prometheus integration"
              }
            }
          },
          "resources": {
            "grafana": {
              "type": "Microsoft.Dashboard/grafana",
              "apiVersion": "2024-10-01",
              "name": "[parameters('grafanaName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "sku": {
                "name": "[parameters('skuName')]"
              },
              "identity": {
                "type": "[if(parameters('enableSystemAssignedIdentity'), 'SystemAssigned', 'None')]"
              },
              "properties": {
                "publicNetworkAccess": "[parameters('publicNetworkAccess')]",
                "zoneRedundancy": "[parameters('zoneRedundancy')]",
                "apiKey": "[parameters('apiKeyEnabled')]",
                "deterministicOutboundIP": "[parameters('deterministicOutboundIP')]",
                "grafanaIntegrations": "[if(not(empty(parameters('azureMonitorWorkspaceId'))), createObject('azureMonitorWorkspaceIntegrations', createArray(createObject('azureMonitorWorkspaceResourceId', parameters('azureMonitorWorkspaceId')))), null())]",
                "grafanaConfigurations": {
                  "users": {
                    "viewersCanEdit": true
                  }
                }
              }
            }
          },
          "outputs": {
            "id": {
              "type": "string",
              "metadata": {
                "description": "The resource ID of the Grafana instance"
              },
              "value": "[resourceId('Microsoft.Dashboard/grafana', parameters('grafanaName'))]"
            },
            "name": {
              "type": "string",
              "metadata": {
                "description": "The name of the Grafana instance"
              },
              "value": "[parameters('grafanaName')]"
            },
            "endpoint": {
              "type": "string",
              "metadata": {
                "description": "The endpoint URL of the Grafana instance"
              },
              "value": "[reference('grafana').endpoint]"
            },
            "principalId": {
              "type": "string",
              "metadata": {
                "description": "The principal ID of the system-assigned managed identity"
              },
              "value": "[if(parameters('enableSystemAssignedIdentity'), reference('grafana', '2024-10-01', 'full').identity.principalId, '')]"
            }
          }
        }
      },
      "dependsOn": [
        "azureMonitorWorkspace",
        "rg"
      ]
    },
    "grafanaLogAnalyticsRole": {
      "condition": "[parameters('grafanaEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "grafanaLogAnalyticsRole",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "resourceName": {
            "value": "[reference('monitoring').outputs.logAnalyticsWorkspaceName.value]"
          },
          "resourceType": {
            "value": "logAnalytics"
          },
          "roleDefinitionID": {
            "value": "[variables('MonitoringReader')]"
          },
          "principalID": {
            "value": "[reference('grafana').outputs.principalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "17433976184513252444"
            }
          },
          "parameters": {
            "resourceName": {
              "type": "string",
              "metadata": {
                "description": "Name of the resource to grant access to"
              }
            },
            "resourceType": {
              "type": "string",
              "allowedValues": [
                "logAnalytics",
                "aks",
                "appInsights",
                "azureMonitorWorkspace"
              ],
              "metadata": {
                "description": "Type of resource for role assignment scope"
              }
            },
            "roleDefinitionID": {
              "type": "string",
              "metadata": {
                "description": "Role Definition ID to assign"
              }
            },
            "principalID": {
              "type": "string",
              "metadata": {
                "description": "Principal ID to grant access to"
              }
            },
            "principalType": {
              "type": "string",
              "defaultValue": "ServicePrincipal",
              "allowedValues": [
                "ServicePrincipal",
                "User",
                "Group"
              ],
              "metadata": {
                "description": "Principal type for role assignment"
              }
            }
          },
          "resources": {
            "logAnalyticsWorkspace": {
              "condition": "[equals(parameters('resourceType'), 'logAnalytics')]",
              "existing": true,
              "type": "Microsoft.OperationalInsights/workspaces",
              "apiVersion": "2022-10-01",
              "name": "[parameters('resourceName')]"
            },
            "aksCluster": {
              "condition": "[equals(parameters('resourceType'), 'aks')]",
              "existing": true,
              "type": "Microsoft.ContainerService/managedClusters",
              "apiVersion": "2024-02-01",
              "name": "[parameters('resourceName')]"
            },
            "appInsights": {
              "condition": "[equals(parameters('resourceType'), 'appInsights')]",
              "existing": true,
              "type": "Microsoft.Insights/components",
              "apiVersion": "2020-02-02",
              "name": "[parameters('resourceName')]"
            },
            "azureMonitorWorkspace": {
              "condition": "[equals(parameters('resourceType'), 'azureMonitorWorkspace')]",
              "existing": true,
              "type": "Microsoft.Monitor/accounts",
              "apiVersion": "2023-04-03",
              "name": "[parameters('resourceName')]"
            },
            "logAnalyticsRoleAssignment": {
              "condition": "[equals(parameters('resourceType'), 'logAnalytics')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.OperationalInsights/workspaces/{0}', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.OperationalInsights/workspaces', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              },
              "dependsOn": [
                "logAnalyticsWorkspace"
              ]
            },
            "aksRoleAssignment": {
              "condition": "[equals(parameters('resourceType'), 'aks')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.ContainerService/managedClusters/{0}', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.ContainerService/managedClusters', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              },
              "dependsOn": [
                "aksCluster"
              ]
            },
            "appInsightsRoleAssignment": {
              "condition": "[equals(parameters('resourceType'), 'appInsights')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.Insights/components/{0}', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.Insights/components', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              },
              "dependsOn": [
                "appInsights"
              ]
            },
            "azureMonitorWorkspaceRoleAssignment": {
              "condition": "[equals(parameters('resourceType'), 'azureMonitorWorkspace')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.Monitor/accounts/{0}', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.Monitor/accounts', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              },
              "dependsOn": [
                "azureMonitorWorkspace"
              ]
            }
          }
        }
      },
      "dependsOn": [
        "grafana",
        "monitoring",
        "rg"
      ]
    },
    "grafanaAksRole": {
      "condition": "[parameters('grafanaEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "grafanaAksRole",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "resourceName": {
            "value": "[reference('aksCluster').outputs.aksClusterName.value]"
          },
          "resourceType": {
            "value": "aks"
          },
          "roleDefinitionID": {
            "value": "[variables('ReaderRole')]"
          },
          "principalID": {
            "value": "[reference('grafana').outputs.principalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "17433976184513252444"
            }
          },
          "parameters": {
            "resourceName": {
              "type": "string",
              "metadata": {
                "description": "Name of the resource to grant access to"
              }
            },
            "resourceType": {
              "type": "string",
              "allowedValues": [
                "logAnalytics",
                "aks",
                "appInsights",
                "azureMonitorWorkspace"
              ],
              "metadata": {
                "description": "Type of resource for role assignment scope"
              }
            },
            "roleDefinitionID": {
              "type": "string",
              "metadata": {
                "description": "Role Definition ID to assign"
              }
            },
            "principalID": {
              "type": "string",
              "metadata": {
                "description": "Principal ID to grant access to"
              }
            },
            "principalType": {
              "type": "string",
              "defaultValue": "ServicePrincipal",
              "allowedValues": [
                "ServicePrincipal",
                "User",
                "Group"
              ],
              "metadata": {
                "description": "Principal type for role assignment"
              }
            }
          },
          "resources": {
            "logAnalyticsWorkspace": {
              "condition": "[equals(parameters('resourceType'), 'logAnalytics')]",
              "existing": true,
              "type": "Microsoft.OperationalInsights/workspaces",
              "apiVersion": "2022-10-01",
              "name": "[parameters('resourceName')]"
            },
            "aksCluster": {
              "condition": "[equals(parameters('resourceType'), 'aks')]",
              "existing": true,
              "type": "Microsoft.ContainerService/managedClusters",
              "apiVersion": "2024-02-01",
              "name": "[parameters('resourceName')]"
            },
            "appInsights": {
              "condition": "[equals(parameters('resourceType'), 'appInsights')]",
              "existing": true,
              "type": "Microsoft.Insights/components",
              "apiVersion": "2020-02-02",
              "name": "[parameters('resourceName')]"
            },
            "azureMonitorWorkspace": {
              "condition": "[equals(parameters('resourceType'), 'azureMonitorWorkspace')]",
              "existing": true,
              "type": "Microsoft.Monitor/accounts",
              "apiVersion": "2023-04-03",
              "name": "[parameters('resourceName')]"
            },
            "logAnalyticsRoleAssignment": {
              "condition": "[equals(parameters('resourceType'), 'logAnalytics')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.OperationalInsights/workspaces/{0}', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.OperationalInsights/workspaces', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              },
              "dependsOn": [
                "logAnalyticsWorkspace"
              ]
            },
            "aksRoleAssignment": {
              "condition": "[equals(parameters('resourceType'), 'aks')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.ContainerService/managedClusters/{0}', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.ContainerService/managedClusters', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              },
              "dependsOn": [
                "aksCluster"
              ]
            },
            "appInsightsRoleAssignment": {
              "condition": "[equals(parameters('resourceType'), 'appInsights')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.Insights/components/{0}', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.Insights/components', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              },
              "dependsOn": [
                "appInsights"
              ]
            },
            "azureMonitorWorkspaceRoleAssignment": {
              "condition": "[equals(parameters('resourceType'), 'azureMonitorWorkspace')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.Monitor/accounts/{0}', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.Monitor/accounts', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              },
              "dependsOn": [
                "azureMonitorWorkspace"
              ]
            }
          }
        }
      },
      "dependsOn": [
        "aksCluster",
        "grafana",
        "rg"
      ]
    },
    "grafanaAppInsightsRole": {
      "condition": "[parameters('grafanaEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "grafanaAppInsightsRole",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "resourceName": {
            "value": "[reference('monitoring').outputs.applicationInsightsName.value]"
          },
          "resourceType": {
            "value": "appInsights"
          },
          "roleDefinitionID": {
            "value": "[variables('MonitoringReader')]"
          },
          "principalID": {
            "value": "[reference('grafana').outputs.principalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "17433976184513252444"
            }
          },
          "parameters": {
            "resourceName": {
              "type": "string",
              "metadata": {
                "description": "Name of the resource to grant access to"
              }
            },
            "resourceType": {
              "type": "string",
              "allowedValues": [
                "logAnalytics",
                "aks",
                "appInsights",
                "azureMonitorWorkspace"
              ],
              "metadata": {
                "description": "Type of resource for role assignment scope"
              }
            },
            "roleDefinitionID": {
              "type": "string",
              "metadata": {
                "description": "Role Definition ID to assign"
              }
            },
            "principalID": {
              "type": "string",
              "metadata": {
                "description": "Principal ID to grant access to"
              }
            },
            "principalType": {
              "type": "string",
              "defaultValue": "ServicePrincipal",
              "allowedValues": [
                "ServicePrincipal",
                "User",
                "Group"
              ],
              "metadata": {
                "description": "Principal type for role assignment"
              }
            }
          },
          "resources": {
            "logAnalyticsWorkspace": {
              "condition": "[equals(parameters('resourceType'), 'logAnalytics')]",
              "existing": true,
              "type": "Microsoft.OperationalInsights/workspaces",
              "apiVersion": "2022-10-01",
              "name": "[parameters('resourceName')]"
            },
            "aksCluster": {
              "condition": "[equals(parameters('resourceType'), 'aks')]",
              "existing": true,
              "type": "Microsoft.ContainerService/managedClusters",
              "apiVersion": "2024-02-01",
              "name": "[parameters('resourceName')]"
            },
            "appInsights": {
              "condition": "[equals(parameters('resourceType'), 'appInsights')]",
              "existing": true,
              "type": "Microsoft.Insights/components",
              "apiVersion": "2020-02-02",
              "name": "[parameters('resourceName')]"
            },
            "azureMonitorWorkspace": {
              "condition": "[equals(parameters('resourceType'), 'azureMonitorWorkspace')]",
              "existing": true,
              "type": "Microsoft.Monitor/accounts",
              "apiVersion": "2023-04-03",
              "name": "[parameters('resourceName')]"
            },
            "logAnalyticsRoleAssignment": {
              "condition": "[equals(parameters('resourceType'), 'logAnalytics')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.OperationalInsights/workspaces/{0}', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.OperationalInsights/workspaces', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              },
              "dependsOn": [
                "logAnalyticsWorkspace"
              ]
            },
            "aksRoleAssignment": {
              "condition": "[equals(parameters('resourceType'), 'aks')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.ContainerService/managedClusters/{0}', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.ContainerService/managedClusters', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              },
              "dependsOn": [
                "aksCluster"
              ]
            },
            "appInsightsRoleAssignment": {
              "condition": "[equals(parameters('resourceType'), 'appInsights')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.Insights/components/{0}', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.Insights/components', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              },
              "dependsOn": [
                "appInsights"
              ]
            },
            "azureMonitorWorkspaceRoleAssignment": {
              "condition": "[equals(parameters('resourceType'), 'azureMonitorWorkspace')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.Monitor/accounts/{0}', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.Monitor/accounts', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              },
              "dependsOn": [
                "azureMonitorWorkspace"
              ]
            }
          }
        }
      },
      "dependsOn": [
        "grafana",
        "monitoring",
        "rg"
      ]
    },
    "grafanaAzureMonitorWorkspaceRole": {
      "condition": "[parameters('grafanaEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "grafanaAzureMonitorWorkspaceRole",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "resourceName": {
            "value": "[reference('azureMonitorWorkspace').outputs.name.value]"
          },
          "resourceType": {
            "value": "azureMonitorWorkspace"
          },
          "roleDefinitionID": {
            "value": "[variables('MonitoringDataReader')]"
          },
          "principalID": {
            "value": "[reference('grafana').outputs.principalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "17433976184513252444"
            }
          },
          "parameters": {
            "resourceName": {
              "type": "string",
              "metadata": {
                "description": "Name of the resource to grant access to"
              }
            },
            "resourceType": {
              "type": "string",
              "allowedValues": [
                "logAnalytics",
                "aks",
                "appInsights",
                "azureMonitorWorkspace"
              ],
              "metadata": {
                "description": "Type of resource for role assignment scope"
              }
            },
            "roleDefinitionID": {
              "type": "string",
              "metadata": {
                "description": "Role Definition ID to assign"
              }
            },
            "principalID": {
              "type": "string",
              "metadata": {
                "description": "Principal ID to grant access to"
              }
            },
            "principalType": {
              "type": "string",
              "defaultValue": "ServicePrincipal",
              "allowedValues": [
                "ServicePrincipal",
                "User",
                "Group"
              ],
              "metadata": {
                "description": "Principal type for role assignment"
              }
            }
          },
          "resources": {
            "logAnalyticsWorkspace": {
              "condition": "[equals(parameters('resourceType'), 'logAnalytics')]",
              "existing": true,
              "type": "Microsoft.OperationalInsights/workspaces",
              "apiVersion": "2022-10-01",
              "name": "[parameters('resourceName')]"
            },
            "aksCluster": {
              "condition": "[equals(parameters('resourceType'), 'aks')]",
              "existing": true,
              "type": "Microsoft.ContainerService/managedClusters",
              "apiVersion": "2024-02-01",
              "name": "[parameters('resourceName')]"
            },
            "appInsights": {
              "condition": "[equals(parameters('resourceType'), 'appInsights')]",
              "existing": true,
              "type": "Microsoft.Insights/components",
              "apiVersion": "2020-02-02",
              "name": "[parameters('resourceName')]"
            },
            "azureMonitorWorkspace": {
              "condition": "[equals(parameters('resourceType'), 'azureMonitorWorkspace')]",
              "existing": true,
              "type": "Microsoft.Monitor/accounts",
              "apiVersion": "2023-04-03",
              "name": "[parameters('resourceName')]"
            },
            "logAnalyticsRoleAssignment": {
              "condition": "[equals(parameters('resourceType'), 'logAnalytics')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.OperationalInsights/workspaces/{0}', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.OperationalInsights/workspaces', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              },
              "dependsOn": [
                "logAnalyticsWorkspace"
              ]
            },
            "aksRoleAssignment": {
              "condition": "[equals(parameters('resourceType'), 'aks')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.ContainerService/managedClusters/{0}', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.ContainerService/managedClusters', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              },
              "dependsOn": [
                "aksCluster"
              ]
            },
            "appInsightsRoleAssignment": {
              "condition": "[equals(parameters('resourceType'), 'appInsights')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.Insights/components/{0}', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.Insights/components', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              },
              "dependsOn": [
                "appInsights"
              ]
            },
            "azureMonitorWorkspaceRoleAssignment": {
              "condition": "[equals(parameters('resourceType'), 'azureMonitorWorkspace')]",
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.Monitor/accounts/{0}', parameters('resourceName'))]",
              "name": "[guid(resourceId('Microsoft.Monitor/accounts', parameters('resourceName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              },
              "dependsOn": [
                "azureMonitorWorkspace"
              ]
            }
          }
        }
      },
      "dependsOn": [
        "azureMonitorWorkspace",
        "grafana",
        "rg"
      ]
    },
    "appInsightsRoleAssignmentMcp": {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "appInsightsRoleAssignmentMcp",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "appInsightsName": {
            "value": "[reference('monitoring').outputs.applicationInsightsName.value]"
          },
          "roleDefinitionID": {
            "value": "[variables('monitoringRoleDefinitionId')]"
          },
          "principalID": {
            "value": "[reference('mcpUserAssignedIdentity').outputs.identityPrincipalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "14167109582542169471"
            }
          },
          "parameters": {
            "principalID": {
              "type": "string"
            },
            "roleDefinitionID": {
              "type": "string"
            },
            "appInsightsName": {
              "type": "string"
            },
            "nameSuffix": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Optional suffix to make role assignment name unique across deployments"
              }
            }
          },
          "resources": {
            "applicationInsights": {
              "existing": true,
              "type": "Microsoft.Insights/components",
              "apiVersion": "2020-02-02",
              "name": "[parameters('appInsightsName')]"
            },
            "appInsightsRoleAssignment": {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.Insights/components/{0}', parameters('appInsightsName'))]",
              "name": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.Insights/components', parameters('appInsightsName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.Insights/components', parameters('appInsightsName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalId": "[parameters('principalID')]",
                "principalType": "ServicePrincipal"
              },
              "dependsOn": [
                "applicationInsights"
              ]
            }
          },
          "outputs": {
            "ROLE_ASSIGNMENT_NAME": {
              "type": "string",
              "value": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.Insights/components', parameters('appInsightsName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.Insights/components', parameters('appInsightsName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]"
            }
          }
        }
      },
      "dependsOn": [
        "mcpUserAssignedIdentity",
        "monitoring",
        "rg"
      ]
    },
    "agentRoleAssignments": {
      "condition": "[parameters('agentIdentityEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "agentRoleAssignments",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "agentPrincipalId": {
            "value": "[reference('nextBestActionAgentIdentity').outputs.agentIdentityPrincipalId.value]"
          },
          "cosmosAccountName": {
            "value": "[reference('cosmosAccount').outputs.name.value]"
          },
          "searchServiceName": {
            "value": "[reference('searchService').outputs.name.value]"
          },
          "storageAccountName": {
            "value": "[reference('storage').outputs.name.value]"
          },
          "foundryAccountName": {
            "value": "[reference('foundry').outputs.foundryAccountName.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "6052450807854338895"
            }
          },
          "parameters": {
            "agentPrincipalId": {
              "type": "string",
              "metadata": {
                "description": "Principal ID of the agent identity"
              }
            },
            "cosmosAccountName": {
              "type": "string",
              "metadata": {
                "description": "Cosmos DB account name"
              }
            },
            "searchServiceName": {
              "type": "string",
              "metadata": {
                "description": "Azure AI Search service name"
              }
            },
            "storageAccountName": {
              "type": "string",
              "metadata": {
                "description": "Storage account name"
              }
            },
            "foundryAccountName": {
              "type": "string",
              "metadata": {
                "description": "Azure AI Foundry account name"
              }
            },
            "deploymentSuffix": {
              "type": "string",
              "defaultValue": "agent-v1",
              "metadata": {
                "description": "Unique suffix for role assignment names to ensure idempotency"
              }
            }
          },
          "variables": {
            "CosmosDBDataContributor": "00000000-0000-0000-0000-000000000002",
            "SearchIndexDataContributor": "8ebe5a00-799e-43f5-93ac-243d3dce84a7",
            "SearchServiceContributor": "7ca78c08-252a-4471-8644-bb5ff32d4ba0",
            "StorageBlobDataOwner": "b7e6dc6d-f1e8-4753-8033-0f276bb0955b",
            "StorageQueueDataContributor": "974c5e8b-45b9-4653-ba55-5f855dd0fb88",
            "CognitiveServicesOpenAIUser": "5e0bd9bd-7b93-4f28-af87-19fc36ad61bd",
            "CognitiveServicesOpenAIContributor": "a001fd3d-188f-4b5d-821b-7da978bf7442"
          },
          "resources": {
            "cosmosAccount": {
              "existing": true,
              "type": "Microsoft.DocumentDB/databaseAccounts",
              "apiVersion": "2024-05-15",
              "name": "[parameters('cosmosAccountName')]"
            },
            "cosmosRoleAssignmentAgent": {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlRoleAssignments",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}', parameters('cosmosAccountName'), guid(resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName')), parameters('agentPrincipalId'), variables('CosmosDBDataContributor'), parameters('deploymentSuffix')))]",
              "properties": {
                "principalId": "[parameters('agentPrincipalId')]",
                "roleDefinitionId": "[format('{0}/sqlRoleDefinitions/{1}', resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName')), variables('CosmosDBDataContributor'))]",
                "scope": "[resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName'))]"
              },
              "dependsOn": [
                "cosmosAccount"
              ]
            },
            "searchService": {
              "existing": true,
              "type": "Microsoft.Search/searchServices",
              "apiVersion": "2024-06-01-preview",
              "name": "[parameters('searchServiceName')]"
            },
            "searchIndexDataContributorAgent": {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.Search/searchServices/{0}', parameters('searchServiceName'))]",
              "name": "[guid(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), parameters('agentPrincipalId'), variables('SearchIndexDataContributor'), parameters('deploymentSuffix'))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', variables('SearchIndexDataContributor'))]",
                "principalId": "[parameters('agentPrincipalId')]",
                "principalType": "ServicePrincipal"
              },
              "dependsOn": [
                "searchService"
              ]
            },
            "searchServiceContributorAgent": {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.Search/searchServices/{0}', parameters('searchServiceName'))]",
              "name": "[guid(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), parameters('agentPrincipalId'), variables('SearchServiceContributor'), parameters('deploymentSuffix'))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', variables('SearchServiceContributor'))]",
                "principalId": "[parameters('agentPrincipalId')]",
                "principalType": "ServicePrincipal"
              },
              "dependsOn": [
                "searchService"
              ]
            },
            "storageAccount": {
              "existing": true,
              "type": "Microsoft.Storage/storageAccounts",
              "apiVersion": "2023-01-01",
              "name": "[parameters('storageAccountName')]"
            },
            "storageBlobDataOwnerAgent": {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.Storage/storageAccounts/{0}', parameters('storageAccountName'))]",
              "name": "[guid(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), parameters('agentPrincipalId'), variables('StorageBlobDataOwner'), parameters('deploymentSuffix'))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', variables('StorageBlobDataOwner'))]",
                "principalId": "[parameters('agentPrincipalId')]",
                "principalType": "ServicePrincipal"
              },
              "dependsOn": [
                "storageAccount"
              ]
            },
            "storageQueueDataContributorAgent": {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.Storage/storageAccounts/{0}', parameters('storageAccountName'))]",
              "name": "[guid(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), parameters('agentPrincipalId'), variables('StorageQueueDataContributor'), parameters('deploymentSuffix'))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', variables('StorageQueueDataContributor'))]",
                "principalId": "[parameters('agentPrincipalId')]",
                "principalType": "ServicePrincipal"
              },
              "dependsOn": [
                "storageAccount"
              ]
            },
            "foundryAccount": {
              "existing": true,
              "type": "Microsoft.CognitiveServices/accounts",
              "apiVersion": "2025-06-01",
              "name": "[parameters('foundryAccountName')]"
            },
            "openAIUserAgent": {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.CognitiveServices/accounts/{0}', parameters('foundryAccountName'))]",
              "name": "[guid(resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryAccountName')), parameters('agentPrincipalId'), variables('CognitiveServicesOpenAIUser'), parameters('deploymentSuffix'))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', variables('CognitiveServicesOpenAIUser'))]",
                "principalId": "[parameters('agentPrincipalId')]",
                "principalType": "ServicePrincipal"
              },
              "dependsOn": [
                "foundryAccount"
              ]
            },
            "openAIContributorAgent": {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.CognitiveServices/accounts/{0}', parameters('foundryAccountName'))]",
              "name": "[guid(resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryAccountName')), parameters('agentPrincipalId'), variables('CognitiveServicesOpenAIContributor'), parameters('deploymentSuffix'))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', variables('CognitiveServicesOpenAIContributor'))]",
                "principalId": "[parameters('agentPrincipalId')]",
                "principalType": "ServicePrincipal"
              },
              "dependsOn": [
                "foundryAccount"
              ]
            }
          },
          "outputs": {
            "cosmosRoleAssignmentId": {
              "type": "string",
              "value": "[resourceId('Microsoft.DocumentDB/databaseAccounts/sqlRoleAssignments', parameters('cosmosAccountName'), guid(resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName')), parameters('agentPrincipalId'), variables('CosmosDBDataContributor'), parameters('deploymentSuffix')))]"
            },
            "searchIndexRoleAssignmentId": {
              "type": "string",
              "value": "[extensionResourceId(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), parameters('agentPrincipalId'), variables('SearchIndexDataContributor'), parameters('deploymentSuffix')))]"
            },
            "searchServiceRoleAssignmentId": {
              "type": "string",
              "value": "[extensionResourceId(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.Search/searchServices', parameters('searchServiceName')), parameters('agentPrincipalId'), variables('SearchServiceContributor'), parameters('deploymentSuffix')))]"
            },
            "storageBlobRoleAssignmentId": {
              "type": "string",
              "value": "[extensionResourceId(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), parameters('agentPrincipalId'), variables('StorageBlobDataOwner'), parameters('deploymentSuffix')))]"
            },
            "storageQueueRoleAssignmentId": {
              "type": "string",
              "value": "[extensionResourceId(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), parameters('agentPrincipalId'), variables('StorageQueueDataContributor'), parameters('deploymentSuffix')))]"
            },
            "foundryOpenAIUserRoleAssignmentId": {
              "type": "string",
              "value": "[extensionResourceId(resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryAccountName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryAccountName')), parameters('agentPrincipalId'), variables('CognitiveServicesOpenAIUser'), parameters('deploymentSuffix')))]"
            },
            "foundryOpenAIContributorRoleAssignmentId": {
              "type": "string",
              "value": "[extensionResourceId(resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryAccountName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.CognitiveServices/accounts', parameters('foundryAccountName')), parameters('agentPrincipalId'), variables('CognitiveServicesOpenAIContributor'), parameters('deploymentSuffix')))]"
            }
          }
        }
      },
      "dependsOn": [
        "cosmosAccount",
        "foundry",
        "nextBestActionAgentIdentity",
        "rg",
        "searchService",
        "storage"
      ]
    },
    "appInsightsRoleAssignmentAgent": {
      "condition": "[parameters('agentIdentityEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "appInsightsRoleAssignmentAgent",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "appInsightsName": {
            "value": "[reference('monitoring').outputs.applicationInsightsName.value]"
          },
          "roleDefinitionID": {
            "value": "[variables('monitoringRoleDefinitionId')]"
          },
          "principalID": {
            "value": "[reference('nextBestActionAgentIdentity').outputs.agentIdentityPrincipalId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "14167109582542169471"
            }
          },
          "parameters": {
            "principalID": {
              "type": "string"
            },
            "roleDefinitionID": {
              "type": "string"
            },
            "appInsightsName": {
              "type": "string"
            },
            "nameSuffix": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Optional suffix to make role assignment name unique across deployments"
              }
            }
          },
          "resources": {
            "applicationInsights": {
              "existing": true,
              "type": "Microsoft.Insights/components",
              "apiVersion": "2020-02-02",
              "name": "[parameters('appInsightsName')]"
            },
            "appInsightsRoleAssignment": {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.Insights/components/{0}', parameters('appInsightsName'))]",
              "name": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.Insights/components', parameters('appInsightsName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.Insights/components', parameters('appInsightsName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalId": "[parameters('principalID')]",
                "principalType": "ServicePrincipal"
              },
              "dependsOn": [
                "applicationInsights"
              ]
            }
          },
          "outputs": {
            "ROLE_ASSIGNMENT_NAME": {
              "type": "string",
              "value": "[if(empty(parameters('nameSuffix')), guid(resourceId('Microsoft.Insights/components', parameters('appInsightsName')), parameters('principalID'), parameters('roleDefinitionID')), guid(resourceId('Microsoft.Insights/components', parameters('appInsightsName')), parameters('principalID'), parameters('roleDefinitionID'), parameters('nameSuffix')))]"
            }
          }
        }
      },
      "dependsOn": [
        "monitoring",
        "nextBestActionAgentIdentity",
        "rg"
      ]
    },
    "agentsApprovalLogicApp": {
      "condition": "[parameters('approvalLogicAppEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "agentsApprovalLogicApp",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "logicAppName": {
            "value": "[format('{0}approval-{1}', variables('abbrs').logicWorkflows, variables('resourceToken'))]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "cosmosDbAccountName": {
            "value": "[reference('cosmosAccount').outputs.name.value]"
          },
          "cosmosDbDatabaseName": {
            "value": "[parameters('cosmosDatabaseName')]"
          },
          "cosmosDbContainerName": {
            "value": "approvals"
          },
          "teamsChannelId": {
            "value": "[parameters('teamsChannelId')]"
          },
          "teamsGroupId": {
            "value": "[parameters('teamsGroupId')]"
          },
          "approvalTimeoutHours": {
            "value": "[parameters('approvalTimeoutHours')]"
          },
          "userAssignedIdentityId": {
            "value": "[reference('mcpUserAssignedIdentity').outputs.identityId.value]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "13864921346673186044"
            }
          },
          "parameters": {
            "logicAppName": {
              "type": "string",
              "metadata": {
                "description": "The name of the Logic App"
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "The location for all resources"
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Tags to apply to all resources"
              }
            },
            "cosmosDbAccountName": {
              "type": "string",
              "metadata": {
                "description": "The CosmosDB account name for audit logging"
              }
            },
            "cosmosDbDatabaseName": {
              "type": "string",
              "defaultValue": "mcpdb",
              "metadata": {
                "description": "The CosmosDB database name"
              }
            },
            "cosmosDbContainerName": {
              "type": "string",
              "defaultValue": "approvals",
              "metadata": {
                "description": "The CosmosDB container name for approvals"
              }
            },
            "teamsChannelId": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "The Teams channel ID for approval notifications"
              }
            },
            "teamsGroupId": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "The Teams group/team ID for approval notifications"
              }
            },
            "approvalTimeoutHours": {
              "type": "int",
              "defaultValue": 2,
              "metadata": {
                "description": "Approval timeout in hours"
              }
            },
            "userAssignedIdentityId": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "The user-assigned managed identity ID"
              }
            }
          },
          "variables": {
            "CosmosDBDataContributor": "00000000-0000-0000-0000-000000000002",
            "cosmosConnectionName": "[format('{0}-cosmos', parameters('logicAppName'))]",
            "teamsConnectionName": "[format('{0}-teams', parameters('logicAppName'))]"
          },
          "resources": {
            "cosmosDbAccount": {
              "existing": true,
              "type": "Microsoft.DocumentDB/databaseAccounts",
              "apiVersion": "2024-05-15",
              "name": "[parameters('cosmosDbAccountName')]"
            },
            "cosmosDbConnection": {
              "type": "Microsoft.Web/connections",
              "apiVersion": "2016-06-01",
              "name": "[variables('cosmosConnectionName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "displayName": "CosmosDB Connection for Approvals",
                "api": {
                  "id": "[subscriptionResourceId('Microsoft.Web/locations/managedApis', parameters('location'), 'documentdb')]"
                },
                "parameterValues": {
                  "databaseAccount": "[parameters('cosmosDbAccountName')]",
                  "accessKey": "[listKeys(resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosDbAccountName')), '2024-05-15').primaryMasterKey]"
                }
              },
              "dependsOn": [
                "cosmosDbAccount"
              ]
            },
            "teamsConnection": {
              "type": "Microsoft.Web/connections",
              "apiVersion": "2016-06-01",
              "name": "[variables('teamsConnectionName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "displayName": "Teams Connection for Approvals",
                "api": {
                  "id": "[subscriptionResourceId('Microsoft.Web/locations/managedApis', parameters('location'), 'teams')]"
                }
              }
            },
            "logicApp": {
              "type": "Microsoft.Logic/workflows",
              "apiVersion": "2019-05-01",
              "name": "[parameters('logicAppName')]",
              "location": "[parameters('location')]",
              "tags": "[union(parameters('tags'), createObject('azd-service-name', 'agents-approval-workflow'))]",
              "identity": "[if(empty(parameters('userAssignedIdentityId')), createObject('type', 'SystemAssigned'), createObject('type', 'UserAssigned', 'userAssignedIdentities', createObject(format('{0}', parameters('userAssignedIdentityId')), createObject())))]",
              "properties": {
                "state": "Enabled",
                "definition": {
                  "$schema": "https://schema.management.azure.com/providers/Microsoft.Logic/schemas/2016-06-01/workflowdefinition.json#",
                  "contentVersion": "1.0.0.0",
                  "parameters": {
                    "$connections": {
                      "defaultValue": {},
                      "type": "Object"
                    },
                    "teamsChannelId": {
                      "defaultValue": "[parameters('teamsChannelId')]",
                      "type": "String"
                    },
                    "teamsGroupId": {
                      "defaultValue": "[parameters('teamsGroupId')]",
                      "type": "String"
                    },
                    "approvalTimeoutHours": {
                      "defaultValue": "[parameters('approvalTimeoutHours')]",
                      "type": "Int"
                    },
                    "cosmosDbEndpoint": {
                      "defaultValue": "[format('https://{0}.documents.azure.com', parameters('cosmosDbAccountName'))]",
                      "type": "String"
                    }
                  },
                  "triggers": {
                    "When_an_HTTP_request_is_received": {
                      "type": "Request",
                      "kind": "Http",
                      "inputs": {
                        "schema": {
                          "type": "object",
                          "properties": {
                            "approval_id": {
                              "type": "string"
                            },
                            "task": {
                              "type": "string"
                            },
                            "environment": {
                              "type": "string"
                            },
                            "cluster": {
                              "type": "string"
                            },
                            "namespace": {
                              "type": "string"
                            },
                            "image_tags": {
                              "type": "array"
                            },
                            "commit_sha": {
                              "type": "string"
                            },
                            "requested_by": {
                              "type": "string"
                            },
                            "callback_url": {
                              "type": "string"
                            }
                          },
                          "required": [
                            "approval_id",
                            "task",
                            "environment",
                            "cluster",
                            "callback_url"
                          ]
                        }
                      }
                    }
                  },
                  "actions": {
                    "Initialize_Approval_Record": {
                      "type": "InitializeVariable",
                      "runAfter": {},
                      "inputs": {
                        "variables": [
                          {
                            "name": "approvalRecord",
                            "type": "object",
                            "value": {
                              "approval_id": "@{triggerBody()?['approval_id']}",
                              "task": "@{triggerBody()?['task']}",
                              "environment": "@{triggerBody()?['environment']}",
                              "status": "pending",
                              "created_at": "@{utcNow()}"
                            }
                          }
                        ]
                      }
                    },
                    "Start_Teams_Approval": {
                      "type": "ApiConnectionWebhook",
                      "runAfter": {
                        "Initialize_Approval_Record": [
                          "Succeeded"
                        ]
                      },
                      "inputs": {
                        "host": {
                          "connection": {
                            "name": "@parameters('$connections')['teams']['connectionId']"
                          }
                        },
                        "body": {
                          "notificationUrl": "@{listCallbackUrl()}",
                          "message": {
                            "title": "CI/CD Deployment Approval - @{triggerBody()?['environment']}",
                            "details": "Deployment to @{triggerBody()?['cluster']} requested"
                          },
                          "approvalType": "CustomResponse",
                          "customResponses": [
                            {
                              "response": "Approve",
                              "comment": {
                                "isOptional": true
                              }
                            },
                            {
                              "response": "Reject",
                              "comment": {
                                "isOptional": false
                              }
                            }
                          ]
                        },
                        "path": "/v2/approvals/create"
                      },
                      "limit": {
                        "timeout": "PT@{parameters('approvalTimeoutHours')}H"
                      }
                    },
                    "Notify_Agent_Of_Decision": {
                      "type": "Http",
                      "runAfter": {
                        "Start_Teams_Approval": [
                          "Succeeded"
                        ]
                      },
                      "inputs": {
                        "method": "POST",
                        "uri": "@{triggerBody()?['callback_url']}",
                        "body": {
                          "approval_id": "@{triggerBody()?['approval_id']}",
                          "decision": "@{body('Start_Teams_Approval')?['outcome']}",
                          "approved_by": "@{body('Start_Teams_Approval')?['responder']?['displayName']}",
                          "timestamp": "@{utcNow()}"
                        },
                        "headers": {
                          "Content-Type": "application/json"
                        }
                      }
                    },
                    "Response": {
                      "type": "Response",
                      "runAfter": {
                        "Notify_Agent_Of_Decision": [
                          "Succeeded"
                        ]
                      },
                      "inputs": {
                        "statusCode": 200,
                        "body": "@variables('approvalRecord')"
                      }
                    }
                  }
                },
                "parameters": {
                  "$connections": {
                    "value": {
                      "documentdb": {
                        "connectionId": "[resourceId('Microsoft.Web/connections', variables('cosmosConnectionName'))]",
                        "connectionName": "documentdb",
                        "id": "[subscriptionResourceId('Microsoft.Web/locations/managedApis', parameters('location'), 'documentdb')]"
                      },
                      "teams": {
                        "connectionId": "[resourceId('Microsoft.Web/connections', variables('teamsConnectionName'))]",
                        "connectionName": "teams",
                        "id": "[subscriptionResourceId('Microsoft.Web/locations/managedApis', parameters('location'), 'teams')]"
                      }
                    }
                  }
                }
              },
              "dependsOn": [
                "cosmosDbConnection",
                "teamsConnection"
              ]
            },
            "cosmosRoleAssignmentLogicApp": {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlRoleAssignments",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}', parameters('cosmosDbAccountName'), guid(resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosDbAccountName')), resourceId('Microsoft.Logic/workflows', parameters('logicAppName')), variables('CosmosDBDataContributor'), 'logicapp'))]",
              "properties": {
                "principalId": "[reference('logicApp', '2019-05-01', 'full').identity.principalId]",
                "roleDefinitionId": "[format('{0}/sqlRoleDefinitions/{1}', resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosDbAccountName')), variables('CosmosDBDataContributor'))]",
                "scope": "[resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosDbAccountName'))]"
              },
              "dependsOn": [
                "cosmosDbAccount",
                "logicApp"
              ]
            },
            "cosmosDatabase": {
              "existing": true,
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}', parameters('cosmosDbAccountName'), parameters('cosmosDbDatabaseName'))]",
              "dependsOn": [
                "cosmosDbAccount"
              ]
            },
            "approvalsContainer": {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlDatabases/containers",
              "apiVersion": "2023-04-15",
              "name": "[format('{0}/{1}/{2}', parameters('cosmosDbAccountName'), parameters('cosmosDbDatabaseName'), parameters('cosmosDbContainerName'))]",
              "properties": {
                "resource": {
                  "id": "[parameters('cosmosDbContainerName')]",
                  "partitionKey": {
                    "paths": [
                      "/environment"
                    ],
                    "kind": "Hash"
                  },
                  "indexingPolicy": {
                    "indexingMode": "consistent",
                    "includedPaths": [
                      {
                        "path": "/*"
                      }
                    ],
                    "excludedPaths": [
                      {
                        "path": "/\"_etag\"/?"
                      }
                    ]
                  },
                  "defaultTtl": -1
                }
              },
              "dependsOn": [
                "cosmosDatabase"
              ]
            }
          },
          "outputs": {
            "logicAppTriggerUrl": {
              "type": "string",
              "metadata": {
                "description": "The Logic App trigger URL for approval requests"
              },
              "value": "[listCallbackUrl(format('{0}/triggers/When_an_HTTP_request_is_received', resourceId('Microsoft.Logic/workflows', parameters('logicAppName'))), '2019-05-01').value]"
            },
            "logicAppId": {
              "type": "string",
              "metadata": {
                "description": "The Logic App resource ID"
              },
              "value": "[resourceId('Microsoft.Logic/workflows', parameters('logicAppName'))]"
            },
            "logicAppName": {
              "type": "string",
              "metadata": {
                "description": "The Logic App name"
              },
              "value": "[parameters('logicAppName')]"
            },
            "logicAppPrincipalId": {
              "type": "string",
              "metadata": {
                "description": "The Logic App managed identity principal ID"
              },
              "value": "[reference('logicApp', '2019-05-01', 'full').identity.principalId]"
            },
            "approvalsContainerName": {
              "type": "string",
              "metadata": {
                "description": "The approvals container name"
              },
              "value": "[parameters('cosmosDbContainerName')]"
            }
          }
        }
      },
      "dependsOn": [
        "cosmosAccount",
        "mcpUserAssignedIdentity",
        "rg"
      ]
    },
    "defender": {
      "condition": "[and(parameters('defenderEnabled'), not(empty(parameters('defenderSecurityContactEmail'))))]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "defender",
      "location": "[deployment().location]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "securityContactEmail": {
            "value": "[parameters('defenderSecurityContactEmail')]"
          },
          "securityContactPhone": {
            "value": "[parameters('defenderSecurityContactPhone')]"
          },
          "enableDefenderForContainers": {
            "value": "[parameters('defenderForContainersEnabled')]"
          },
          "enableDefenderForKeyVault": {
            "value": "[parameters('defenderForKeyVaultEnabled')]"
          },
          "enableDefenderForCosmosDB": {
            "value": "[parameters('defenderForCosmosDBEnabled')]"
          },
          "enableDefenderForAPIs": {
            "value": "[parameters('defenderForAPIsEnabled')]"
          },
          "enableDefenderForResourceManager": {
            "value": "[parameters('defenderForResourceManagerEnabled')]"
          },
          "enableDefenderForContainerRegistry": {
            "value": "[parameters('defenderForContainerRegistryEnabled')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2018-05-01/subscriptionDeploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "4349294089469550402"
            }
          },
          "parameters": {
            "securityContactEmail": {
              "type": "string",
              "metadata": {
                "description": "Email address for security contact notifications"
              }
            },
            "securityContactPhone": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Phone number for security contact notifications"
              }
            },
            "enableDefenderForContainers": {
              "type": "bool",
              "defaultValue": true,
              "metadata": {
                "description": "Enable Defender for Containers"
              }
            },
            "enableDefenderForKeyVault": {
              "type": "bool",
              "defaultValue": true,
              "metadata": {
                "description": "Enable Defender for Key Vault"
              }
            },
            "enableDefenderForCosmosDB": {
              "type": "bool",
              "defaultValue": true,
              "metadata": {
                "description": "Enable Defender for Azure Cosmos DB"
              }
            },
            "enableDefenderForAPIs": {
              "type": "bool",
              "defaultValue": true,
              "metadata": {
                "description": "Enable Defender for APIs (API Management)"
              }
            },
            "enableDefenderForResourceManager": {
              "type": "bool",
              "defaultValue": true,
              "metadata": {
                "description": "Enable Defender for Resource Manager"
              }
            },
            "enableDefenderForContainerRegistry": {
              "type": "bool",
              "defaultValue": true,
              "metadata": {
                "description": "Enable Defender for Container Registries"
              }
            }
          },
          "resources": {
            "defenderForContainers": {
              "condition": "[parameters('enableDefenderForContainers')]",
              "type": "Microsoft.Security/pricings",
              "apiVersion": "2024-01-01",
              "name": "Containers",
              "properties": {
                "pricingTier": "Standard",
                "subPlan": "P2",
                "extensions": [
                  {
                    "name": "ContainerRegistriesVulnerabilityAssessments",
                    "isEnabled": "True"
                  },
                  {
                    "name": "AgentlessDiscoveryForKubernetes",
                    "isEnabled": "True"
                  },
                  {
                    "name": "AgentlessVmScanning",
                    "isEnabled": "True"
                  }
                ]
              }
            },
            "defenderForKeyVault": {
              "condition": "[parameters('enableDefenderForKeyVault')]",
              "type": "Microsoft.Security/pricings",
              "apiVersion": "2024-01-01",
              "name": "KeyVaults",
              "properties": {
                "pricingTier": "Standard"
              }
            },
            "defenderForCosmosDB": {
              "condition": "[parameters('enableDefenderForCosmosDB')]",
              "type": "Microsoft.Security/pricings",
              "apiVersion": "2024-01-01",
              "name": "CosmosDbs",
              "properties": {
                "pricingTier": "Standard"
              }
            },
            "defenderForAPIs": {
              "condition": "[parameters('enableDefenderForAPIs')]",
              "type": "Microsoft.Security/pricings",
              "apiVersion": "2024-01-01",
              "name": "Api",
              "properties": {
                "pricingTier": "Standard",
                "subPlan": "P1"
              }
            },
            "defenderForResourceManager": {
              "condition": "[parameters('enableDefenderForResourceManager')]",
              "type": "Microsoft.Security/pricings",
              "apiVersion": "2024-01-01",
              "name": "Arm",
              "properties": {
                "pricingTier": "Standard"
              }
            },
            "defenderForContainerRegistry": {
              "condition": "[parameters('enableDefenderForContainerRegistry')]",
              "type": "Microsoft.Security/pricings",
              "apiVersion": "2024-01-01",
              "name": "ContainerRegistry",
              "properties": {
                "pricingTier": "Standard"
              }
            },
            "securityContact": {
              "type": "Microsoft.Security/securityContacts",
              "apiVersion": "2020-01-01-preview",
              "name": "default",
              "properties": {
                "emails": "[parameters('securityContactEmail')]",
                "phone": "[parameters('securityContactPhone')]",
                "alertNotifications": {
                  "state": "On",
                  "minimalSeverity": "Medium"
                },
                "notificationsByRole": {
                  "state": "On",
                  "roles": [
                    "Owner"
                  ]
                }
              }
            },
            "autoProvisioningLogAnalytics": {
              "type": "Microsoft.Security/autoProvisioningSettings",
              "apiVersion": "2017-08-01-preview",
              "name": "default",
              "properties": {
                "autoProvision": "On"
              }
            }
          },
          "outputs": {
            "defenderForContainersEnabled": {
              "type": "bool",
              "value": "[parameters('enableDefenderForContainers')]"
            },
            "defenderForKeyVaultEnabled": {
              "type": "bool",
              "value": "[parameters('enableDefenderForKeyVault')]"
            },
            "defenderForCosmosDBEnabled": {
              "type": "bool",
              "value": "[parameters('enableDefenderForCosmosDB')]"
            },
            "defenderForAPIsEnabled": {
              "type": "bool",
              "value": "[parameters('enableDefenderForAPIs')]"
            },
            "defenderForResourceManagerEnabled": {
              "type": "bool",
              "value": "[parameters('enableDefenderForResourceManager')]"
            },
            "securityContactConfigured": {
              "type": "bool",
              "value": true
            }
          }
        }
      }
    },
    "purviewAccount": {
      "condition": "[parameters('purviewEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "purviewAccount",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "name": {
            "value": "[variables('purviewResourceName')]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "managedIdentityType": {
            "value": "SystemAssigned"
          },
          "publicNetworkAccess": "[if(parameters('vnetEnabled'), createObject('value', 'Disabled'), createObject('value', 'Enabled'))]"
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "4899688328759303887"
            },
            "description": "Create a Microsoft Purview account for data governance and compliance."
          },
          "parameters": {
            "name": {
              "type": "string"
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]"
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            },
            "managedIdentityType": {
              "type": "string",
              "defaultValue": "SystemAssigned",
              "allowedValues": [
                "SystemAssigned",
                "UserAssigned",
                "SystemAssigned,UserAssigned"
              ],
              "metadata": {
                "description": "Managed identity type for the Purview account"
              }
            },
            "publicNetworkAccess": {
              "type": "string",
              "defaultValue": "Disabled",
              "allowedValues": [
                "Enabled",
                "Disabled"
              ],
              "metadata": {
                "description": "Public network access configuration"
              }
            },
            "managedResourceGroupName": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Managed resource group name for Purview managed resources"
              }
            }
          },
          "resources": {
            "purviewAccount": {
              "type": "Microsoft.Purview/accounts",
              "apiVersion": "2021-12-01",
              "name": "[parameters('name')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "identity": {
                "type": "[parameters('managedIdentityType')]"
              },
              "properties": {
                "publicNetworkAccess": "[parameters('publicNetworkAccess')]",
                "managedResourceGroupName": "[if(not(empty(parameters('managedResourceGroupName'))), parameters('managedResourceGroupName'), format('{0}-managed-rg', parameters('name')))]"
              }
            }
          },
          "outputs": {
            "id": {
              "type": "string",
              "value": "[resourceId('Microsoft.Purview/accounts', parameters('name'))]"
            },
            "name": {
              "type": "string",
              "value": "[parameters('name')]"
            },
            "endpoint": {
              "type": "string",
              "value": "[format('https://{0}.purview.azure.com', parameters('name'))]"
            },
            "catalogEndpoint": {
              "type": "string",
              "value": "[reference('purviewAccount').endpoints.catalog]"
            },
            "scanEndpoint": {
              "type": "string",
              "value": "[reference('purviewAccount').endpoints.scan]"
            },
            "principalId": {
              "type": "string",
              "value": "[reference('purviewAccount', '2021-12-01', 'full').identity.principalId]"
            },
            "managedResourceGroupName": {
              "type": "string",
              "value": "[reference('purviewAccount').managedResources.resourceGroup]"
            }
          }
        }
      },
      "dependsOn": [
        "rg"
      ]
    },
    "purviewPrivateEndpoint": {
      "condition": "[and(parameters('purviewEnabled'), parameters('vnetEnabled'))]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "purviewPrivateEndpoint",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "tags": {
            "value": "[variables('tags')]"
          },
          "virtualNetworkName": {
            "value": "[variables('serviceVirtualNetworkName')]"
          },
          "subnetName": "[if(parameters('vnetEnabled'), createObject('value', variables('serviceVirtualNetworkPrivateEndpointSubnetName')), createObject('value', ''))]",
          "resourceName": {
            "value": "[variables('purviewResourceName')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "8652161665332955525"
            }
          },
          "parameters": {
            "virtualNetworkName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the virtual network."
              }
            },
            "subnetName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the name of the subnet which contains the private endpoints."
              }
            },
            "resourceName": {
              "type": "string",
              "metadata": {
                "description": "Specifies the resource name of the Purview account."
              }
            },
            "location": {
              "type": "string",
              "defaultValue": "[resourceGroup().location]",
              "metadata": {
                "description": "Specifies the location."
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {}
            }
          },
          "variables": {
            "purviewPrivateDNSZoneNames": [
              "privatelink.purview.azure.com",
              "privatelink.purviewstudio.azure.com"
            ]
          },
          "resources": {
            "vnet": {
              "existing": true,
              "type": "Microsoft.Network/virtualNetworks",
              "apiVersion": "2021-08-01",
              "name": "[parameters('virtualNetworkName')]"
            },
            "purviewAccount": {
              "existing": true,
              "type": "Microsoft.Purview/accounts",
              "apiVersion": "2021-12-01",
              "name": "[parameters('resourceName')]"
            },
            "purviewPrivateDnsZones": {
              "copy": {
                "name": "purviewPrivateDnsZones",
                "count": "[length(variables('purviewPrivateDNSZoneNames'))]"
              },
              "type": "Microsoft.Network/privateDnsZones",
              "apiVersion": "2020-06-01",
              "name": "[variables('purviewPrivateDNSZoneNames')[copyIndex()]]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {}
            },
            "purviewPrivateDnsZoneVirtualNetworkLinks": {
              "copy": {
                "name": "purviewPrivateDnsZoneVirtualNetworkLinks",
                "count": "[length(variables('purviewPrivateDNSZoneNames'))]"
              },
              "type": "Microsoft.Network/privateDnsZones/virtualNetworkLinks",
              "apiVersion": "2020-06-01",
              "name": "[format('{0}/{1}', variables('purviewPrivateDNSZoneNames')[copyIndex()], format('{0}-purview-link-{1}-{2}', parameters('resourceName'), copyIndex(), take(toLower(uniqueString(parameters('resourceName'), parameters('virtualNetworkName'))), 4)))]",
              "location": "global",
              "tags": "[parameters('tags')]",
              "properties": {
                "registrationEnabled": false,
                "virtualNetwork": {
                  "id": "[resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]"
                }
              },
              "dependsOn": [
                "[format('purviewPrivateDnsZones[{0}]', copyIndex())]",
                "vnet"
              ]
            },
            "purviewAccountPrivateEndpoint": {
              "type": "Microsoft.Network/privateEndpoints",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}-account-private-endpoint', parameters('resourceName'))]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "privateLinkServiceConnections": [
                  {
                    "name": "purviewAccountPrivateLinkConnection",
                    "properties": {
                      "privateLinkServiceId": "[resourceId('Microsoft.Purview/accounts', parameters('resourceName'))]",
                      "groupIds": [
                        "account"
                      ]
                    }
                  }
                ],
                "subnet": {
                  "id": "[format('{0}/subnets/{1}', resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName')), parameters('subnetName'))]"
                }
              },
              "dependsOn": [
                "purviewAccount",
                "vnet"
              ]
            },
            "purviewAccountPrivateDnsZoneGroup": {
              "type": "Microsoft.Network/privateEndpoints/privateDnsZoneGroups",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', format('{0}-account-private-endpoint', parameters('resourceName')), 'purviewAccountPrivateDnsZoneGroup')]",
              "properties": {
                "privateDnsZoneConfigs": [
                  {
                    "name": "config-account",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('purviewPrivateDNSZoneNames')[0])]"
                    }
                  }
                ]
              },
              "dependsOn": [
                "purviewAccountPrivateEndpoint",
                "[format('purviewPrivateDnsZones[{0}]', 0)]"
              ]
            },
            "purviewPortalPrivateEndpoint": {
              "type": "Microsoft.Network/privateEndpoints",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}-portal-private-endpoint', parameters('resourceName'))]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "privateLinkServiceConnections": [
                  {
                    "name": "purviewPortalPrivateLinkConnection",
                    "properties": {
                      "privateLinkServiceId": "[resourceId('Microsoft.Purview/accounts', parameters('resourceName'))]",
                      "groupIds": [
                        "portal"
                      ]
                    }
                  }
                ],
                "subnet": {
                  "id": "[format('{0}/subnets/{1}', resourceId('Microsoft.Network/virtualNetworks', parameters('virtualNetworkName')), parameters('subnetName'))]"
                }
              },
              "dependsOn": [
                "purviewAccount",
                "vnet"
              ]
            },
            "purviewPortalPrivateDnsZoneGroup": {
              "type": "Microsoft.Network/privateEndpoints/privateDnsZoneGroups",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', format('{0}-portal-private-endpoint', parameters('resourceName')), 'purviewPortalPrivateDnsZoneGroup')]",
              "properties": {
                "privateDnsZoneConfigs": [
                  {
                    "name": "config-portal",
                    "properties": {
                      "privateDnsZoneId": "[resourceId('Microsoft.Network/privateDnsZones', variables('purviewPrivateDNSZoneNames')[1])]"
                    }
                  }
                ]
              },
              "dependsOn": [
                "purviewPortalPrivateEndpoint",
                "[format('purviewPrivateDnsZones[{0}]', 1)]"
              ]
            }
          },
          "outputs": {
            "accountPrivateEndpointId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateEndpoints', format('{0}-account-private-endpoint', parameters('resourceName')))]"
            },
            "portalPrivateEndpointId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Network/privateEndpoints', format('{0}-portal-private-endpoint', parameters('resourceName')))]"
            },
            "privateDnsZoneIds": {
              "type": "array",
              "copy": {
                "count": "[length(variables('purviewPrivateDNSZoneNames'))]",
                "input": "[resourceId('Microsoft.Network/privateDnsZones', variables('purviewPrivateDNSZoneNames')[copyIndex()])]"
              }
            }
          }
        }
      },
      "dependsOn": [
        "purviewAccount",
        "rg",
        "serviceVirtualNetwork"
      ]
    },
    "purviewAgentRole": {
      "condition": "[and(parameters('purviewEnabled'), parameters('agentIdentityEnabled'))]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "purviewAgentRole",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "purviewAccountName": {
            "value": "[variables('purviewResourceName')]"
          },
          "roleDefinitionID": {
            "value": "[variables('PurviewDataReader')]"
          },
          "principalID": {
            "value": "[reference('nextBestActionAgentIdentity').outputs.agentIdentityPrincipalId.value]"
          },
          "principalType": {
            "value": "ServicePrincipal"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "18350096071531097120"
            }
          },
          "parameters": {
            "purviewAccountName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Purview account."
              }
            },
            "roleDefinitionID": {
              "type": "string",
              "metadata": {
                "description": "Role definition ID to assign (use built-in Azure RBAC roles)."
              }
            },
            "principalID": {
              "type": "string",
              "metadata": {
                "description": "Principal ID to assign the role to."
              }
            },
            "principalType": {
              "type": "string",
              "defaultValue": "ServicePrincipal",
              "metadata": {
                "description": "Principal type: User, Group, or ServicePrincipal."
              }
            }
          },
          "resources": {
            "purviewAccount": {
              "existing": true,
              "type": "Microsoft.Purview/accounts",
              "apiVersion": "2021-12-01",
              "name": "[parameters('purviewAccountName')]"
            },
            "purviewRoleAssignment": {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.Purview/accounts/{0}', parameters('purviewAccountName'))]",
              "name": "[guid(resourceId('Microsoft.Purview/accounts', parameters('purviewAccountName')), parameters('principalID'), parameters('roleDefinitionID'))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionID'))]",
                "principalType": "[parameters('principalType')]"
              },
              "dependsOn": [
                "purviewAccount"
              ]
            }
          },
          "outputs": {
            "roleAssignmentId": {
              "type": "string",
              "value": "[extensionResourceId(resourceId('Microsoft.Purview/accounts', parameters('purviewAccountName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.Purview/accounts', parameters('purviewAccountName')), parameters('principalID'), parameters('roleDefinitionID')))]"
            }
          }
        }
      },
      "dependsOn": [
        "nextBestActionAgentIdentity",
        "rg"
      ]
    },
    "purviewScanCosmosRole": {
      "condition": "[parameters('purviewEnabled')]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "purviewScanCosmosRole",
      "resourceGroup": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "cosmosAccountName": {
            "value": "[reference('cosmosAccount').outputs.name.value]"
          },
          "roleDefinitionID": {
            "value": "00000000-0000-0000-0000-000000000001"
          },
          "principalID": {
            "value": "[reference('purviewAccount').outputs.principalId.value]"
          },
          "principalType": {
            "value": "ServicePrincipal"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "2.1-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "This template uses ARM features that are experimental. Experimental features should be enabled for testing purposes only, as there are no guarantees about the quality or stability of these features. Do not enable these settings for any production usage, or your production environment may be subject to breaking.",
            "_EXPERIMENTAL_FEATURES_ENABLED": [
              "Extensibility"
            ],
            "_generator": {
              "name": "bicep",
              "version": "0.28.1.47646",
              "templateHash": "3777928649650282036"
            }
          },
          "parameters": {
            "cosmosAccountName": {
              "type": "string",
              "metadata": {
                "description": "Name of the Cosmos DB account."
              }
            },
            "roleDefinitionID": {
              "type": "string",
              "metadata": {
                "description": "Role definition ID to assign."
              }
            },
            "principalID": {
              "type": "string",
              "metadata": {
                "description": "Principal ID to assign the role to."
              }
            },
            "principalType": {
              "type": "string",
              "defaultValue": "ServicePrincipal",
              "metadata": {
                "description": "Principal type: User, Group, or ServicePrincipal."
              }
            }
          },
          "resources": {
            "cosmosAccount": {
              "existing": true,
              "type": "Microsoft.DocumentDB/databaseAccounts",
              "apiVersion": "2024-05-15",
              "name": "[parameters('cosmosAccountName')]"
            },
            "cosmosRoleAssignment": {
              "type": "Microsoft.DocumentDB/databaseAccounts/sqlRoleAssignments",
              "apiVersion": "2024-05-15",
              "name": "[format('{0}/{1}', parameters('cosmosAccountName'), guid(resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName')), parameters('principalID'), parameters('roleDefinitionID')))]",
              "properties": {
                "principalId": "[parameters('principalID')]",
                "roleDefinitionId": "[format('{0}/sqlRoleDefinitions/{1}', resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName')), parameters('roleDefinitionID'))]",
                "scope": "[resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName'))]"
              },
              "dependsOn": [
                "cosmosAccount"
              ]
            }
          },
          "outputs": {
            "roleAssignmentId": {
              "type": "string",
              "value": "[resourceId('Microsoft.DocumentDB/databaseAccounts/sqlRoleAssignments', parameters('cosmosAccountName'), guid(resourceId('Microsoft.DocumentDB/databaseAccounts', parameters('cosmosAccountName')), parameters('principalID'), parameters('roleDefinitionID')))]"
            }
          }
        }
      },
      "dependsOn": [
        "cosmosAccount",
        "purviewAccount",
        "rg"
      ]
    }
  },
  "outputs": {
    "APPLICATIONINSIGHTS_CONNECTION_STRING": {
      "type": "string",
      "value": "[reference('monitoring').outputs.applicationInsightsConnectionString.value]"
    },
    "AZURE_LOCATION": {
      "type": "string",
      "value": "[parameters('location')]"
    },
    "AZURE_TENANT_ID": {
      "type": "string",
      "value": "[tenant().tenantId]"
    },
    "AKS_CLUSTER_NAME": {
      "type": "string",
      "value": "[reference('aksCluster').outputs.aksClusterName.value]"
    },
    "CONTAINER_REGISTRY": {
      "type": "string",
      "value": "[reference('containerRegistry').outputs.containerRegistryLoginServer.value]"
    },
    "AZURE_STORAGE_ACCOUNT_URL": {
      "type": "string",
      "value": "[reference('storage').outputs.primaryEndpoints.value.blob]"
    },
    "MCP_SERVER_IDENTITY_CLIENT_ID": {
      "type": "string",
      "value": "[reference('mcpUserAssignedIdentity').outputs.identityClientId.value]"
    },
    "SERVICE_API_ENDPOINTS": {
      "type": "array",
      "value": [
        "[format('{0}/mcp/sse', reference('apimService').outputs.gatewayUrl.value)]"
      ]
    },
    "APIM_GATEWAY_URL": {
      "type": "string",
      "value": "[reference('apimService').outputs.gatewayUrl.value]"
    },
    "MCP_BASE_URL": {
      "type": "string",
      "value": "[format('{0}/mcp', reference('apimService').outputs.gatewayUrl.value)]"
    },
    "MCP_OAUTH_AUTHORIZE_URL": {
      "type": "string",
      "value": "[format('{0}/mcp/oauth/authorize', reference('apimService').outputs.gatewayUrl.value)]"
    },
    "MCP_OAUTH_TOKEN_URL": {
      "type": "string",
      "value": "[format('{0}/mcp/oauth/token', reference('apimService').outputs.gatewayUrl.value)]"
    },
    "MCP_CLIENT_ID": {
      "type": "string",
      "value": "[parameters('existingEntraAppId')]"
    },
    "AZURE_RESOURCE_GROUP_NAME": {
      "type": "string",
      "value": "[if(not(empty(parameters('resourceGroupName'))), parameters('resourceGroupName'), format('{0}{1}', variables('abbrs').resourcesResourceGroups, parameters('environmentName')))]"
    },
    "AZURE_SUBSCRIPTION_ID": {
      "type": "string",
      "value": "[subscription().subscriptionId]"
    },
    "MCP_PUBLIC_IP_ADDRESS": {
      "type": "string",
      "value": "[reference('mcpPublicIp').outputs.publicIpAddress.value]"
    },
    "MCP_PUBLIC_IP_NAME": {
      "type": "string",
      "value": "[format('pip-mcp-{0}', variables('resourceToken'))]"
    },
    "FOUNDRY_PROJECT_ENDPOINT": {
      "type": "string",
      "value": "[reference('foundry').outputs.projectEndpoint.value]"
    },
    "FOUNDRY_MODEL_DEPLOYMENT_NAME": {
      "type": "string",
      "value": "[parameters('foundryModelDeploymentName')]"
    },
    "FOUNDRY_ACCOUNT_NAME": {
      "type": "string",
      "value": "[reference('foundry').outputs.foundryAccountName.value]"
    },
    "EMBEDDING_MODEL_DEPLOYMENT_NAME": {
      "type": "string",
      "value": "[parameters('embeddingModelDeploymentName')]"
    },
    "COSMOSDB_ENDPOINT": {
      "type": "string",
      "value": "[reference('cosmosAccount').outputs.endpoint.value]"
    },
    "COSMOSDB_DATABASE_NAME": {
      "type": "string",
      "value": "[parameters('cosmosDatabaseName')]"
    },
    "COSMOSDB_ACCOUNT_NAME": {
      "type": "string",
      "value": "[reference('cosmosAccount').outputs.name.value]"
    },
    "COSMOS_ACCOUNT_URI": {
      "type": "string",
      "value": "[reference('cosmosAccount').outputs.endpoint.value]"
    },
    "COSMOS_DATABASE_NAME": {
      "type": "string",
      "value": "[reference('lightningCosmos').outputs.databaseName.value]"
    },
    "AZURE_SEARCH_ENDPOINT": {
      "type": "string",
      "value": "[reference('searchService').outputs.endpoint.value]"
    },
    "AZURE_SEARCH_INDEX_NAME": {
      "type": "string",
      "value": "[parameters('searchIndexName')]"
    },
    "AZURE_SEARCH_SERVICE_NAME": {
      "type": "string",
      "value": "[reference('searchService').outputs.name.value]"
    },
    "ONTOLOGY_CONTAINER_NAME": {
      "type": "string",
      "value": "[variables('ontologyContainerName')]"
    },
    "ONTOLOGY_STORAGE_URL": {
      "type": "string",
      "value": "[format('{0}{1}', reference('storage').outputs.primaryEndpoints.value.blob, variables('ontologyContainerName'))]"
    },
    "FABRIC_CAPACITY_NAME": {
      "type": "string",
      "value": "[if(parameters('fabricEnabled'), reference('fabricCapacity').outputs.name.value, '')]"
    },
    "FABRIC_ENABLED": {
      "type": "bool",
      "value": "[parameters('fabricEnabled')]"
    },
    "FABRIC_ONELAKE_DFS_ENDPOINT": {
      "type": "string",
      "value": "[if(parameters('fabricEnabled'), 'https://onelake.dfs.fabric.microsoft.com', '')]"
    },
    "FABRIC_ONELAKE_BLOB_ENDPOINT": {
      "type": "string",
      "value": "[if(parameters('fabricEnabled'), 'https://onelake.blob.fabric.microsoft.com', '')]"
    },
    "FABRIC_DATA_AGENTS_ENABLED": {
      "type": "bool",
      "value": "[parameters('fabricDataAgentsEnabled')]"
    },
    "FABRIC_WORKSPACE_ID": {
      "type": "string",
      "value": "[parameters('fabricWorkspaceId')]"
    },
    "FABRIC_API_ENDPOINT": {
      "type": "string",
      "value": "[if(parameters('fabricEnabled'), 'https://api.fabric.microsoft.com/v1', '')]"
    },
    "AGENT_IDENTITY_ENABLED": {
      "type": "bool",
      "value": "[parameters('agentIdentityEnabled')]"
    },
    "AGENT_IDENTITY_BLUEPRINT_APP_ID": {
      "type": "string",
      "value": "[if(parameters('agentIdentityEnabled'), reference('agentIdentityBlueprint').outputs.blueprintAppId.value, '')]"
    },
    "AGENT_IDENTITY_APP_ID": {
      "type": "string",
      "value": "[if(parameters('agentIdentityEnabled'), reference('nextBestActionAgentIdentity').outputs.agentIdentityAppId.value, '')]"
    },
    "AGENT_IDENTITY_PRINCIPAL_ID": {
      "type": "string",
      "value": "[if(parameters('agentIdentityEnabled'), reference('nextBestActionAgentIdentity').outputs.agentIdentityPrincipalId.value, '')]"
    },
    "AGENT_IDENTITY_DISPLAY_NAME": {
      "type": "string",
      "value": "[if(parameters('agentIdentityEnabled'), reference('nextBestActionAgentIdentity').outputs.agentDisplayName.value, '')]"
    },
    "APPROVAL_LOGIC_APP_ENABLED": {
      "type": "bool",
      "value": "[parameters('approvalLogicAppEnabled')]"
    },
    "APPROVAL_LOGIC_APP_TRIGGER_URL": {
      "type": "string",
      "value": "[if(parameters('approvalLogicAppEnabled'), reference('agentsApprovalLogicApp').outputs.logicAppTriggerUrl.value, '')]"
    },
    "APPROVAL_LOGIC_APP_NAME": {
      "type": "string",
      "value": "[if(parameters('approvalLogicAppEnabled'), reference('agentsApprovalLogicApp').outputs.logicAppName.value, '')]"
    },
    "GRAFANA_ENABLED": {
      "type": "bool",
      "value": "[parameters('grafanaEnabled')]"
    },
    "GRAFANA_NAME": {
      "type": "string",
      "value": "[if(parameters('grafanaEnabled'), reference('grafana').outputs.name.value, '')]"
    },
    "GRAFANA_ENDPOINT": {
      "type": "string",
      "value": "[if(parameters('grafanaEnabled'), reference('grafana').outputs.endpoint.value, '')]"
    },
    "GRAFANA_RESOURCE_ID": {
      "type": "string",
      "value": "[if(parameters('grafanaEnabled'), reference('grafana').outputs.id.value, '')]"
    },
    "DEFENDER_ENABLED": {
      "type": "bool",
      "value": "[parameters('defenderEnabled')]"
    },
    "DEFENDER_DEPLOYED": {
      "type": "bool",
      "value": "[and(parameters('defenderEnabled'), not(empty(parameters('defenderSecurityContactEmail'))))]"
    },
    "DEFENDER_FOR_CONTAINERS_ENABLED": {
      "type": "bool",
      "value": "[parameters('defenderForContainersEnabled')]"
    },
    "DEFENDER_FOR_KEY_VAULT_ENABLED": {
      "type": "bool",
      "value": "[parameters('defenderForKeyVaultEnabled')]"
    },
    "DEFENDER_FOR_COSMOS_DB_ENABLED": {
      "type": "bool",
      "value": "[parameters('defenderForCosmosDBEnabled')]"
    },
    "DEFENDER_FOR_APIS_ENABLED": {
      "type": "bool",
      "value": "[parameters('defenderForAPIsEnabled')]"
    },
    "DEFENDER_FOR_RESOURCE_MANAGER_ENABLED": {
      "type": "bool",
      "value": "[parameters('defenderForResourceManagerEnabled')]"
    },
    "PURVIEW_ENABLED": {
      "type": "bool",
      "value": "[parameters('purviewEnabled')]"
    },
    "PURVIEW_ACCOUNT_NAME": {
      "type": "string",
      "value": "[if(parameters('purviewEnabled'), reference('purviewAccount').outputs.name.value, '')]"
    },
    "PURVIEW_ENDPOINT": {
      "type": "string",
      "value": "[if(parameters('purviewEnabled'), reference('purviewAccount').outputs.endpoint.value, '')]"
    },
    "PURVIEW_CATALOG_ENDPOINT": {
      "type": "string",
      "value": "[if(parameters('purviewEnabled'), reference('purviewAccount').outputs.catalogEndpoint.value, '')]"
    },
    "PURVIEW_SCAN_ENDPOINT": {
      "type": "string",
      "value": "[if(parameters('purviewEnabled'), reference('purviewAccount').outputs.scanEndpoint.value, '')]"
    },
    "PURVIEW_MANAGED_RESOURCE_GROUP": {
      "type": "string",
      "value": "[if(parameters('purviewEnabled'), reference('purviewAccount').outputs.managedResourceGroupName.value, '')]"
    }
  }
}